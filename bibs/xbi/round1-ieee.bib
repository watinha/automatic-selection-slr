@article{1591,
 abstract = {Abstract:
An attractive and visually appealing appearance is important for the success of a website. Presentation failures in a site's web pages can negatively impact end users' perception of the quality of the site and the services it delivers. Debugging such failures is challenging because testers must visually inspect large web pages and analyze complex interactions among the HTML elements of a page. In this paper we propose a novel automated approach for debugging web page user interfaces. Our approach uses computer vision techniques to detect failures and can then identify HTML elements that are likely to be responsible for the failure. We evaluated our approach on a set of real-world web applications and found that the approach was able to accurately and quickly identify faulty HTML elements.},
 duplicado = {false},
 inserir = {false},
 title = {Detection and Localization of HTML Presentation Failures Using Computer Vision-Based Techniques},
 year = {2015}
}

@article{1592,
 abstract = {Abstract:
Failures in the presentation layer of a web application can negatively impact its usability and end users' perception of the application's quality. The problem of verifying the consistency of a web application's user interface across its different pages is one of the many challenges that software development teams face in testing the presentation layer. In this paper we propose a novel automated approach to detect and localize visual inconsistencies in web applications. To detect visual inconsistencies, our approach uses computer vision techniques to compare a test web page with its reference. Then to localize, our approach analyzes the structure and style of the underlying HTML elements to find the faulty elements responsible for the observed inconsistencies.},
 duplicado = {false},
 inserir = {false},
 title = {Detecting and Localizing Visual Inconsistencies in Web Applications},
 year = {2016}
}

@article{1594,
 abstract = {Abstract:
Presentation failures in a website can undermine its success by giving users a negative perception of the trustworthiness of the site and the quality of the services it delivers. Unfortunately, existing techniques for debugging presentation failures do not provide developers with automated and broadly applicable solutions for finding the site's faulty HTML elements and CSS properties. To address this limitation, we propose a novel automated approach for debugging web sites that is based on image processing and probabilistic techniques. Our approach first builds a model that links observable changes in the web site's appearance to faulty elements and styling properties. Then using this model, our approach predicts the elements and styling properties most likely to cause the observed failure for the page under test and reports these to the developer. In evaluation, our approach was more accurate and faster than prior techniques for identifying faulty elements in a website.},
 duplicado = {false},
 inserir = {false},
 title = {Using Visual Symptoms for Debugging Presentation Failures in Web Applications},
 year = {2016}
}

@article{1595,
 abstract = {Abstract:
CSS is a widely used language for describing the presentation semantics of HTML elements on the web. The language has a number of characteristics, such as inheritance and cascading order, which makes maintaining CSS code a challenging task for web developers. As a result, it is common for unused rules to be accumulated over time. Despite these challenges, CSS analysis has not received much attention from the research community. We propose an automated technique to support styling code maintenance, which (1) analyzes the runtime relationship between the CSS rules and DOM elements of a given web application (2) detects unmatched and ineffective selectors, overridden declaration properties, and undefined class values. Our technique, implemented in an open source tool called Cilla, has a high precision and recall rate. The results of our case study, conducted on fifteen open source and industrial web-based systems, show an average of 60% unused CSS selectors in deployed applications, which points to the ubiquity of the problem.},
 duplicado = {false},
 inserir = {false},
 title = {Automated analysis of CSS rules to support style maintenance},
 year = {2012}
}

@article{1597,
 abstract = {Abstract:
Behavior models of applications are widely used for diagnosing security incidents in complex web-based systems. However, Ajax techniques that enable better web experiences also make it fairly challenging to model Ajax application behaviors in the complex browser environment. In Ajax applications, server-side states are no longer synchronous with the views to end users at the client side. Therefore, to model the behaviors of Ajax applications, it is indispensable to incorporate client-side application states into the behavior models, as being explored by prior work. Unfortunately, how to leverage behavior models to perform security diagnosis in Ajax applications has yet been thoroughly examined. Existing models extracted from Ajax application behaviors are insufficient in a security context. In this paper, we propose a new behavior model for diagnosing attacks in Ajax applications, which abstracts both client-side state transitions as well as their communications to external servers. Our model articulates different states with the browser events or user actions that trigger state transitions. With a prototype implementation, we demonstrate that the proposed model is effective in attack diagnosis for real-world Ajax applications.},
 duplicado = {false},
 inserir = {false},
 title = {A Comprehensive Client-Side Behavior Model for Diagnosing Attacks in Ajax Applications},
 year = {2013}
}

@article{1598,
 abstract = {Abstract:
Cascading Style Sheets (CSS) is a widely-used language for defining the presentation of structured documents and user interfaces. Despite its popularity, CSS still lacks adequate tool support for everyday maintenance tasks, such as debugging and refactoring. In this paper, we present CSSDEV, a tool suite for analyzing CSS code to detect refactoring opportunities.(https://youtu.be/lu3oITi1XrQ).},
 duplicado = {false},
 inserir = {false},
 title = {CSSDev: refactoring duplication in cascading style sheets},
 year = {2017}
}

@article{1600,
 abstract = {Abstract:
Web applications can be easily made available to an international audience by leveraging frameworks and tools for automatic translation and localization. However, these automated changes can distort the appearance of web applications since it is challenging for developers to design their websites to accommodate the expansion and contraction of text after it is translated to another language. Existing web testing techniques do not support developers in checking for these types of problems and manually checking every page in every language can be a labor intensive and error prone task. To address this problem, we introduce an automated technique for detecting when a web page's appearance has been distorted due to internationalization efforts and identifying the HTML elements or text responsible for the observed problem. In evaluation, our approach was able to detect internationalization problems in a set of 54 web applications with high precision and recall and was able to accurately identify the underlying elements in the web pages that led to the observed problem.},
 duplicado = {false},
 inserir = {false},
 title = {Detecting and Localizing Internationalization Presentation Failures in Web Applications},
 year = {2016}
}

@article{1601,
 abstract = {Abstract:
The web has had a significant impact on our lives. A technology that was initially created for sharing documents across the network has evolved into a strong medium for developing and distributing software applications. In this paper, we first provide a concise overview of the evolution of the web itself. We then focus on some of the main industrial and research achievements in software analysis and testing techniques geared toward web apps, in the past two decades. We discuss static, dynamic, and hybrid analyses approaches, software testing and test adequacy techniques, as well as techniques that help developers write, analyze and maintain their code. Finally, we present some of the current and future challenges and research opportunities ahead in this field.},
 duplicado = {false},
 inserir = {false},
 title = {Software Analysis for the Web: Achievements and Prospects},
 year = {2016}
}

@article{1604,
 abstract = {Abstract:
Many APIs enable cross-platform system development by abstracting over the details of a platform, allowing application developers to write one implementation that will run on a wide variety of platforms. Unfortunately, subtle differences in the behavior of the underlying platforms make cross-platform behavior difficult to achieve. As a result, applications using these APIs can be plagued by bugs difficult to observe before deployment. These portability bugs can be particularly difficult to diagnose and fix because they arise from the API implementation, the operating system, or hardware, rather than application code. This paper describes CheckAPI, a technique for detecting violations of cross-platform portability. CheckAPI compares an application's interactions with the API implementation to its interactions with a partial specification-based API implementation, and does so efficiently enough to be used in real production systems and at runtime. CheckAPI finds latent errors that escape pre-release testing. This paper discusses the subtleties of different kinds of API calls and strategies for effectively producing the partial implementations. Validating CheckAPI on JavaScript, the Seattle project's Repy VM, and POSIX detects dozens of violations that are confirmed bugs in widely-used software.},
 duplicado = {false},
 inserir = {false},
 title = {Detecting latent cross-platform API violations},
 year = {2015}
}

@article{1605,
 abstract = {Abstract:
Cross-browser compatibility testing is a time consuming and monotonous task. In its most manual form, Web testers open Web pages one-by-one on multiple browser-platform combinations and visually compare the resulting page renderings. Automated cross-browser testing tools speed up this process by extracting screenshots and applying image processing techniques so as to highlight potential incompatibilities. However, these systems suffer from insufficient accuracy, primarily due to a large percentage of false positives. Improving accuracy in this context is challenging as the criteria for classifying a difference as an incompatibility are to some extent subjective. We present our experience building a cross-browser testing tool (Browser bite) based on image segmentation and differencing in conjunction with machine learning. An experimental evaluation involving a dataset of 140 pages, each rendered in 14 browser-system combinations, shows that the use of machine learning in this context leads to significant accuracy improvement, allowing us to attain an F-score of over 90%.},
 duplicado = {false},
 inserir = {true},
 title = {Browserbite: Accurate Cross-Browser Testing via Machine Learning over Image Features},
 year = {2013}
}

@article{1606,
 abstract = {JavaScript has become one of the most prevalent programming languages. Unfortunately, some of the unique properties that contribute to this popularity also make JavaScript programs prone to errors and difficult for program analyses to reason about. These properties include the highly dynamic nature of the language, a set of unusual language features, a lack of encapsulation mechanisms, and the no crash philosophy. This article surveys dynamic program analysis and test generation techniques for JavaScript targeted at improving the correctness, reliability, performance, security, and privacy of JavaScript-based software.},
 duplicado = {false},
 inserir = {false},
 title = {A Survey of Dynamic Analysis and Test Generation for JavaScript},
 year = {2017}
}

@article{1609,
 abstract = {Abstract:
This paper provides a retrospective examination of GUI Ripping - reverse engineering a workflow model of the graphical user interface of a software application - born a decade ago out of recognition of the severe need for improving the then largely manual state-of-the-practice of functional GUI testing. In these last 10 years, GUI ripping has turned out to be an enabler for much research, both within our group at Maryland and other groups. Researchers have found new and unique applications of GUI ripping, ranging from measuring human performance to re-engineering legacy user interfaces. GUI ripping has also enabled large-scale experimentation involving millions of test cases, thereby helping to understand the nature of GUI faults and characteristics of test cases to detect them. It has resulted in large multi-institutional Government-sponsored research projects on test automation and benchmarking. GUI ripping tools have been ported to many platforms, including Java AWT and Swing, iOS, Android, UNO, Microsoft Windows, and web. In essence, the technology has transformed the way researchers and practitioners think about the nature of GUI testing, no longer considered a manual activity; rather, thanks largely to GUI Ripping, automation has become the primary focus of current GUI testing techniques.},
 duplicado = {false},
 inserir = {false},
 title = {The first decade of GUI ripping: Extensions, applications, and broader impacts},
 year = {2013}
}

@article{1611,
 abstract = {Abstract:
Test cases that drive an application under test via its graphical user interface (GUI) consist of sequences of steps that perform actions on, or verify the state of, the application user interface. Such tests can be hard to maintain, especially if they are not properly modularized - that is, common steps occur in many test cases, which can make test maintenance cumbersome and expensive. Performing modularization manually can take up considerable human effort. To address this, we present an automated approach for modularizing GUI test cases. Our approach consists of multiple phases. In the first phase, it analyzes individual test cases to partition test steps into candidate subroutines, based on how user-interface elements are accessed in the steps. This phase can analyze the test cases only or also leverage execution traces of the tests, which involves a cost-accuracy tradeoff. In the second phase, the technique compares candidate subroutines across test cases, and refines them to compute the final set of subroutines. In the last phase, it creates callable subroutines, with parameterized data and control flow, and refactors the original tests to call the subroutines with context-specific data and control parameters. Our empirical results, collected using open-source applications, illustrate the effectiveness of the approach.},
 duplicado = {false},
 inserir = {false},
 title = {Automated Modularization of GUI Test Cases},
 year = {2015}
}

@article{1614,
 abstract = {Abstract:
Acceptance testing is an important part of software development and it is performed to ensure that a system delivers its required functionalities. Today, most modern interactive web applications are designed using Web 2.0 technologies, many among them relying on JavaScript. JavaScript enables the development of client-side functionality through the dynamic modification of the web-page's content and structure without calls to the server. This implies that server-side testing frameworks will necessarily fail to test the complete application behaviors. In this paper we present a method for automated acceptance testing of JavaScript web applications to ensure that required functionalities have been implemented. Using an intuitive, human-readable scripting language our method allows users to describe user stories in high level declarative test scripts and to then execute these test scripts on a web application using an automated website crawler. We also describe a case study that evaluates our approach in terms of capabilities to translate user stories in automated acceptance test scripts.},
 duplicado = {false},
 inserir = {false},
 title = {Automated Acceptance Testing of JavaScript Web Applications},
 year = {2012}
}

@article{1616,
 abstract = {Abstract:
Ajax-based Web 2.0 applications rely on stateful asynchronous client/server communication, and client-side runtime manipulation of the DOM tree. This not only makes them fundamentally different from traditional web applications, but also more error-prone and harder to test. We propose a method for testing Ajax applications automatically, based on a crawler to infer a state-flow graph for all (client-side) user interface states. We identify Ajax-specific faults that can occur in such states (related to, e.g., DOM validity, error messages, discoverability, back-button compatibility) as well as DOM-tree invariants that can serve as oracles to detect such faults. Our approach, called Atusa, is implemented in a tool offering generic invariant checking components, a plugin-mechanism to add application-specific state validators, and generation of a test suite covering the paths obtained during crawling. We describe three case studies, consisting of six subjects, evaluating the type of invariants that can be obtained for Ajax applications as well as the fault revealing capabilities, scalability, required manual effort, and level of automation of our testing approach.},
 duplicado = {false},
 inserir = {false},
 title = {Invariant-Based Automatic Testing of Modern Web Applications},
 year = {2011}
}

@article{1617,
 abstract = {Abstract:
As a result of the ubiquity and popularity of smart phones, the number of third party mobile applications is explosively growing. With the increasing demands of users for new dependable applications, novel software engineering techniques and tools geared towards the mobile platform are required to support developers in their program comprehension and analysis tasks. In this paper, we propose a reverse engineering technique that automatically (1) hooks into, dynamically runs, and analyzes a given iOS mobile application, (2) exercises its user interface to cover the interaction state space and extracts information about the runtime behaviour, and (3) generates a state model of the given application, capturing the user interface states and transitions between them. Our technique is implemented in a tool called iCrawler. To evaluate our technique, we have conducted a case study using six open-source iPhone applications. The results indicate that iCrawler is capable of automatically detecting the unique states and generating a correct model of a given mobile application.},
 duplicado = {false},
 inserir = {false},
 title = {Reverse Engineering iOS Mobile Applications},
 year = {2012}
}

@article{1618,
 abstract = {Abstract:
Graphical User Interface (GUI) testing literature emphasizes testing a system's functionality through its GUI, rather than testing visual aspects of the GUI itself. In this paper we introduce the notion of visual testing as a subset of GUI testing. To explore visual testing, we have conducted a study of defects in four open source systems. We found that visual defects represent between 16% and 33% of reported defects in those systems. Two categories of visual defects are identified with six subcategories within each of them. Other findings are also reported that are aimed at motivating the importance and the need for systematically conducting visual testing among researchers and practitioners.},
 duplicado = {false},
 inserir = {false},
 title = {Visual testing of Graphical User Interfaces: An exploratory study towards systematic definitions and approaches},
 year = {2012}
}

@article{1619,
 abstract = {Abstract:
Although asynchronous technologies such as Ajax make Rich Internet Applications (RIAs) responsive, they can result in unexpected behavior due to nondeterministic client-side processing and asynchronous communication. One difficulty in understanding such erroneous behavior lies in the unpredictable contexts of the running system. Dynamic behavior analysis techniques do not help to verify the correctness of certain "blind spots" in the execution path. In this work, we present a static approach for extracting all possible state transitions described in source code from the RIAs. Our approach is based on the assumption that user, server and self interactions with the RIAs can change the states of the application. Our method consists of three steps: (i) annotating interactions and extracting their controls in source code (ii) abstracting a call graph to extract relationships among the interactions and (iii) refining the relationships with interaction controls By extracting the state machines of test scenarios of the correct and wrong behavior, it can help developers to pinpoint the statements in the source code that lead to the erroneous behavior. Our approach has been evaluated against a few experimental cases and we conclude that it can extract comprehensible state machines in a reasonable time.},
 duplicado = {false},
 inserir = {false},
 title = {Extracting Interaction-Based Stateful Behavior in Rich Internet Applications},
 year = {2012}
}

@article{1620,
 abstract = {Abstract:
Context: Mobile app development is a relatively new phenomenon that is increasing rapidly due to the ubiquity and popularity of smartphones among end-users. Objective: The goal of our study is to gain an understanding of the main challenges developers face in practice when they build apps for different mobile devices. Method: We conducted a qualitative study, following a Grounded Theory approach, in which we interviewed 12 senior mobile developers from 9 different companies, followed by a semi-structured survey, with 188 respondents from the mobile development community. Results: The outcome is an overview of the current challenges faced by mobile developers in practice, such as developing apps across multiple platforms, lack of robust monitoring, analysis, and testing tools, and emulators that are slow or miss many features of mobile devices. Conclusion: Based on our findings of the current practices and challenges, we highlight areas that require more attention from the research and development community.},
 duplicado = {false},
 inserir = {false},
 title = {Real Challenges in Mobile App Development},
 year = {2013}
}

@article{1621,
 abstract = {Abstract:
Although several distance or similarity functions for trees have been introduced, their performance is not always satisfactory in many applications, ranging from document clustering to natural language processing. This research proposes a new similarity function for trees, namely Extended Subtree (EST), where a new subtree mapping is proposed. EST generalizes the edit base distances by providing new rules for subtree mapping. Further, the new approach seeks to resolve the problems and limitations of previous approaches. Extensive evaluation frameworks are developed to evaluate the performance of the new approach against previous proposals. Clustering and classification case studies utilizing three real-world and one synthetic labeled data sets are performed to provide an unbiased evaluation where different distance functions are investigated. The experimental results demonstrate the superior performance of the proposed distance function. In addition, an empirical runtime analysis demonstrates that the new approach is one of the best tree distance functions in terms of runtime efficiency.},
 duplicado = {false},
 inserir = {false},
 title = {Extended Subtree: A New Similarity Function for Tree Structured Data},
 year = {2013}
}

@article{1623,
 abstract = {Abstract:
When developing asynchronous JavaScript and XML (Ajax) applications, developers implement Ajax design patterns for increasing the usability of the applications. However, unpredictable contexts of running applications might conceal faults that will break the design patterns, which decreases usability. We propose a support tool called JSVerifier that auto-matically verifies interaction invariants; the applications handle their interactions in invariant occurrence and order. We also present a selective set of interaction invariants derived from Ajax design patterns, as input. If the application behavior breaks the design patterns, JSVerifier automatically outputs faulty execution paths for debugging. The results of our case studies show that JSVerifier can verify the interaction invariants in a feasible amount of time, and we conclude that it can help developers increase the usability of Ajax applications.},
 duplicado = {false},
 inserir = {false},
 title = {Automated verification of pattern-based interaction invariants in Ajax applications},
 year = {2013}
}

@article{1624,
 abstract = {Abstract:
Web applications have become the most popular type of software in the past decade, attracting the attention of both the academia and the industry. In parallel with their popularity, the complexity of aesthetics and functionality of web applications have also increased significantly, creating a big challenge for maintenance and cross-browser compliance testing. Since such testing and verification activities require visual analysis, web application testing has not been sufficiently automated. In this paper, we propose a novel pairwise image comparison approach suitable for web application testing where the location of layout faults needs to be detected efficiently while insignificant variations being neglected. This technique is developed based on the characteristics of fault patterns of browser layouts. An empirical study conducted with the industry partner shows our approach is more effective and efficient than existing methods in this area.},
 duplicado = {false},
 inserir = {false},
 title = {Adaptive Random Testing for Image Comparison in Regression Web Testing},
 year = {2014}
}

@article{1630,
 abstract = {Abstract:
To automatically test web applications, crawling-based techniques are usually adopted to mine the behavior models, explore the state spaces or detect the violated invariants of the applications. However, their broad use is limited by the required manual configurations for input value selection, GUI state comparison and clickable detection. In existing crawlers, the configurations are usually string-matching based rules looking for tags or attributes of DOM elements, and often application-specific. Moreover, in input topic identification, it can be difficult to determine which rule suggests a better match when several rules match an input field to more than one topic. This paper presents a natural-language approach based on semantic similarity to address the above issues. The proposed approach represents DOM elements as vectors in a vector space formed by the words used in the elements. The topics of encountered input fields during crawling can then be inferred by their similarities with ones in a labeled corpus. Semantic similarity can also be applied to suggest if a GUI state is newly discovered and a DOM element is clickable under an unsupervised learning paradigm. We evaluated the proposed approach in input topic identification with 100 real-world forms and GUI state comparison with real data from industry. Our evaluation shows that the proposed approach has comparable or better performance to the conventional techniques. Experiments in input topic identification also show that the accuracy of the rule-based approach can be improved by up to 22% when integrated with our approach.},
 duplicado = {false},
 inserir = {false},
 title = {Using Semantic Similarity in Crawling-Based Web Application Testing},
 year = {2017}
}

@article{1641,
 abstract = {Abstract:
As the use of mobile devices becomes increasingly ubiquitous, the need for systematically testing applications (apps) that run on these devices grows more and more. However, testing mobile apps is particularly expensive and tedious, often requiring substantial manual effort. While researchers have made much progress in automated testing of mobile apps during recent years, a key problem that remains largely untracked is the classic oracle problem, i.e., to determine the correctness of test executions. This paper presents a novel approach to automatically generate test cases, that include test oracles, for mobile apps. The foundation for our approach is a comprehensive study that we conducted of real defects in mobile apps. Our key insight, from this study, is that there is a class of features that we term user-interaction features, which is implicated in a significant fraction of bugs and for which oracles can be constructed - in an application agnostic manner -- based on our common understanding of how apps behave. We present an extensible framework that supports such domain specific, yet application agnostic, test oracles, and allows generation of test sequences that leverage these oracles. Our tool embodies our approach for generating test cases that include oracles. Experimental results using 6 Android apps show the effectiveness of our tool in finding potentially serious bugs, while generating compact test suites for user-interaction features.},
 duplicado = {false},
 inserir = {false},
 title = {Automated Generation of Oracles for Testing User-Interaction Features of Mobile Apps},
 year = {2014}
}

@article{1643,
 abstract = {Abstract:
Due to the exponential increase in the number ofmobile devices being used to access the World Wide Web, it iscrucial that Web sites are functional and user-friendly across awide range of Web-enabled devices. This necessity has resulted in the introduction of responsive Web design (RWD), which usescomplex cascading style sheets (CSS) to fluidly modify a Web site's appearance depending on the viewport width of the device in use. Although existing tools may support the testing of responsive Web sites, they are time consuming and error-prone to use because theyrequire manual screenshot inspection at specified viewport widths. Addressing these concerns, this paper presents a method thatcan automatically detect potential layout faults in responsively designed Web sites. To experimentally evaluate this approach, weimplemented it as a tool, called ReDeCheck, and applied itto 5 real-world web sites that vary in both their approach toresponsive design and their complexity. The experiments revealthat ReDeCheck finds 91% of the inserted layout faults.},
 duplicado = {false},
 inserir = {false},
 title = {Automatic Detection of Potential Layout Faults Following Changes to Responsive Web Pages (N)},
 year = {2015}
}

@article{1645,
 abstract = {Abstract:
It is well known that the fragmentation of Android ecosystem has caused severe compatibility issues. Therefore, for Android apps, cross-platform testing (the apps must be tested on a multitude of devices and operating system versions) is particularly important to assure their quality. Although lots of cross-platform testing techniques have been proposed, there are still some limitations: 1) it is time-consuming and error-prone to encode platform-agnostic tests manually, 2) test scripts generated by existing record/replay techniques are brittle and will break when replayed on different platforms, 3) Developers, and even test vendors have not equipped some special Android devices. As a result, apps have not been tested sufficiently, leading to many compatibility issues after releasing. To address these limitations, this paper proposes AppCheck, a crowdsourced testing service for Android apps. To generate tests that will explore different behavior of the app automatically, AppCheck crowdsources event trace collection over the Internet, and various touch events will be captured when real users interact with the app. The collected event traces are then transformed into platform-agnostic test scripts, and directly replayed on the devices of real users. During the replay, various data (e.g., screenshots and layout information) will be extracted to identify compatibility issues. Our empirical evaluation shows that AppCheck is effective and improves the state of the art.},
 duplicado = {false},
 inserir = {false},
 title = {AppCheck: A Crowdsourced Testing Service for Android Applications},
 year = {2017}
}

@article{1646,
 abstract = {Abstract:
Web applications pervade all aspects of human activity today. Therefore the content of the web has become extremely important. According to the great number of applications present nowadays, as a consequence, the manifestation of a bug has become very common. Testing modern web applications, so called "Web 2.0" applications has become more difficult due to their "stateful" nature, so the development of an approach capable of testing these applications in order to detect these bugs has become a necessity. The paper presents an automated approach for testing these dynamic web applications, where a combination of dynamic crawling and back-end testing is used to automatically detect behavioural bugs.},
 duplicado = {false},
 inserir = {false},
 title = {Searching for Behavioural Bugs with Stateful Test Oracles in Web Crawlers},
 year = {2017}
}

@article{1647,
 abstract = {Abstract:
Mobile devices such as smartphones and tablets have become an integral part of a person's life. These portable devices opened up a new software market for mobile application development resulting in various applications from healthcare, banking till entertainment. Therefore, there is a need for mobile applications to be reliable and maintainable. In this paper we introduce an equivalent class based technique for testing the graphical user interface of Android applications. This technique is a specification based approach, in which test cases are generated based on the functionalities and the graphical user interface specification. For each possible user interface event a set of test cases are generated using equivalence class partitioning approach. Once the test cases are generated for the given application, the app is executed based on the generated test cases and results are compared with the other testing techniques. From the obtained results we can infer that our approach detects more bugs than other previous work. In addition, this approach helps in the generation of test cases at an early in the app development life cycle.},
 duplicado = {false},
 inserir = {false},
 title = {Class coverage GUI testing for Android applications},
 year = {2016}
}

@article{1651,
 abstract = {Abstract:
Revolutionary changes in technology has brought a lots of different types of devices towards the Internet enabled services. It has become challenging to keep web sites functional and user friendly in a wide range of devices. Responsive Web Design (RWD) steps up to facilitate the necessary support to overcome those challenges with complex cascading style sheet (CSS) and JavaScript defined layouts. Fluidly modified layout that controls appearance of Responsive Web Pages (RWP) is subjected to erroneous when faulty CSS and JavaScript modifies the actual look of the web page. Though several methods have already been proposed to detect layout faults in web pages, they are error-prone and time consuming in nature. Thus an automatic approach considering both CSS and JavaScript defined dynamic layout fault detection technique have been proposed in this paper. Simulation result demonstrates that proposed technique outperforms the existing methods in case of time requirement, memory requirement and fault detection rate.},
 duplicado = {false},
 inserir = {false},
 title = {An automatic layout faults detection technique in responsive web pages considering JavaScript defined dynamic layouts},
 year = {2016}
}

