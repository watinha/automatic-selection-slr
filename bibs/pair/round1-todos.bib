@ARTICLE{I[48],
    inserir = {true},
  author = {T. C. Ahren},
  title = {Work in progress - effect of instructional design and pair programming
	on student performance in an introductory programming course},
  year = {2005},
  abstract = {California State University Monterey Bay (CSUMB) uses an outcomes-based
	delivery philosophy and focuses on measurable student learning. Because
	of the required outcome it was determined that the students needed
	more scaffolding or "metacognitive support" than is typically afforded
	in the introductory programming courses. The students were simply
	not capable of making the jump from simple programming concepts to
	being able to deliver a satisfactory completed portfolio piece. This
	paper reports on a study that investigated use of pair programming
	as a delivery methodology for an introductory Java programming course.},
  owner = {Katia},
  references = {Finding a place for computer-equipped lectures in a rich-lab environment

	An interactive lecture approach to teaching computer science

	Self-regulation empowerment program: A school-based program to enhance
	self-regulated and self-motivated cycles of student learning

	Making cooperative learning work. Theory into practice

	Experimenting with pair programming in the classroom ITCSE’03

	Improving the CS1 experience with pair programming

	A quantitative study of the differences in ideas generated by three
	different opportunities for classroom talk},
  timestamp = {2010.06.22}
}

@ARTICLE{E[1],
    inserir = {false},
  author = {J. Aiken},
  title = {Technical and Human Perspectives on Pair Programming},
  year = {2004},
  abstract = {Extreme Programming is presented as an answer to problems in software
	engineering. Extreme Programming is briefly introduced and one of
	its primary principles, pair programming, is examined more closely.
	Drawing from readings and Medtronic employee interviews, potential
	challenges to pair programming are discussed and analyzed. Finally,
	recommendations for those considering pair programming are suggested.},
  owner = {Katia},
  references = {Are agile methods good for design?

	Extreme programming explained: embrace change

	The costs and benefits of pair programming

	Testing Extreme Programming

	Peopleware

	Personal interview

	Managing technical people: innovation, teamwork, and the software
	process

	What is extreme programming

	The more more things change more

	Demystifying extreme programming: winning with a pair

	Extreme embedded - a report from the front line

	Extreme Programming: what is XP?

	Software Engineering: Theory and Practice

	Personal interview

	Information Technology Project Management

	How to make collaboration work: powerful ways to build consensus,
	solve problems, make decisions

	eXtreme programming: a gentle introduction

	XP123 - exploring extreme programming

	All I really need to know about pair programming I learned in kindergarten

	Pair Programming Illuminated

	Strengthening the Case for Pair Programming},
  timestamp = {2010.06.22}
}

@ARTICLE{E[2],
    inserir = {false},
  author = {H. Al-Kilidar and D. R. Jeffery and A. Aurum},
  title = {Description of an empirical experiment to measure effects of pair
	work on the design phase},
  year = {2004},
  abstract = {This paper presents a description of an empirical experiment into
	the effects of pair work on the design phase of the software development
	lifecycle. The aims of the experiment are to compare the quality
	of the design products produced by pair designers and individual
	designers as well as compare the efficiency and cost effectiveness
	of the pair work and the individual work paradigms in the design
	process. In addition, the experiment studies the partners expectations
	and practices during the pair work experience. In this paper we make
	the case for conducting such an experiment, and detail the experimental
	hypotheses, design, inputs, outputs, and evaluation measures.},
  owner = {Katia},
  references = {(no available): Available only to "Buy now ": http://www.pubzone.org/pages/publications/showVenue.do?venueId=4864

	(no available): Available only to "Buy now ": Description of an empirical
	experiment to measure effects of pair work on the design phase

	(no available): Available only to "Buy now ": Description of an empirical
	experiment to measure effects of pair work on the design phase

	(no available): Available only to "Buy now ": Description of an empirical
	experiment to measure effects of pair work on the design phase

	(no available): Available only to "Buy now ": Description of an empirical
	experiment to measure effects of pair work on the design phase

	(no available): Available only to "Buy now ": Description of an empirical
	experiment to measure effects of pair work on the design phase

	(no available): Available only to "Buy now ": Description of an empirical
	experiment to measure effects of pair work on the design phase

	(no available): Available only to "Buy now ": Description of an empirical
	experiment to measure effects of pair work on the design phase

	(no available): Available only to "Buy now ": Description of an empirical
	experiment to measure effects of pair work on the design phase

	(no available): Available only to "Buy now ": Description of an empirical
	experiment to measure effects of pair work on the design phase

	(no available): Available only to "Buy now ": Description of an empirical
	experiment to measure effects of pair work on the design phase},
  timestamp = {2010.06.22}
}

@ARTICLE{I[1],
    inserir = {true},
  author = {H. Al-Kilidar and P. Parkin and A. Aurum and R. Jeffery},
  title = {Evaluation of effects of pair work on quality of designs},
  year = {2005},
  abstract = {Quality is a key issue in the development of software products. Although
	the literature acknowledges the importance of the design phase of
	software lifecycle and the effects of the design process and intermediate
	products on the final product, little progress has been achieved
	in addressing the quality of designs. This is partly due to difficulties
	associated in defining quality attributes with precision and measurement
	of the many different types and styles of design products, as well
	as problems with assessing the methodologies utilized in the design
	process. In this research we report on an empirical investigation
	that we conducted to examine and evaluate quality attributes of design
	products created through a process of pair-design and solo-design.
	The process of pair-design methodology involves pair programming
	principles where two people work together and periodically switch
	between the roles of driver and navigator. The evaluation of the
	quality of design products was based on ISO/IEC 9126 standards. Our
	results show some mixed findings about the effects of pair work on
	the quality of design products.},
  owner = {Katia},
  references = {Software Quality Assurance, From theory to implementation

	The Meaning of Quality

	An Experiment in Small-Scale Application Software Engineering

	Software Design

	Strengthening the case for pair programming

	Experimenting with Industry's "Pair Programming" Model in the Computer
	Science Classroom

	The Case for Collaborative Programming

	The costs and benefits of pair programming

	The effects of "Pairpressure" and Pair-Learning" on Software engineering
	Education

	The Impact of Pair Programming on Student Performance

	 Pair Programming Illuminated

	eXtreme Programming explained, Embrace Change

	Experimental Evaluation of Pair Programming

	Embracing Change with Extreme Programming

	What is Extreme Programming

	Building Pair Programming Knowledge Through a Family of Experiments

	Fundamentals of Design

	Design Methods: Seeds of Human Futures

	All I really need to know about Pair Programming I learned in Kindergarten

	Software engineering Measurement

	A Model for Software Product Quality

	Software Quality

	14598-5 Information Technology-Software product evaluation

	Fundamentals of Software Engineering

	Evaluating Software Architectures Methods and Case Studies

	Structured Analysis and system Specification

	Beyond Requirements: Software making as Art

	A field Study Of The Software Design Process For Large Systems

	What is Software Quality

	The 10 Most Powerful Principles for Quality in Software and Software
	Organizations

	Research methods in Social Relations

	Software Product Evaluation

	Software Quality: The Elusive Target

	A hierarchical Model For Object-Oriented Design Quality

	An evaluation of MOOD Set of Object-Oriented Software Metrics

	Applying Win-Win to quality requirements: A case study

	The use of software complexity metrics in software maintenance

	Product Quality Framework: A Vehicle for Focusing on Product Quality
	Goals

	ISO/IEC 9126-1 Software engineering - Product quality

	ISO/IEC 9126-3 Software engineering - Product quality

	ISO/IEC 9126-2 Software engineering - Product quality

	ISO/IEC 9126-4 Software engineering - Product quality

	Writing effective Use Cases

	Planning an Empirical Experiment To Evaluate The Effects Of Pair Work
	On The Design Phase Of The Software Lifecycle

	Fundamental Research Statistics for Behavioral Sciences

	Statistical Methods for Business and Economics

	Introduction to Business Statistics: A Computer Integrated Approach

	Hints for Reviewing empirical Work in Software Engineering},
  timestamp = {2010.06.22}
}

@ARTICLE{E[3],
    inserir = {false},
  author = {M. Ally and F. Darroch and M. Toleman},
  title = {A framework for understanding the factors influencing pair programming
	success},
  year = {2005},
  abstract = {Pair programming is one of the more controversial aspects of several
	Agile system development methods, in particular eXtreme Programming
	(XP). Various studies have assessed factors that either drive the
	success or suggest advantages (and disadvantages) of pair programming.
	In this exploratory study the literature on pair programming is examined
	and factors distilled. These factors are then compared and contrasted
	with those discovered in our recent Delphi study of pair programming.
	Gallis et al. (2003) have proposed an initial framework aimed at
	providing a comprehensive identification of the major factors impacting
	team programming situations including pair programming. However,
	this study demonstrates that the framework should be extended to
	include an additional category of factors that relate to organizational
	matters. These factors will be further refined, and used to develop
	and empirically evaluate a conceptual model of pair programming (success).},
  owner = {Katia},
  references = {Extreme Programming Explained: Embrace Change

	The Mythical Man-Month Essays on Software Engineering

	The Costs and Benefits of Pair Programming

	Delphi Research in the Corporate Environment

	Paired Programming and Personality Traits

	Is Pair Programming a Valuable Practice?

	An Initial Framework for Research on Pair Programming

	Software Runaways

	Launching Extreme Programming at a Process-Intensive Company

	Empirical Studies of Pair Programming

	A Pair Programming Experience

	When Does a Pair Outperform Two Individuals?

	Groups: Theory and experience

	Using Extreme Programming in a Maintenance Environment

	Extreme Programming in a Customer Services Organization

	Delphi: A Reevaluation of Research and Theory

	Team Development and Pair Programming – Tasks and Challenges of the
	XP Coach

	A Delphi Study of Pair Programming

	The Collaborative Software Process

	Pair Programming Illuminated

	Strengthening the Case for Pair Programming

	The Complete Developer’s Guide to Surviving ‘Mission Impossible’ Projects},
  timestamp = {2010.06.22}
}

@ARTICLE{E[5],
    inserir = {false},
  author = {M. Alshayeb and W. Li},
  title = {An empirical study of system design instability metric and design
	evolution in an agile software process},
  year = {2005},
  abstract = {Software project tracking and project plan adjustment are two important
	software engineering activities. The class growth shows the design
	evolution of the software. The System Design Instability (SDI) metric
	indicates the progress of an object-oriented (OO) project once the
	project is set in motion. The SDI metric provides information on
	project evolution to project managers for possible adjustment to
	the project plan. The objectives of this paper are to test if the
	System Design Instability metric can be used to estimate and re-plan
	software projects in an XP-like agile process and study system design
	evolution in the Agile software process. We present an empirical
	study of the class growth and the SDI metric in two OO systems, developed
	using an agile process similar to Extreme Programming (XP). We analyzed
	the system evolutionary data collected on a daily basis from the
	two systems. We concluded that: the systems' class growth follows
	observable trends, the SDI metric can indicate project progress with
	certain trends, and the SDI metric is correlated with XP activities.
	In both of the analyzed systems, we observed two consistent jumps
	in the SDI metric values in early and late development phases. Part
	of the results agrees with a previous empirical study in another
	environment.},
  owner = {Katia},
  references = {An Empirical Validation of Object-Oriented Metrics in Two Different
	Iterative Software Processes

	Agile Modeling: Effective Practices for eXtreme Programming and the
	Unified Process

	A Validation of Object-Oriented Design Metrics as Quality Indicators

	Understanding and predicting the process of software maintenance release

	Embracing Change with Extreme Programming

	Defining and Validating Measures for Object-Based High-Level Design

	Modeling Development Effort in Object-Oriented Systems Using Design
	Properties

	A Metrics Suite for Object Oriented Design

	A Critique of Software Defect Prediction Models

	Quantitative Analysis of Faults and Failures in a Complex Software
	System

	Estimation and Prediction Metrics for Adaptive Maintenance Effort
	of Object-Oriented Systems

	A Vector-Based Approach to Software Size Measurement and Effort Estimation

	An empirical study of object-oriented system evolution

	Object-oriented metrics that predict maintainability

	Maintenance metrics for object-oriented paradigm

	Cost estimation based on business models

	Effort estimation and prediction of object-oriented systems

	Capability Maturity Model for software

	A controlled experiment on the impact of software structure on maintainability

	Design Measurement: Some Lessons Learned},
  timestamp = {2010.06.22}
}

@ARTICLE{E[4],
    inserir = {false},
  author = {M. Alshayeba and W. Li},
  title = {An empirical study of relationships among extreme programming engineering
	activities},
  year = {2006},
  abstract = {Extreme programming (XP) is an agile software process that promotes
	early and quick production of working code. In this paper, we investigated
	the relationship among three XP engineering activities: new design,
	refactoring, and error fix. We found that the more the new design
	performed to the system the less refactoring and error fix were performed.
	However, the refactoring and error fix efforts did not seem to be
	related. We also found that the error fix effort is related to number
	of days spent on each story, while new design is not. The relationship
	between the refactoring effort and number of days spent on each story
	was not conclusive.},
  owner = {Katia},
  references = {An empirical study of refactoring, new design, and error-fix efforts
	in extreme programming

	An empirical study of system design instability metric and design
	evolution in an agile software process

	Agile Modeling: Effective Practices for Extreme Programming and the
	Unified Process

	Embracing changes with extreme programming

	Extreme Programming Explained: Embracing Change

	Planning Extreme Programming

	The cost and benefits of pair programming

	Agile Software Development

	Refactoring: Improving the Design of Existing Code

	An investigation into the applicability and validity of object-oriented
	design metrics

	Extreme Programming Installed

	Empirically analysing object-oriented software evolution

	An Empirical Study of Extreme Programming

	The case for collaborative programming

	Limitations of agile software processes},
  timestamp = {2010.06.22}
}

@ARTICLE{E[6],
    inserir = {false},
  author = {R. Anderson and L. Bendix},
  title = {eXtreme Teaching: A framework for continuous improvement},
  year = {2006},
  abstract = {Many universities have experienced an increase in the intake of students
	and at the same time cuts in the budgets for teaching. Many teachers
	have discovered, for a number of reasons, that they have to adjust
	their teaching or even a course with short notice. These facts pose
	a challenge to the teachers’ agility in adapting to changes—and in
	doing it in a cost-efficient way. We propose eXtreme Teaching as
	a framework that allows teachers to focus on experimenting with and
	improving their teaching techniques without compromising quality.
	The framework and the associated practices provide quick, accurate
	feedback that teachers can act on. eXtreme Teaching will allow better
	student learning, stronger relationships with the students, increased
	interaction and development of the staff involved, less risk—and
	probably happier staff members. In this paper, we will describe the
	eXtreme Teaching framework and discuss and motivate its background.},
  owner = {Katia},
  references = {eXtreme Teaching

	Towards a Set of eXtreme Teaching Practices

	Pair Teaching—an eXtreme Teaching Practice

	Embracing Change with Extreme Programming

	Extreme Programming Explained—Embrace Change

	Teaching for Quality Learning at University

	Taxonomy of Educational Objectives

	Scholarship Reconsidered

	Credo: ‘‘Learning by doing’’

	Developing the Scholarship of Teaching in Higher Education: A disciplinebased
	approach

	The Scholarship of Teaching: Issues around an Evolving Concept

	Experiental Learning: Experience as the source of learning

	How University Teaching Award Winners Conceptualise Academic Work:
	Some further thought on the meaning of scholarship

	Teaching Excellence, Teaching Expertise, and the Scholarship of Teaching

	Scholarship of Teaching: A model

	Student Learning and the Scholarship of University Teaching

	Learning, Meaning, and Identity},
  timestamp = {2010.06.22}
}

@ARTICLE{E[8],
    inserir = {false},
  author = {E. Arisholm and H. Gallis and T. Dyba and D. I. K. Sjoberg},
  title = {Evaluating pair programming with respect to system complexity and
	programmer expertise},
  year = {2007},
  abstract = {A total of 295 junior, intermediate, and senior professional Java
	consultants (99 individuals and 98 pairs) from 29 international consultancy
	companies in Norway, Sweden, and the UK were hired for one day to
	participate in a controlled experiment on pair programming. The subjects
	used professional Java tools to perform several change tasks on two
	alternative Java systems with different degrees of complexity. The
	results of this experiment do not support the hypotheses that pair
	programming in general reduces the time required to solve the tasks
	correctly or increases the proportion of correct solutions. On the
	other hand, there is a significant 84 percent increase in effort
	to perform the tasks correctly. However, on the more complex system,
	the pair programmers had a 48 percent increase in the proportion
	of correct solutions but no significant differences in the time taken
	to solve the tasks correctly. For the simpler system, there was a
	20 percent decrease in time taken but no significant differences
	in correctness. However, the moderating effect of system complexity
	depends on the programmer expertise of the subjects. The observed
	benefits of pair programming in terms of correctness on the complex
	system apply mainly to juniors, whereas the reductions in duration
	to perform the tasks correctly on the simple system apply mainly
	to intermediates and seniors. It is possible that the benefits of
	pair programming will exceed the results obtained in this experiment
	for larger, more complex tasks and if the pair programmers have a
	chance to work together over a longer period of time.},
  owner = {Katia},
  references = {A Controlled Experiment with Professionals to Evaluate the Effect
	of a Delegated versus Centralized Control Style on the Maintainability
	of Object-Oriented Software

	Evaluating the Effect of a Delegated versus Centralized Control Style
	on the Maintainability of Object-Oriented Software

	A web-based support environment for software engineering experiments

	Embracing Change with Extreme Programming

	Extreme Programming Explained: Embrace Change

	Social Facilitation: A Meta-Analysis of 241 Studies

	Object-Oriented Program Comprehension: Effect of Expertise, Task and
	Phase, Empirical Software Engineering

	Activity Patterns of Pair Programming

	The costs and benefits of pair programming

	Statistical Power Analysis for the Behavioral Sciences

	A Power Primer

	Constantine on Peopleware

	Quasi-Experimentation—Design & Analysis Issues for Field Settings

	A generative development-process pattern language

	A Systematic Review of Statistical Power in Software Engineering Experiments

	Analyzing Distributed Cognition in Software Teams: A Case Study of
	Team Programming During Perfective Software Maintenance

	Group Dynamics

	An Initial Framework for Research on Pair Programming

	Pair-Programming Effect on Developers Productivity

	A Simple Sequentially Rejective Multiple Test Procedure

	Task Complexity and Expertise as Determinants of Task Perceptions
	and Performance

	Social Loafing: A Meta-Analytic Review and Theoretical Integration

	Preliminary guidelines for empirical research in software engineering

	When Does a Pair Outperform Two Individuals?

	A Cognitive Model for Solo Programming and Pair Programming,

	The effects of pair-programming on performance in an introductory
	programming course

	Generalized Linear Models: With Applications in Engineering and the
	Sciences

	Are Reviews an Alternative to Pair Programming?

	Two controlled experiments concerning the comparison of pair programming
	to peer review

	Experimental Evaluation of Pair Programming

	The case for collaborative programming

	Analyzing the Cost and Benefit of Pair Programming

	Experimental and Quasi-Experimental Designs for Generalized Causal
	Inference

	Identifying the difficulties of object-oriented development

	Challenges and Recommendations when Increasing the Realism of Controlled
	Software Engineering Experiments

	Designing documentation to compensate for delocalized plans

	Development Sequence in Small Groups

	The psychology of computer programming

	In support of student pair-programming

	Pair Programming Illuminated

	An Initial Exploration of the Relationship Between Pair Programming
	and Brooks' Law

	Strengthening the Case for Pair Programming

	In Support of Pair Programming in the Introductory Computer Science
	Course

	The collaborative software process(sm)

	Characterizing Your Application's Control Style

	Object-oriented design: a responsibility-driven approach

	Experiments: Planning, Analysis, and Parameter Design Optimization

	Social Facilitation},
  timestamp = {2010.06.22}
}

@ARTICLE{E[9],
    inserir = {false},
  author = {K. Assiter},
  title = {Balancing depth and breadth in the data structure course},
  year = {2005},
  abstract = {The data structures (CS 103) course in a computer science curriculum
	is the bridge between the CS 101/CS 102 sequence, which introduces
	the fundamentals of programming, and the algorithms course, which
	emphasizes rigorous analysis. The challenge for CS 103 instructors
	is to balance the breadth and depth of coverage of data structures
	material: pacing the assignment of projects with lectures so that
	all of the fundamental data structure topics are covered, and assigning
	large-scale projects to students without overwhelming them with time
	and complexity requirements. To address this challenge, this paper
	proposes an approach that combines pair programming, weekly assigned
	large-scale student-centered projects, web-based portfolios, a multiple-intelligence
	focus for material presentation [3], and process log (journal) entries
	submitted in conjunction with assignments. The approach is evaluated
	with an analysis of student questionnaires and an evaluation of written
	responses from students' process-logs. This paper documents the research
	and suggests directions for further study.},
  owner = {Katia},
  references = {Bicycle club mileage log: a servlet application for teaching Web programming

	Group projects across the curriculum

	A multiple-intelligences approach to teaching number systems

	The role of the data structures course in the computing curriculum

	Experiences with pair programming at a small college

	Software development productivity and cycle time reduction

	The costs and benefits of pair programming

	Pair programming and pair trading: effects on learning and motivation
	in a CS2 course

	Programming portfolios on the Web: an interactive approach

	Using process journals to gain qualitative understanding of beginning
	programmers},
  timestamp = {2010.06.22}
}

@ARTICLE{E[10],
    inserir = {false},
  author = {S. Atsuta and S. Matsuura},
  title = {eXtreme Programming support tool in distributed environment},
  year = {2004},
  abstract = {eXtreme Programming (XP) is an agile software development process
	in which both short period iterative development arid communication
	between project members are important. Software development aims
	at producing high quality programs within a promised period. To gain
	an improvement in product quality, XP proposes twelve practices such
	as pair programming, test driven development, refactoring, etc. Pair
	programming makes it possible for all project members to deepen understanding
	of their programs, and also it becomes easy to find the error of
	them. Consequently, it improves quality of their programs. It is
	required that the pair has to work together with sufficient communication.
	However, in realistic software development, it is necessary to carry
	out development in the distributed environment by time and spatial
	restrictions of developers, such as office environment, and telecommuting,
	an international project. In XP, since communication is important,
	we propose XP support environment on a network from the viewpoint
	of pair programming support so that the quality of a program can
	be improved also in distributed environment.},
  owner = {Katia},
  references = {eXtreme Programming eXplained: Embrace Change

	Extreme Programming Applied: Playing to Win

	Pair Programming illuminated

	Awareness and Coordination in Shared Workspaces},
  timestamp = {2010.06.22}
}

@ARTICLE{E[11],
    inserir = {false},
  author = {J. Auvinen and R. Back and J. Heidenberg and P. Hirkman and L. Milovanov},
  title = {Software process improvement with agile practices in a large telecom
	company},
  year = {2006},
  abstract = {Besides the promise of rapid and efficient software development, agile
	methods are well-appreciated for boosting communication and motivation
	of development teams. However, they are not practical "as such" in
	large organizations, especially because of the well-established,
	rigid processes in the organizations. In this paper, we present a
	case study where a few agile practices were injected into the software
	process of a large organization in order to pilot pair programming
	and improve the motivation and competence build-up. The selected
	agile practices were pair programming, the planning game and collective
	code ownership. We show how we adjust these practices in order to
	integrate them into the existing software process of the company
	in the context of a real software project.},
  owner = {Katia},
  references = {Analyses of an Agile Methodology Implementation

	Adapting PROFES for Use in an Agile Process: An Industry Experience
	Report

	Assessing XP at a European Internet Company

	Quantitative Survey on Extreme Programming Projects

	Software Development and Experimentation in an Academic Environment:
	The Gaudi Experience

	How Good are Agile Methods?

	Evaluation of Agile Software Development: The Controlled Case Study
	approach

	Teaching Extreme Programming to Large Groups of Students

	Introducing Agile Methods: Three Years of Experience

	A Cross-Program Investigation of Students’ Perceptions of Agile Methods

	Agile Software Development: The Business of Innovation

	Working in Pairs as a Means for Design Knowledge Building: An Empirical
	Study

	Get Ready for Agile Methods, with Care

	Extreme Programming Explained: Embrace Change

	Agile Software Development in Large Organizations

	Evolving Agile in the Enterprise: Implementing XP on a Grand Scale

	Software Process Improvement: Practical Guidelines for Business Success

	Introducing a Customer Representative to High Requirement Uncertainties

	Improving the Engineering Process Area at Ericsson with Agile Practices

	Pair Programming Illuminated

	The Costs and Benefits of Pair Programming

	Constantine on Peopleware

	Extreme Programming and the Software Design Course

	Case Study: Extreme Programming in a University Environment

	Experimenting with Industry’s Pair-Programming Model in the Computer
	Science Classroom

	The Case for Collaborative Programming

	Software Development and Experimentation in an Academic Environment:
	The Gaudi Experience

	Extreme Programming: A gentle introduction website

	Extreme Programming Installed

	Planning Extreme Programming

	People in Organizations: An Introduction to Organizational Behavior},
  timestamp = {2010.06.22}
}

@ARTICLE{E[12],
    inserir = {false},
  author = {R. J. Back and L. Milovanov and I. Porres and V. Preoteasa},
  title = {XP as a Framework for Practical Software Engineering Experiments},
  year = {2003},
  abstract = {We discuss how Extreme Programming (XP) can be used as the base software
	development method to per-form practical experiments in software
	engineering. We show how the main features of XP can help us to minimize
	some of the problems and difficulties that appear when trying to
	perform such experiments in a university environment. We also discuss
	the execution and experiences from one experiment studying a new
	methodology: the Stepwise Feature Introduction.},
  owner = {Katia},
  references = {Software Construction by Stepwise Feature Introduction

	An Experiment on Extreme Programming and Stepwise Feature Introduction

	Refinement Calculus -A Systematic Introduction

	Extreme Programming Explained: Embrace change

	Introducing Extreme Programming in a Research and Development Laboratory

	The Costs and Benefits of Pair Programming

	Constantine on Peopleware

	Design Patterns

	Extreme Programming and the Software Design Course

	Results from Software Engineering Research into Open Source Development
	Projects Using Public Data

	RUP / XP Guidelines: Pair Programming

	Object-Oriented Software Construction

	Case Study: Extreme Programming in a University Environment

	OMG Unified Language Specification

	Extreme Programming Explored

	Experimenting with Industry’s Pair-Programming Model in the Computer
	Science Classroom},
  timestamp = {2010.06.22}
}

@ARTICLE{E[13],
    inserir = {false},
  author = {P. Baheti and E. F. Gehringer and P. D. Stotts},
  title = {Exploring the efficacy of distributed pair programming},
  year = {2002},
  owner = {Katia},
  abstract = {Pair programming is one of the twelve practices of Extreme Programming
	(XP). Pair programming is usually performed by programmers that are
	collocated-working in front of the same monitor. But the inevitability
	of distributed development of software gives rise to important questions:
	How effective is pair programming if the pairs are not physically
	next to each other? What if the programmers are geographically distributed?
	An experiment was conducted at North Carolina State University to
	compare different working arrangements of student teams developing
	object-oriented software. Teams were both collocated and in distributed
	environments; some teams practiced pair programming while others
	did not. In particular, we compared the software developed by virtual
	teams using distributed pair programming against collocated teams
	using pair programming and against virtual teams that did not employ
	distributed pair programming. The results of the experiment indicate
	that it is feasible to develop software using distributed pair programming,
	and that the resulting software is comparable to software developed
	in collocated or virtual teams (without pair programming) in productivity
	and quality.},
  references = {Extreme Programming Explained: Embrace Change

	A Multidisciplinary Virtual Team

	Distance Matters

	The Collaborative Software Process PhD Dissertation

	The case for collaborative programming

	Pair Programming Illuminated

	Strengthening the case for pair-programming

	The costs and benefits of pair programming

	The Boundless Team: Virtual Teaming

	Support for Distributed Teams in Extreme Programming

	Virtual Teams in Computing Education

	Leading Virtual Teams

	Awareness and Coordination in Shared Workspaces},
  timestamp = {2010.06.21}
}

@ARTICLE{I[2],
    inserir = {true},
  author = {V. Balijepally},
  title = {Task complexity and effectiveness of pair programming: An experimental
	study},
  year = {2006},
  abstract = {Extreme Programming, which is recently gaining popularity as an alternate
	software development methodology, involves two programmers working
	collaboratively to develop software. This study examined the efficacy
	of pair programming by comparing the effectiveness of collaborating
	pairs with those of programmers working individually. Student subjects
	participated in a controlled laboratory experiment. Two factors were
	manipulated in the experiment: programming task complexity (high
	vs. low) and programmers working individually vs. in pairs. The performance
	of programmer pairs was compared with those of the best performer
	and the second best performer from among nominal pairs. An important
	finding of the study is that programmer pairs outperform second best
	programmers in nominal groups, but perform at comparable levels as
	the best programmers in nominal groups. The best programmers among
	collaborating pairs also develop significantly better understanding
	of the problem domain, reflected in their task mental model, compared
	to the second-best individuals working individually in nominal pairs.
	Their mental models were however comparable to that of the best programmers
	in the nominal groups. These two relationships were found to be consistent
	across different levels of task complexity. In terms of perceptual
	outcomes, the best programmers among the collaborating pairs have
	comparable levels of overall satisfaction as the best and second-best
	individuals in the nominal groups, while second-best programmers
	among collaborating pairs have higher satisfaction than the best
	and second-best individuals in the nominal pairs. An additional finding
	was that best programmers among the collaborating pairs have higher
	confidence in their solution than best programmers in nominal pair
	when task complexity is low, but not when it is high.},
  owner = {Katia},
  references = {The Role of Domain Experience in Software Design

	Social Facilitation from Triplett to Electronic Performance Monitoring

	Electronic Performance Monitoring and Social Context: Impact on Productivity
	and Stress

	Computering Monitoring of Work Performance: Extending the Social Facilitation
	Framework to Electronic Presence

	The Group Attibution Error

	Realism in Confidence Judgments as a Function of Working in Dyads
	or Alone

	Tightening the Iron Cage: Concertive Control in Self-Managing Teams

	Distraction-Conflict Theory: Progress and Problems

	Interacting Effects of Control Motivation

	A Self Presentational View of Social Phenomena

	Embracing Change with Extreme Programming

	Extreme Programming Explained: Embrace Change

	Rewards and Organizational Goal Achievement: A Case Study of Toyota
	Motor Manufacturing in Kentucky

	Understanding Information Systems Continuance: An Expectation-Confirmation
	Model

	Get Ready for Agile Methods with Care

	Perspective Making and Perspective Taking in Communities of Knowing

	Social Facilitation: A Self-Presentational View

	Social Facilitation: A Meta-Analysis of 241 Studies

	The Role of Personality in Task and Relationship Conflict

	Effects of Personal Involvement: Thought-Provoking Implications for
	Social Loafing

	Communication Networks in Task-Performing Groups: Effects of Task
	Complexity, Time Pressure, and Interpersonal Dominance

	Task Complexity Affects Information-Seeking and Use

	Task Complexity: A Review and Analysis. Academy of Management Review

	The Interactive Effects of Task Complexity and Participation on Task-Performance
	- a Field Experiment

	Relations Between Work Group Characteristics and Effectiveness: Implications
	for Designing Effective Work Groups

	The Impact of Communication Mode and Task Complexity on Small Group
	Performance and Member Satisfaction

	Mental Models in Human-Computer Interaction

	Computer-Aided Monitoring: Its Influence on Employee Job Satisfaction
	and Turnover

	Computer Anxiety and Perception of Task Complexity in Learning Programming-Related
	Skills

	The Decision is In: Agile versus Heavy Methodologies

	Cognitive Conservatism and Radicalism in Individual and Group Decisions

	Agile Software Development Joins the "Would-Be" Crowd

	Agile Software Development 2: The People Factor

	The Costs and Benefits of Pair Programming

	How People Construct Mental Models

	Social Psychology of Group Processes for Decision-Making

	Social Facilitation

	Social Facilitation of the Dominant Responses by the Presence of an
	Audience and the Mere Presence of Others

	Software Development Worldwide: The State of the Practice

	Perceived Group Variables as Moderators of the Task Characteristics
	- Individual Performance Relationship

	Group Performance

	An Empirical Study of the Efficacy of a Computerized Negotiation Support
	System

	Team-based rewards: Current empirical evidence and directions for
	future research

	Team-Based Rewards: Current Empirical Evidence and Directions for
	Future Research

	Three Studies of Problem Solving in Collaborative Software Development

	The Impact of Computer Monitoring and Negative Affectivity on Task
	Performance and Satisfaction

	LMX and Subordinate Performance: The Moderating Effects of Task Characteristics

	Concept Attainment by Pairs and Individuals as a Function of Vocalization

	Extreme Programming: It's Worth a Look

	Group versus Individual Problem-Solving

	Group versus Individual Gambling Behavior: Reexamination and Limitation

	Why do Lay People Believe that Satisfaction and Performance are Correlated?
	Possible Sources of a Commonsense Theory

	Analyzing Distributed Cognition in Software Teams: A Case Study of
	Team Programming During Perfective Software Maintenance

	Responsibility Attribution by Groups and Individuals: The Effects
	of the Interaction Episode

	The Relative Quality of Decisions Written by Individuals and by Groups
	as the Available Time for Problem Solving is Increased

	Affective Contributions of Cooperative and Group Goal Structures

	The Effects of Dyadic Group Experience in Subsequent Individual Performance

	Impact of Task and Technology on Group Performance

	Effects of Task Characteristics on Group Products

	Group Tasks, Group Interaction Processes and Group Performance Effectiveness:
	A Review and Proposed Integration

	A New Strategy for Job Enrichment

	Multivariate Data Analysis

	Individual Versus Group

	Small Group Research: A Handbook

	Social Loafing and Social Facilitation

	The Role of Evaluation in Eliminating Social Loafing

	Effects of Task Difficulty and Task Uniqueness on Social Loafing

	Social Loafing and Group Evauation

	Coworker Abiity and Effort as Determinants of Individual Effort on
	a Collective Task

	The Number of Decision Makers and the Level of Risk Taking Within
	a Group

	Review Essay: Experimental Evidence on Group Accuracy

	Interaction with Others Increases Decision Confidence but Not Decision
	Quality: Evidence against Information Collection Views of Interactive
	Decision Making

	Agile Software Development Ecosystems

	Extreme Programming (White paper): Agile Project Management Advisory
	Service

	Agile Project Management: Principles and Tools

	Agile Software Development 1: The Business of Innovation

	Group versus Individual Performance: Are N + 1 Heads Better than One?

	Goal Setting by Groups Performing an Additive Task: A Comparison with
	Individual Goal Setting

	Positive Reactions to Working in Groups in a Study of Group and Individual
	Goal Decision Making

	The Emerging Conceptualization of Groups as Information Processors

	When Teamwork Quality Matters: Task Innovativeness as a Moderator
	of the Teamwork-Performance Relationship in Software Development
	Projects

	Distributed Cognition: Toward a New Foundation for Human-Computer
	Interaction Research

	The Effects of Cooperative and Individualistic Reward on Intrinsic
	Motivation

	Evaluation of Diagnostic Tests by Individuals and Small Groups

	Social Facilitation in a Coaction Setting: An Examination of the Effects
	over Learning Trials

	Job Satisfaction and Job Performance: A Meta-Analysis

	Effects of Task Difficulty and Interunit Interdependence on Information
	Processing Systems

	Equity in Effort: An Explanation of the Social Loafing Effect

	Social Loafing on Difficult Tasks: Working Collectively can Improve
	Performance

	The Effect of Task Complexity and Conflict Handling Styles on Computer-Supported
	Negotiations

	Why Differences Make a Difference: A Field Study of Diversity, Conflict,
	and Performance in Workgroups

	The Effects of Cooperative and Individualized Instruction on Student
	Attitudes and Achievement

	Mental Models in Cognitive Science

	Mental Models

	Mental Models and Human Reasoning

	Individual and Group Performance on an Anagrams Task

	Group Performance as a Function of Group Type, Task Condition and
	Scholastic Level

	Social Loafing: A Meta-Analytic Review and Theoretical Integration

	Individual and Group Performance: Effects of Task Complexity and Information

	Motivation Losses in Groups: A Social Dilemma Analysis

	The Dispensability of Member Effort and Group Motivation Loses: Free
	Rider Effects

	Group Performance and Decision Making

	Why is Programming (Sometimes) so Difficult? Programming as Scientific
	Discovery in Multiple Problem Spaces

	Verbal Interaction and Problem-Solving Within Computer-Assisted Coperative
	Learning Groups

	Explanation, Imagination, and Confidence in Judgment

	The Effects of Electronic Performance Monitoring on Stress: Locus
	of control as a Moderator Variable

	Mental Models, Team Mental Models, and Performance: Process, Development,
	and Future Directions

	Team mental models: Techniques, methods, and analytic approaches

	Social Comparison and Goal Setting in Brainstorming Groups

	The Psychology of Social Impact

	Group-to-Individual and Individual-to-Group Problem-Solving Transfers

	Groups Perform Better than the Best Individuals on Letter-to-Numbers
	Problems

	Demonstrability and Social Combination Processes on Mathematical Intellective
	Tasks

	Collective Versus Individual Induction: Recognition of Truth, Rejection
	of Error, and Collective Information Processing

	Cognitive Processes in Program Comprehension

	An Empirical Study of Computer System Learning: Comparison of Co-discovery
	and Self-discovery Methods

	Empirical Findings in Agile Methods

	Toward a Theory of Task Motivation and Incentives

	Job Satisfaction and Job Performance: A Theoretical Analysis

	The Nature and Causes of Job Satisfaction

	Work Motivation and Satisfaction: Light at the End of the Tunnel

	What Should we Do About Motivation Theory?

	How Internet Companies Build Software

	The Measurement of Team Mental Models: We Have no Shared Schema

	Operationalizing the Effect of the Group on the Individual: A Self-
	Attention Perspective

	Productivity Loss in Brainstorming Groups: A Meta-Analytic Integration

	Improving the CS1 Experience with Pair Programming

	Experimental Evaluation of Pair Programming

	Applied Linear Models

	Human Problem Solving

	The Case for Collaborative Programming

	Psychometric Theory

	A Review of the Influence of Group Goals on Group Performance

	CMM Versus Agile Development: Religious Wars and Software Development

	Perception of Performance in Group Brainstorming: The Illusion of
	Group Productivity

	Measurement, Design, and Analysis: An Integrated Approach

	Confidence, Uncertainty, and the Use of Information

	A Meta-Analysis of the Relationships Between Individual Job Satisfaction
	and Individual Performance

	The Effects of Group Size on Cognitive Effort and Evaluation

	From Text to Situation to Equation: Cognitive Simulation of Understanding
	and Solving Mathematical Word Problems

	Developmental Analysis of Understanding Language About Quantities
	and of Solving Problems

	Schema Creation in Programming

	Social Performance

	The SAGE Handbook of Social Psychology

	Identifiability as a Deterrent to Social Loafing: Two Cheering Experiments

	Social Loafing and Social Compensation: The Effects of Expectations
	of Co-Worker Performance

	The Collaborative Software Process

	All I Really Need to Know About Pair Programming I Learned in Kindergarten

	Strengthening the Case for Pair Programming

	Mental Models: Theory and Application in Human Factors

	Kohler Rediscovered: the Anti-Ringelmann Effect

	Task Complexity - Definition of the Construct

	Task Complexity as Moderator of Goal Effects: A Meta-Analysis

	Risky Aggression in Individuals and Groups

	The Complete Software Developer's Guide to Surviving 'Mission Impossible'
	Projects

	Social Facilitation

	Extending the Social Information Processing Perspective: New Links
	to Attitudes, Behaviors, and Perceptions

	Productivity and Group Success: Team Spirit vs. the Individual Achiever

	The Social Influence of Confidence in Group Decision Making},
  timestamp = {2010.06.22}
}

@ARTICLE{E[14],
    inserir = {false},
  author = {L. L. Beck and A. W. Chizhik and A. C. McElroy},
  title = {Cooperative learning techniques in CS1: Design and Experimental Evaluation},
  year = {2005},
  abstract = {A set of cooperative learning exercises were designed for use in a
	Java-based CS1 course. The exercises used specific roles to focus
	students' attention on key concepts of the Java

	language, and on key mental processes of programming and problem solving.
	A controlled experiment was conducted to evaluate the effectiveness
	of this approach. The results show that the cooperative learning
	experience had a significant positive effect on student performance,
	and may have been of special benefit to women and minority students.},
  owner = {Katia},
  references = {Extreme Programming Explained : Embrace Change

	Combining Cooperative Learning and Peer Instruction in Introductory
	Computer Science

	Computer Supported Peer Learning in an Introductory Computer Science
	Course

	Joining Together: Group Theory and Group Skills

	Learning Together and Alone

	Active Learning: Cooperation in the College Classroom

	On Understanding Compatibility of Student Pair Programmers

	An Assessment of Cooperative Learning Used for Basic Computer Skills
	Instruction in the College Classroom

	The Effects of Pair-Programming on Performance in an Introductory
	Programming Course

	Testing Research Hypotheses with the General Linear Model

	Student Diversity Requires Different Approaches to College Teaching

	The Effects of Cooperative Learning in a Second-Semester University
	Computer Science Course

	Handbook of Cooperative Learning Methods

	Cooperative Learning: Theory, Research, and Practice

	Formal Methods, Design, and Collaborative Learning in the First Computer
	Science Course

	Collaborative Learning: A Case Study for CS1 at Grinnell College and
	UT–Austin

	The Collaborative Software Process

	Experimenting with Industry's 'Pair-Programming' Model in the Computer
	Science Classroom

	Strengthening the Case for Pair Programming

	In Support of Student Pair Programming

	In Support of Pair Programming in the Introductory Computer Science
	Course

	Peer Learning in an Introductory Computer Science Course

	Guidelines for Collaborative Learning in Computer Science},
  timestamp = {2010.06.22}
}

@ARTICLE{E[15],
    inserir = {false},
  author = {E. Bellini and G. Canfora and A. Cimitile and F. Garcia and M. Piattini
	and C. A. Visaggio},
  title = {The Impact of educational background on design knowledge sharing
	during pair programming: An empirical study},
  year = {2005},
  abstract = {The management of knowledge in software processes is becoming a challenging
	concern for researchers and practitioners, Explicit knowledge can
	be formalized in many kinds of documents and rules, and consequently
	transferred in a number of manners. On the contrary, tacit knowledge
	cannot be formalized, because it is mainly retained in personal cognitive
	models and consists of individual capabilities of dealing with problems.
	The design of software systems requires a consistent deployment of
	tacit knowledge, and pair programming has shown great promises for
	helping to share knowledge between programmers. It is a common experience
	that programmers come not only from computer science and engineering
	curricula, but also from other education degrees, such as mathematics,
	natural sciences, and social sciences. In this case they attend proper
	specialist post graduation courses. We have executed an experiment
	in order to verify the relationship between educational background
	of pair's components and knowledge sharing throughout working in
	pairs while designing software systems.},
  owner = {Katia},
  references = {Improving Software Engineering practice through competency based personnel
	reviews

	Wanted: Project teams with a blend of IS Professional orientations

	A dynamic theory of organizational knowledge creation

	Knowledge, Knowledge Work and Organizations: An Overview and Interpretation

	Developmental Work Research: Reconstructing Expertise through Expansive
	Learning

	Knowledge and the Theory of Organizations: Organizations as Activity
	Systems and the Reframing of Management

	The Knowing Organization

	The Effects of "Pair-Pressure" and "Pair-Learning"

	Working in pairs as a means for design knowledge building: an empirical
	study

	The case for collaborative programming

	Experimental Evaluation of Pair Programming

	Straightening the case for pair programming

	Lessons learned about Distributed Pair programming: what are the knowledge
	needs to address?

	In Support of Student Pair-Programming

	The Effects of Pair Programming on Performance in an introductory
	Programming Course

	Coupling Pair Programming and Writing: Learning About Students’ Perceptions
	and Processes

	The Collaborative Software Process PhD Dissertation

	Construct validation of tacit Knowledge for military Leadership

	Using Empirical Studies during Software Courses

	Preliminary Guidelines for Empirical Research in Software Engineering

	Using Students as Subjects – A comparative Study of Students & Professionals
	in Lead-Time Impact Assessment

	Building Knowledge Through Families of Experiments Experimentation
	in Software Engineering: An Introduction},
  timestamp = {2010.06.22}
}

@ARTICLE{I[3],
    inserir = {true},
  author = {E. Bellini and G. Canfora and F. García and M. Piattini and C. A.
	Visaggio},
  title = {Pair designing as practice for enforcing and diffusing design knowledge},
  year = {2005},
  abstract = {Evolving software's design requires that the members of the team acquire
	a deep and complete knowledge of the domain, the architectural components,
	and their integration. Such information is scarcely addressed within
	the design documentation and it is not trivial to derive it. A strategy
	for enforcing the consciousness of such hidden aspects of software's
	design is needed. One of the expected benefits of pair programming
	is fostering (tacit) knowledge building between the components of
	the pair and fastening its diffusion within the project's team. We
	have applied the paradigm of pair programming to the design phase
	and we have named it 'pair designing'. We have realized an experiment
	and a replica in order to understand if pair designing can be used
	as an effective means for diffusing and enforcing the design knowledge
	while evolving the system's design. The results suggest that pair
	designing could be a suitable means to disseminate and enforce design
	knowledge. Copyright (c) 2005 John Wiley & Sons, Ltd.},
  owner = {Katia},
  references = {An architecture for tailoring cooperative multi-user displays

	Direct verbal communication as a catalyst of agile knowledge sharing

	Visualisation design knowledge reuse

	The effects of pair programming on performance in an introductory
	programming course

	Extreme programming: A survey of empirical data from a controlled
	case study

	The case for collaborative programming

	Strengthening the case for pair programming

	Lessons learned about distributed pair programming: What are the knowledge
	needs to address?

	Toward a framework for evaluating extreme programming

	Building pair programming knowledge through a family of experiments

	The effects of ‘Pair-Pressure’ and ‘Pair-Learning’

	In support of student pair-programming

	Coupling pair programming and writing: Learning about students’ perceptions
	and processes

	Design decision trees

	Generating linkage between source code and evolvable domain knowledge
	for the ease of software evolution

	A dynamic theory of organizational knowledge creation

	The Knowing Organization

	Knowledge, knowledge work and organizations: An overview and interpretation

	Working in pairs as a means for design knowledge building: An empirical
	study

	Confirming the influence on educational background in pair design
	knowledge through experiments

	Next generation model-driven development

	Building knowledge through family of experiments

	Preliminary guidelines for empirical research in software engineering

	Using students as subjects—a comparative study of students and professionals
	in lead time impact assessment},
  timestamp = {2010.06.22}
}

@ARTICLE{E[16],
    inserir = {false},
  author = {T. Benaya and E. Zur},
  title = {Collaborative programming projects in an advanced CS course},
  year = {2007},
  abstract = {There is ongoing discussion regarding the benefits of collaborative
	programming in software development. This paper presents the results
	of a collaborative programming research conducted at the Open University
	of Israel which is a distance learning institution. The research
	was conducted during the academic year of 2005 in the course "Advanced
	Programming in Java Workshop", given in the Computer Science Department.
	The workshop is based primarily on J2EE technologies and requires
	the students to hand in a final project. We investigated the collaborative
	programming work in the workshop. Our results support the use of
	collaborative programming as an effective programming technique.},
  owner = {Katia},
  references = {Distance learning in graduate school

	Guidelines for the Use of Pair Programming in a Freshman Programming
	Class

	Experiences with pair programming at a small college

	Advanced Java 2 Platform How to Program

	Integrating internet tools into traditional CS distance education:
	student's attitudes

	The effects of pair-programming on performance in an introductory
	programming course

	Investigating pair-programming in a 2nd-year software development
	and design computer science course

	Improving the CS1 experience with pair programming

	Code warriors and code-a-phobes: a study in attitude and pair programming

	Strengthening the Case for Pair Programming

	Pair programming in an introductory computer science course: Initial
	results and recommendation

	Pair Programming Illuminated},
  timestamp = {2010.06.22}
}

@ARTICLE{I[4],
    inserir = {true},
  author = {S. B. Berenson and K. M. Slaten and L. Williams and C. Ho},
  title = {Voices of women in a software engineering course: Reflections on
	collaboration},
  year = {2004},
  abstract = {Those science, mathematics, and engineering faculty who are serious
	about making the education they offer as available to their daughters
	as to their sons are, we posit, facing the prospect of dismantling
	a large part of its traditional pedagogical structure, along with
	the assumptions and practice which support it. [Seymour and Hewett
	1997]. Prior research indicates that female students can be concerned
	about the insularity of working alone for long periods of time, as
	they perceive to be the case with computer science and information
	technology careers. We studied an advanced undergraduate software
	engineering course at North Carolina State University to characterize
	the potential of collaborative learning environments created via
	pair-programming and agile software development to ameliorate this
	concern. A collective case study of three representative women in
	the course revealed that they held the following four themes in common:
	working with others; productivity; confidence; and interest in IT
	careers. Three conjectures concerning collaboration emerged from
	our study, including the importance of face-to-face meetings, an
	increased confidence among women based on product quality, and a
	reduction in the amount of time spent on assignments. While our findings
	are not generalized to early undergraduate courses, the young women
	we studied were at a critical junction in deciding whether to pursue
	a career in IT upon their near-term graduation. Additionally, we
	propose a model for future testing with both males and females that
	connects these three factors with an increased interest in IT careers.},
  owner = {Katia},
  references = {Academically talented women in the 1980s: The Illinois Valedictorian
	Project

	Iterative enhancement: A practical technique for software development

	Extreme Programming Explained: Embrace Change

	Collaboration through agile software development practices: Student
	interviews and lab observations

	Guidelines for the user of pair programming in a freshman programming
	class

	Get ready for agile methods, with care

	Agile Software Development

	The costs and benefits of pair programming

	Toward improving female retention in the computer science major

	Qualitative Inquiry and Research Design: Choosing Among Five Traditions

	Women's Science

	The Supply of Information Technology Workers in the United States

	Towards Gender Equity in Mathematics Education

	Agile Software Development Ecosystems

	Educated in Romance: Women, Achievement, and College Culture

	The Qualitative Researcher's Companion

	Active Learning: Cooperation in the College Classroom

	Understanding the compatibility of pair programmers

	Smart Girls

	Situated Learning: Legitimate Peripheral Participation

	Shared Purpose: Working Together to Build Strong Families and High-Performance
	Companies

	Geek mythology and attracting undergraduate women to computer science

	Unlocking the Clubhouse: Women in Computing

	The effect of pair programming on performance in an introductory programming
	course

	The impact of pair programming on student performance of computer
	science related majors

	Improving the CS1 experience with pair programming

	Knowledge in Motion: Space, Time and Curriculum in Undergraduate Physics
	and Management

	A Practical Guide to Feature-Driven Development

	Agile Software Development with SCRUM

	Talking about Leaving: Why Undergraduates Leave the Sciences

	On pair rotation in the computer science course

	The growth in commitment to cooperative education in a computer science
	program

	Women and information technology (WIT): A comparative study of young
	women from middle grades through high school and into college

	Student culture vs. group work in computer science

	Female computer science students who pair program persist

	Discourse and learning in the classroom: A sociocultural approach

	The collaborative software process

	Strengthening the case for pair-programming

	Pair Programming Illuminated

	In support of pair programming in the introductory computer science
	course

	Pair programming in an introductory computer science course: Initial
	results and recommendations},
  timestamp = {2010.06.22}
}

@ARTICLE{E[17],
    inserir = {false},
  author = {J. Bergin and E. Wallingford},
  title = {Test-first pair-programming tutorial},
  year = {2005},
  abstract = {This hands-on tutorial covers two practices of Extreme Programming
	(XP): test-first programming and test-driven development. It focuses
	on the deeper aspects of these practices, including how they affect
	productivity.},
  owner = {Katia},
  references = {no references: Test-first pair-programming tutorial},
  timestamp = {2010.06.22}
}

@ARTICLE{E[18],
    inserir = {false},
  author = {J. Bevan and L. Werner and C. McDowell},
  title = {Guidelines for the use of pair programming in a freshman programming
	class},
  year = {2002},
  owner = {Katia},
  abstract = {Undergraduate freshman programming classes are conventionally organized
	such that individual students complete a set of concept-specific
	and unrelated programming assignments. This structure does not prepare
	students for future collaborative efforts or for the future use of
	software engineering practices. The addition of pair programming
	into a freshman programming class at the University of California
	at Santa Cruz (UCSC) showed similar benefits to similar studies on
	upper-division software classes, and is expected to show an improvement
	in students' willingness and ability to participate in complex, collaborative
	software engineering assignments in later classes. This paper describes
	the implementation of the pair programming experiment at UCSC, discusses
	some of the issues that compromised the effectiveness of certain
	pairs, and provides implementation guidelines for avoiding such issues
	in other classes},
  references = {But, isn’t that cheating?

	Integrating pair programming into a software development process

	If this is what it’s really like, maybe I better major in English:
	integrating realism into a sophomore software engineering course

	All I really need to know about pair programming I learned in kindergarten

	Pair programming on the C3 project

	Extreme programming: a university team design experience

	The effects of pair-programming on performance in an introductory
	programming course

	Strengthening the case for pair programming},
  timestamp = {2010.06.21}
}

@ARTICLE{E[19],
    inserir = {false},
  author = {M. Bigss},
  title = {Pair Programming: Development times two},
  year = {2000},
  abstract = {By teaming developers into two-person groups, you can boost both software
	quality and staff satisfaction.},
  owner = {Katia},
  references = {XP general information

	www.xprogramming.com

	www.extremeprogramming.org

	www.xprogramming.com/Practices/PracPairs.html

	c2.com/cgi/wiki?ProgrammingInPairs

	members.aol.com/humansandt/papers/pairprogrammingcostbene/pairprogrammingcostben},
  timestamp = {2010.06.21}
}

@ARTICLE{I[5],
    inserir = {true},
  author = {T. Bipp and A. Lepper and D. Schmedding},
  title = {Pair Programming in Software Development Teams An Empirical Study
	of its Benefits},
  year = {2007},
  abstract = {We present the results of an extensive and substantial case study
	on pair programming, which was carried out in courses for software
	development at the University of Dortmund, Germany. 13 software development
	teams with about 100 students took part in the experiment. The groups
	were divided into two sets with different working conditions. In
	one set, the group members worked on their projects in pairs. Even
	though the paired teams could only use half of the workstations the
	teams of individual workers could use, the paired teams produced
	nearly as much code as the teams of individual workers at the same
	time. In addition, the code produced by the paired teams was easier
	to read and to understand. This facilitates finding errors and maintenance.},
  owner = {Katia},
  references = {Relating member ability and personality to work-team processes and
	team effectiveness

	Extreme Programming explained: Embrace Chance

	Experimente mit XP in der Lehre

	The Unified Modeling Language – User Guide

	Hogrefe Verlag für Psychologie

	Measuring facets of job ambiguity: Construct validity evidence

	A Metrics Suite for Object Oriented Design

	Coefficient alpha and the internal structure of tests

	Software Metrics: A Rigorous and Practical Approach

	Refactoring – Improving the Design of Existing Code

	Statistics. Harcourt Brace

	Der Unified Process im Grundstudium - Didaktische Konzeption, von
	Lernmodulen und Erfahrungen

	The Rational Unified Process: An Introduction

	Eine empirische Studie über Paararbeit in der Softwaretechnik

	The Effects of Pair-Programming on Performance in an Introductory
	Programming Course

	The impact of pair programming on student performance, perception
	and persistence

	Two controlled experiments concerning the comparison of pair programming
	to peer review

	An Empirical Study about the Feelgood Factor in Pair Programming

	The Case for Collaborative Programming

	Eine deutschsprachige Skala zur Messung verschiedener Ambiguitätsfacetten
	bei der Arbeit. Diagnostica

	Strengthening the Case for Pair-Programming

	Pair Programming Illuminated},
  timestamp = {2010.06.22}
}

@ARTICLE{E[20],
    inserir = {false},
  author = {C. Bishop-Clark and J. Courte and H. Elizabeth V},
  title = {Programming in pairs with Alice to improve confidence, enjoyment,
	and achievement},
  year = {2006},
  abstract = {Students in an introductory computing class participated in a study
	investigating the impact of using a graphics programming environment
	(Alice) and pair-programming on confidence, enjoyment and achievement.
	Sixty-four participants completed a short questionnaire and a content
	pre-test about computer programming concepts. Students were then
	assigned to one of two groups: individual or paired. The pairs completed
	a tutorial on Alice and then completed a short assignment over a
	period of one week working as a team of two. The individuals completed
	the same tutorial and assignment but completed it alone. Lastly,
	all participants took the same questionnaire and content post-test.
	The results showed that all students experienced increased confidence
	in programming, that students in pairs enjoyed programming more than
	students who worked individually, and that all students performed
	significantly better on the content post-test.},
  owner = {Katia},
  references = {(not available): http://baywood.metapress.com/app/home/contribution.asp?referrer=parent&backto=issue,5,5;journal,35,166;linkingpublicationresults,1:300321,1

	(not available): Programming in pairs with Alice to improve confidence,
	enjoyment, and achievement

	(not available): Programming in pairs with Alice to improve confidence,
	enjoyment, and achievement

	(not available): Programming in pairs with Alice to improve confidence,
	enjoyment, and achievement

	(not available): Programming in pairs with Alice to improve confidence,
	enjoyment, and achievement

	(not available): Programming in pairs with Alice to improve confidence,
	enjoyment, and achievement

	(not available): Programming in pairs with Alice to improve confidence,
	enjoyment, and achievement

	(not available): Programming in pairs with Alice to improve confidence,
	enjoyment, and achievement

	(not available): Programming in pairs with Alice to improve confidence,
	enjoyment, and achievement

	(not available): Programming in pairs with Alice to improve confidence,
	enjoyment, and achievement

	(not available): Programming in pairs with Alice to improve confidence,
	enjoyment, and achievement},
  timestamp = {2010.06.22}
}

@ARTICLE{E[21],
    inserir = {false},
  author = {S. Bowen and F. Maurer},
  title = {Process support and knowledge management for virtual teams doing
	agile software development},
  year = {2002},
  owner = {Katia},
  abstract = {Agile practices are arguably improving the productivity of small,
	co-located software development teams. We describe an approach that
	tries to overcome the constraint of co-location by introducing a
	process-support environment (called MILOS) that helps software development
	teams to maintain adaptive practices in a distributed setting. MILOS
	supports project coordination, information routing, team communication,
	pair programming and experience management.},
  references = {Extreme Programming Explained: Embrace Change

	An Empirical Study of Global Software Development: Distance and Speed

	Process Support for Distributed Extreme Programming Teams

	Agile Software Development with Scrum},
  timestamp = {2010.06.21}
}

@ARTICLE{E[22],
    inserir = {false},
  author = {S. Bryant},
  title = {Double Trouble: Mixing Qualitative and Quantitative Methods in the
	Study of eXtreme Programmers},
  year = {2004},
  abstract = {Despite sparse and sometimes contradictory evidence, eXtreme Programming
	(XP) is currently growing in popularity as an alternative strategy
	for developing software. This paper proposes a methodology for observational
	studies of one of XPs twelve practices, pair programming, including
	the analysis of verbalisations, interactions and artefacts in order
	to improve our understanding of its cognitive implications. In addition,
	a protocol for analysing pair programming behaviours is included
	as a means of identifying the behavioural differences of those who
	are more expert or novice at pair programming and understanding the
	effect of pairing programmers of differing expertise. Initial results
	from a recent study using this methodology are then presented.},
  owner = {Katia},
  references = {When novices surpass experts: The difficulty of task may increase
	with expertise

	A model of software design

	What doesn’t fit: The ’residual category’ as analytic resource

	Extreme programming explained: Embrace change

	Quantifying qualitative analyses of verbal data: A practical guide

	By the way, did anyone study any real programmers?

	Paired programming and personality traits

	Qualitative studies of XP in a medium sized business

	The discovery of grounded theory: Strategies for qualitative research

	From local to global coordination: Lessons from software reuse

	A history of field methods. Ethnographic research: A guide to general
	conduct

	Comparing extreme programming to traditional development for student
	projects

	The case for collaborative programming

	An ethnography of XP practices

	Experiences in learning XP practices: A qualitative study

	Extreme programming explored

	The effects of ‘pairpressure’ and ‘pair-learning’ on software engineering
	education

	Strengthening the case for pair programming},
  timestamp = {2010.06.22}
}

@ARTICLE{E[23],
    inserir = {false},
  author = {S. Bryant and P. Romero and B. du Boulay},
  title = {Pair programming and the mysterious role of the navigator},
  year = {2007},
  abstract = {Computer programming is generally understood to be highly challenging
	and since its inception a wide range of approaches, tools and methodologies
	have been developed to assist in managing its complexity. Relatively
	recently the potential benefits of collaborative software development
	have been formalised in the practice of pair programming. Here we
	attempt to `unpick' the pair programming process through the analysis
	of verbalisations from a number of commercial studies. We focus particularly
	on the roles of the two programmers and what their key characteristics
	and behaviours might be. In particular, we dispute two existing claims:
	(i) that the programmer who is not currently typing in code ("the
	navigator") is constantly reviewing what is typed and highlighting
	any errors (i.e. acting as a reviewer) and (ii) that the navigator
	focuses on a different level of abstraction as a way of ensuring
	coverage at all necessary levels (i.e. acting as a foreman). We provide
	an alternative model for these roles ("the tag team") in which the
	driver and navigator play much more equal roles. We also suggest
	that a key factor in the success of pair programming may be the associated
	increase in talk at an intermediate level of abstraction.},
  owner = {Katia},
  references = {The effects of self-explaining when learning with text or diagrams

	Extreme programming explained: Embrace change

	The Agile Manifesto

	Information relationships in PROLOG programs: how

	do programmers comprehend functionality?

	What is programming?

	Towards a theory of the comprehension of computer programs

	Double Trouble: Mixing quantitative and qualitative methods in the
	study of extreme programmers

	Rating expertise in collaborative software development

	Pair programming and the reappropriation of individual tools for collaborative
	software development

	The collaborative nature of pair programming

	Quantifying qualitative analyses of verbal data: A practical guide

	Eliciting self-explanations improves understanding

	Pair collaboration in end user debugging

	By the way, did anyone study any real programmers?

	Paired programming and personality traits

	Program comprehension and authentic measurement: A scheme for analysing
	descriptions of programs

	Bridging cognitive and social chasms in software development using
	extreme programming

	Trends in the use of verbal protocol analysis in software engineering
	research

	Cognition in the wild

	A pair programming experience

	Situated learning: Legitimate peripheral participation

	The case for collaborative programming

	Comprehension strategies in programming

	Cognitive activities and levels of abstraction in procedural and object-oriented
	design

	Mental imagery in program design and visual programming

	Extreme programming explored

	The effects of "pair-pressure" and "pair-learning" on software engineering
	education

	Pair programming illuminated

	Strengthening the case for pair programming},
  timestamp = {2010.06.22}
}

@ARTICLE{E[24],
    inserir = {false},
  author = {S. Bryant and P. Romero and B. du Boulay},
  title = {The collaborative nature of pair programming},
  year = {2006},
  abstract = {This paper considers the nature of pair programming. It focuses on
	using pair programmers' verbalizations as an indicator of collaboration.
	A review of the literature considers the benefits and costs of co-operative
	and collaborative verbalization. We then report on a set of four
	one-week studies of commercial pair programmers. From recordings
	of their conversations we analyze which generic sub-tasks were discussed
	and use the contribution of new information as a means of discerning
	the extent to which each pair collaborated. We also consider whether
	a particular role is more likely to contribute to a particular sub-task.
	We conclude that pair programming is highly collaborative in nature,
	however the level of collaboration varies according to task. We also
	find that tasks do not seem aligned to particular roles, rather the
	driver tends to contribute slightly more across almost all tasks.},
  owner = {Katia},
  references = {Strengthening the case for pair programming

	A pair programming experience

	The case for collaborative programming

	The costs and benefits of pair programming

	Experiences in learning XP practices: A qualitative study

	When does a pair outperform two individuals?

	Pair Programming Illuminated

	An ethnography of XP practices

	Pair programming and the re-appropriation of individual tools for
	collaborative software development

	Cognition in the wild

	The effects of self-explaining when learning with text or diagrams

	Verbal reports as data

	Representation construction, externalized cognition and individual
	differences

	A cognitive analysis of exceptional memory for restaurant orders

	Thoughts beyond words: When language overshadows insight

	Towards a systematic study of representational guidance for collaborative
	learning discourse

	Does collaborative learning lead to the construction of common knowledge?

	What do you mean by collaborative learning?

	The construction of shared knowledge in collaborative problem solving

	By the way, did anyone study any real programmers?

	Double Trouble: Mixing quantitative and qualitative methods in the
	study of extreme programmers

	Pair Programming and the re-appropriation of individual tools for
	collaborative software development

	Paired programming and personality traits

	Trends in the use of verbal protocol analysis in software engineering
	research

	Stimulus Structures and Mental Representations in Expert Comprehension
	of Computer Programs

	Extreme Programming: A more musical approach to software development},
  timestamp = {2010.06.22}
}

@ARTICLE{E[25],
    inserir = {false},
  author = {M. Bullock},
  title = {Not really pair programming},
  year = {2003},
  abstract = {(no abstract)},
  owner = {Katia},
  references = {(not available): http://ieeexplore.ieee.org/Xplore/errorpage.jsp&userType=inst:
	Not really pair programming

	(not available): Not really pair programming

	(not available): Not really pair programming

	(not available): Not really pair programming

	(not available): Not really pair programming

	(not available): Not really pair programming

	(not available): Not really pair programming

	(not available): Not really pair programming

	(not available): Not really pair programming

	(not available): Not really pair programming

	(not available): Not really pair programming},
  timestamp = {2010.06.22}
}

@ARTICLE{E[26],
    inserir = {false},
  author = {J. D. Campbell},
  title = {Coordination for multi-person visual program development},
  year = {2006},
  abstract = {Typically, visual programming has been limited to only one person
	developing one program at a time. This article describes a technique
	for helping multiple people coordinate working together on the same
	diagram at the same time. This approach identifies transactions based
	on domain syntax. These transactions are used to notify people when
	someone else changes the diagram in a way that is likely to impact
	other people's work. In particular, the system assigns ownership
	of each syntactically incorrect element to the person who last acted
	upon that element. This ownership can be transferred between people.
	The potential problem of incomplete transactions when work extends
	beyond a single session is resolved by restarting transactions when
	work resumes. This syntax-based approach is particularly appropriate
	for visual languages. Various domain constraints are described as
	alternatives or supplements to the syntactic criteria. The technique
	was validated with data from 20 groups of three people using CoDiagram,
	a proof of concept system.},
  owner = {Katia},
  references = {A Visual Language System for Developing and Presenting Internet-based
	Education

	Scaling Up Visual Programming Languages

	Structured Systems Analysis: Tools and Techniques

	Strengthening the Case for Pair Programming

	Collaborative Design Using a Shared Object Spaces Infrastructure

	Distributed Pair Programming on the Web

	eXtreme Programming Support Tool in Distributed Environment

	A Collaborative Learning Tool for Programming

	Assessing distributed pair programming

	Concurrency control in groupware systems

	Real time groupware as a distributed system: concurrency control and
	its effect on the interface

	Concurrency control for real time groupware

	WYSIWIS revised: early experiences with multiuser interfaces

	Interaction in collaborative computer supported diagram development

	Groupware: some issues and experiences

	Cooperative modeling with TOBACO

	Data sharing in group work

	Implicit locking in the ensemble concurrent object-oriented graphics
	editor

	Beyond the chalkboard: computer support for collaboration and problem
	solving in meetings

	Computer-Based Real-Time Conferencing Systems

	GROUPKIT: a groupware toolkit for building real-time conferencing
	applications

	Building real time groupware with Groupkit, a groupware toolkit

	DistView: support for building efficient collaborative applications
	using replicated objects

	Issues and experiences designing and implementing two group drawing
	tools

	Slice: a logical model for shared editors

	Diagram server

	Consistency maintenance in real-time collaborative graphics editing
	systems

	CollabCAD: a toolkit for integrated synchronous and asynchronous sharing
	of CAD applications

	Extending single-location cad/cam for multi-location collaboration

	Some design principles for sharing in Tivoli, a whiteboard meeting
	support tool

	The Parting of the Ways: Divergence, Data Management and Collaborative
	Work

	Consistency guarantees: exploiting application semantics for consistency
	management in a collaboration toolkit

	Characteristics of Group Development of Diagrams

	The Entity-Relationship Approach To Logical Data Base Design

	Giving undo attention, Interacting with Computers

	A framework for undoing actions in collaborative systems

	Undoing any operation in collaborative graphics editing systems

	Achieving undo in bitmap-based collaborative graphics editing systems

	Reducing the problems of group undo

	An integrating, transformation-oriented approach to concurrency control
	and undo in group editors

	Undoing actions in collaborative work

	The transaction concept: virtues and limitations

	Granularity of locks and degrees of consistency in a shared data base

	Database transaction models for advanced applications

	Usability analysis of visual programming environments: a "cognitive
	dimensions" framework

	The notions of consistency and predicate locks in a database system

	A concurrency control framework for collaborative systems

	Database modeling and design

	Multi-User Collaborative Visual Program Development

	Split-Transactions for Open-Ended Activities

	Dynamic restructuring of transactions

	Cooperative transactions for multiuser environments

	Consistency maintenance for real-time collaborative diagram developmen

	IBM computer usability satisfaction questionnaires: psychometric evaluation
	and instructions for use},
  timestamp = {2010.06.22}
}

@ARTICLE{E[27],
    inserir = {false},
  author = {S. Campe and L. L. Werner and J. Denner},
  title = {Information technology fluency for middle school girls},
  year = {2005},
  abstract = {To participate in the changing world of technology, students must
	develop information technology (IT) fluency, rather than simply IT
	literacy. Fluency includes three kinds of knowledge: skills, concepts,
	and capabilities. The acquisition of these kinds of knowledge is
	more likely to happen in the context of project-based work. Because
	of the continued majority of males in IT, it is essential that efforts
	are made to increase the participation of girls. In this paper, we
	describe an after school program for middle school girls that aims
	to develop IT fluency by teaching them to make computer games. We
	present data from their games that show how participants have made
	substantial strides toward information technology fluency. The findings
	suggest that most girls developed skills in graphics, use of a database,
	and the use of the internet. They developed capabilities such as
	sustained reasoning and managing complexity. And they developed concepts
	such as algorithmic thinking and programming and information organization.},
  owner = {Katia},
  references = {Tech-Savvy: educating girls in the new computer age

	Unlocking the clubhouse

	Chess for girls? Feminism and Computer Games

	Taking stock: where we’ve been where we are, where we’re going

	Pair Programming helps female computer science students persist

	Being Fluent with Information Technology

	ACM K-12 Task Force Curriculum Committee

	International Society for Technology in Education

	UCSC UC Santa Cruz Schedule of Classes –Netscape},
  timestamp = {2010.06.22}
}

@ARTICLE{E[28],
    inserir = {false},
  author = {G. Canfora and A. Cimitile and F. Garcia and M. Piattini and C. A.
	Visaggio},
  title = {Evaluating performances of pair designing in industry},
  year = {2007},
  abstract = {Pair programming has attracted an increasing interest from practitioners
	and researchers: there is initial empirical evidence that it has
	positive effects on quality and overall delivery time, as demonstrated
	by several controlled experiments. The practice does not only regard
	coding, since it can be applied to any other phase of the software
	process: analysis, design, and testing. Because of the asymmetry
	between design and coding, applying pair programming to the design
	phase might not produce the same benefits as those it produces in
	the development phase. In this paper, we report the findings of a
	controlled experiment on pair programming, applied to the design
	phase and performed in a software company. The results of the experiment
	suggest that pair programming slows down the task, yet improves quality.
	Furthermore we compare our results with those of a previous exploratory
	experiment involving students, and we demonstrate how the outcomes
	exhibit very similar trends.},
  owner = {Katia},
  references = {Evaluation of effects of pair work on quality of designs

	Exploring the efficacy of distributed pair programming

	The TAME project: towards improvement-oriented software environments

	Building knowledge through families of experiments

	Extreme Programming Explained: Embrace Change

	Pair designing as a practice for enforcing and diffusing design knowledge

	Performances of pair designing on software evolution: a controlled
	experiment

	Evaluating Software Architectures: Methods and Case Studies

	Agile software development: the business of innovation

	Software Metrics: A Rigorous and Practical Approach (second ed.)

	Metrics for Software Conceptual Models

	Fundamentals of Software Engineering (second ed.)

	Pair programming effect on developers productivity

	Using students as subjects – a comparative study of students and professionals

	A multiple case study on the impact of pair programming on product
	quality

	Preliminary guidelines for empirical research in software engineering

	When does a pair outperform two individuals?

	The effects of pair-programming on performance in an introductory
	programming course

	Investigating pair-programming in a 2nd-year software development
	and design computer science course

	A preliminary study on the impact of a pair design phase on pair programming
	and solo programming

	Experimental Evaluation of pair programming

	The case for collaborative programing

	Manifesto elicits cynism

	How good are agile methods?

	Conducting realistic experiments in software engineering

	On pair rotation in the computer science course

	Preliminary analysis of the effects of pair programming on job satisfaction

	The Effects of “Pair Pressure” and “Pair-Learning” on software engineering
	education

	Experimenting with industry’s pair programming model in the computer
	science classroom

	Strengthening the case for pair programming

	The benefits of collaboration for student programmers

	Experimentation in Software Engineering: An Introduction

	Pair programming in graduate software engineering course projects},
  timestamp = {2010.06.22}
}

@ARTICLE{E[58],
    inserir = {false},
  author = {G. Canfora and A. Cimitile and F. Garcia and M. Piattini and C. A.
	Visaggio},
  title = {Evaluating performances of pair designing in industry},
  year = {2007},
  abstract = {Pair programming has attracted an increasing interest from practitioners
	and researchers: there is initial empirical evidence that it has
	positive effects on quality and overall delivery time, as demonstrated
	by several controlled experiments. The practice does not only regard
	coding, since it can be applied to any other phase of the software
	process: analysis, design, and testing. Because of the asymmetry
	between design and coding, applying pair programming to the design
	phase might not produce the same benefits as those it produces in
	the development phase. In this paper, we report the findings of a
	controlled experiment on pair programming, applied to the design
	phase and performed in a software company. The results of the experiment
	suggest that pair programming slows down the task, yet improves quality.
	Furthermore we compare our results with those of a previous exploratory
	experiment involving students, and we demonstrate how the outcomes
	exhibit very similar trends.},
  owner = {Katia},
  references = {Evaluation of Effects of Pair Work on Quality of Designs

	Building Knowledge through Families of Experiments

	Extreme programming explained: embrace change

	Pair designing as practice for enforcing and diffusing design knowledge:
	Research Articles

	Performances of Pair Designing on Software Evolution: a controlled
	experiment

	Evaluating Software Architectures: Methods and Case Studies

	Agile Software Development: The Business of Innovation

	Software Metrics: A Rigorous and Practical Approach

	Metrics For Software Conceptual Models

	Fundamentals of software engineering

	Pair programming effect on developers productivity

	Using Students as Subjects—A Comparative Study ofStudents and Professionals
	in Lead-Time Impact Assessment

	A multiple case study on the impact of pair programming on product
	quality

	Preliminary guidelines for empirical research in software engineering

	When does a pair outperform two individuals?

	The effects of pair-programming on performance in an introductory
	programming course

	Investigating pair-programming in a 2nd-year software development
	and design computer science course

	A preliminary study on the impact of a pair design phase on pair programming
	and solo programming

	Experimental Evaluation of pair programming

	The case for collaborative programming

	Manifesto elicits cynism

	How Good are Agile Methods?

	Conducting Realistic Experiments in Software Engineering

	On Pair Rotation in the Computer Science Course

	Preliminary analysis of the effects of pair programming on job satisfaction

	The Effects of "Pair-Pressure" and "Pair-Learning" on Software Engineering
	Education

	Experimenting with industry's pair programming model in the computer
	science classroom

	Strengthening the Case for Pair Programming

	The benefits of collaboration for student programmers

	Experimentation in software engineering: an introduction

	Pair programming in graduate software engineering course projects},
  timestamp = {2010.06.22}
}

@ARTICLE{I[9],
    inserir = {true},
  author = {G. Canfora and A. Cimitile and F. Garcia and M. Piattini and C. A.
	Visaggio},
  title = {Performances of pair designing on software evolution: a controlled
	experiment},
  year = {2006},
  abstract = {Evolving software design is a critical activity for many reasons:
	inadequate documentation, loss of strategic knowledge due to personnel's
	turnover, intrinsic complexity of software design. As a consequence,
	performances in the evolution tasks may deteriorate. Some experiments
	demonstrate that pair programming is able to reduce the time spent
	for accomplishing the tasks while increasing the overall work quality.
	Pair programming is usually applied to coding; the term 'pair designing'
	refers to applying the practice of working in pairs to the design
	phase. Because of the asymmetry existing between coding and designing,
	pair designing could not replicate all the benefits of pair programming.
	This paper discusses a controlled experiment for understanding which
	are the effects of pair designing when evolving software design.},
  owner = {Katia},
  references = {Evaluation of Effects of Pair Work on Quality of Designs

	Building Knowledge through family of experiments

	Extreme Programming explained: Embrace change

	Pair designing as practice for enforcing and diffusing design knowledge

	Evaluating Software architectures Methods and Case Studies Software
	Development Failures

	Fundamentals of Software Engineering

	Using Students as Subjects – A comparative Study of Students & Professionals
	in Lead-Time Impact Assessment

	Preliminary Guidelines for Empirical Research in Software Engineering

	When Does a Pair Outperform Two Individuals?

	The Effects of Pair- Programming on Performance in an Introductory
	Programming Course

	Experiment Evaluation of Pair Programming

	The case for collaborative programming

	On Pair Rotation in the Computer Science Course

	Strengthening the Case for Pair Programming

	Building Pair Programming Knowledge through a Family of Experiments

	Experimenting with industry’s Pair Programming Model in the Computer
	Sicence Classroom

	Pair Programming Illuminated},
  timestamp = {2010.06.22}
}

@ARTICLE{I[8],
    inserir = {true},
  author = {G. Canfora and A. Cimitile and F. Garcia and M. Piattini and C. A.
	Visaggio},
  title = {Confirming the influence of educational background in pair-design
	knowledge through experiments},
  year = {2005},
  abstract = {The sharing of tacit knowledge is a strategic factor for the success
	of software process, from a number of perspectives: training, project
	assimilation, and reducing noise in knowledge transfer. Pair programming
	is supposed to be a practice suitable for this purpose. Unfortunately,
	the building of tacit knowledge is determined by factors that are
	difficult to isolate and capture because they concern personal attitude
	and capability. Thus, we have focused on the possible causes forming
	the individual ability, that can be isolated and studied, such as
	the individual education background. We have applied the practice
	of working in pairs to the design phase. We have made an experiment
	and a replica in academic environment, in order to understand the
	relationship between the building of knowledge through the practice
	and the individual background. In this paper we discuss the replica
	and compare the results with the first experiment’s ones.},
  owner = {Katia},
  references = {Building Knowledge Through Families of Experiments

	Extreme Programming Explained: embrace change

	The Mythical Man Month

	Working in pairs as a means for design knowledge building: an empirical
	study

	Lessons learned about Distributed Pair programming: what are the knowledge
	needs to address?

	Using Empirical Studies during Software Courses

	Characterizing People as Non-Linear, First-Order Components in Software
	Development

	Construct validation of tacit Knowledge for military Leadership

	Using Students as Subjects – A comparative Study of Students & Professionals
	in Lead-Time Impact Assessment

	Preliminary Guidelines for Empirical Research in Software Engineering

	The Effects of Pair Programming on Performance in an introductory
	Programming Course

	Direct Verbal Communication as a Catalyst of Agile Knowledge Sharing

	Experimental Evaluation of Pair Programming

	Coupling Pair Programming and Writing: Learning About Students’ Perceptions
	and Processes

	The Effects of "Pair-Pressure" and "Pair-Learning"

	Straightening the case for pair programming

	In Support of Student Pair-Programming

	The Collaborative Software Process

	An initial Exploration of the relationship between Pair programming
	and Brook},
  timestamp = {2010.06.22}
}

@ARTICLE{E[29],
    inserir = {false},
  author = {G. Canfora and A. Cimitile and G. A. Di Lucca and C. A. Visaggio},
  title = {How distribution affects the success of pair programming},
  year = {2006},
  abstract = {Recent experiments demonstrated the effectiveness of pair programming
	in terms of quality and productivity. Growing interest towards global
	software development is fostering the design of suitable methods
	and tools for distributing software processes, at any level of detail,
	from entire subprocesses up to a single activity. Consequently, people
	placed in different locations could also share programming tasks
	and related practices, such as pair programming. Unfortunately, distribution
	might seriously compromise the success of pair programming, due to
	communication and collaboration issues. We have performed an experiment
	in order to investigate the impact of distribution on pair programming
	when performing maintenance tasks. An interesting conjecture stems
	from the experiment: under certain conditions, distributed pair's
	components tend to dismiss from each other, stopping the collaborative
	work. This can be a very expensive risk factor to keep into account
	when planning tasks of distributed pair programming.},
  owner = {Katia},
  references = {Manifesto for Agile Software Development

	What is pair programming?

	Extreme Programming Explained: embrace change

	Pair Programming

	The Costs and Benefits of Pair Programming

	Straightening the case for pair programming

	Case study: Extreme Programming in a University Environment

	Surviving Global Software Development

	Tactical Approaches for alleviating distance in global software development

	Launching Extreme Programming at a Process-Intensive Company

	Exploring the efficacy of distributed pair programming

	Experimentation in Software engineering: an introduction

	Get ready for Agile Methods, with care

	Developing complex projects using XP with extension

	Assessing XP at a European Internet Company

	Extreme Programming: a gentle introduction

	Scoping the Global Market: size is just part of the story

	Global Software Development: Attainable Challenge or the Holy Grail?

	An empirical study on Global Software Development: distance and speed

	Groupware, workflow and intranets

	Architecture, Coordination, and Distance: Conway’s Law and Beyond

	A pair programming experience

	Pair Programming is done by peers

	Knowing in practice: Enacting a Collective Capability in Distributed
	Organizing

	Lessons learned about distributed pair programming: what are the knowledge
	needs to address?

	Networks and Organizations: Structure, form, and action

	Experimenting with Pair Programming in the classroom

	A Pair-Programming Experiment in a Non-Programming Course

	Building Pair Programming Knowledge through a Family of Experiments

	When Does a Pair Outperform Two Individuals?

	The case of Collaborative programming

	Distributed Pair Programming: an empirical study

	An Initial Exploration of the relationship between Pair Programming
	and Brooks’ Law

	An Empirical Study about the Feelgood Factor in Pair Programming},
  timestamp = {2010.06.22}
}

@ARTICLE{I[7],
    inserir = {true},
  author = {G. Canfora and A. Cimitile and C. A. Visaggio},
  title = {Empirical study on the productivity of the pair programming},
  year = {2005},
  abstract = {Many authors complain the lack of empirical studies which assess the
	benefits and the drawbacks of agile practices. Particularly, pair
	programming rises an interesting question for managers: does pair
	programming mean to pay two developers in the place of one? We realized
	an experiment to compare the productivity of a developer when performing
	pair programming and when working as solo programmer. We obtained
	empirical evidence that pair programming decreases the effort of
	the single programmer.},
  owner = {Katia},
  references = {Exterme Programming: A Survey of Empirical Data from a Controlled
	Case Study

	Software modeling and measurement: The Goal Question Metric paradigm

	Distributed Pair programming: Empirical Studies and Supporting Environments

	Building Knowledge Through Families of Experiments

	The impact of educational background on design knowledge sharing during
	pair programming: an empirical study

	Lessons learned about Distributed Pair programming: what are the knowledge
	needs to address?

	Working in Pairs as a Means for Design Knowledge Building: An Empirical
	Study

	Using Empirical Studies during Software Courses

	Agile Software Development

	An Initial Framework for Reasearch on Pair Progamming

	The Effects of Pair Programming on Performance in an introductory
	Programming Course

	Preliminary Guidelines for Empirical Research in Software Engineering

	Using Students as Subjects - A comparative Study of Students Professionals
	in Lead-Time Impact Assessment

	The Impact of Pair Programming on Student Performance, Perception
	and persistence

	Experimental Evaluation of Pair Programming

	The case for collaborative programming

	Coupling Pair Programming and Writing: Learning About Students Perceptions
	and Processes

	The impact of Using Pair Programming on System Evolution: a Simulation
	Based Study

	Straightening the case for pair programming

	In Support of Student Pair-Programming

	Building Pair programming Knowledge through a Family of Experiments

	The Effects of Pair-Pressure and Pair-Learning

	An Initial Exploration of the relationship between Pair programming
	and Brooks law},
  timestamp = {2010.06.22}
}

@ARTICLE{I[6],
    inserir = {true},
  author = {G. Canfora and A. Cimitile and C. A. Visaggio},
  title = {Working in pairs as a means for design knowledge building: An Empirical
	Study},
  year = {2004},
  abstract = {Pair programming is increasingly attracting researchers' and practitioners'
	attention. One of the claimed benefits of pair programming consists
	of easing socialization among programmers, with the effect of transferring
	tacit knowledge. Designing software systems requires a strong employment
	of tacit knowledge, such as individual experience and skills. In
	this paper, the authors, explore the hypothesis that working in pairs
	can speed up and enforce the knowledge building process among designers.
	We name "pair designing" the application of pair programming concepts
	to the design stage. An experiment has been performed to test the
	effect of pair designing on knowledge building. This paper discusses
	preliminary results, which confirm the hypothesis of a positive effect
	of working in pairs on the process of knowledge building.},
  owner = {Katia},
  references = {Improving Software Engineering practice through competency based personnel
	reviews

	Wanted: Project teams with a blend of IS Professional orientations

	A dynamic theory of organizational knowledge creation

	Knowledge, Knowledge Work and Organizations: An Overview and Interpretation

	Developmental Work Research: Reconstructing Expertise through Expansive
	Learning

	Knowledge and the Theory of Organizations: Organizations as Activity
	Systems and the Reframing of Management

	Extreme Programming Explained: embrace change

	The case for collaborative programming

	Experimental Evaluation of Pair Programming

	Straightening the case for pair programming

	Lessons learned about Distributed Pair programming: what are the knowledge
	needs to address?

	In Support of Student Pair-Programming

	The Effects of Pair Programming on Performance in an introductory
	Programming Course

	Coupling Pair Programming and Writing: Learning About Students’ Perceptions
	and Processes

	The Effects of "Pair-Pressure" and "Pair-Learning"

	The Collaborative Software Process PhD Dissertation

	Construct validation of tacit Knowledge for military Leadership},
  timestamp = {2010.06.22}
}

@ARTICLE{E[30],
    inserir = {false},
  author = {G. Canfora and A. Cimitile and C. A. Visaggio},
  title = {Lessons learned about distributed pair programming: what are the
	knowledge needs to address?},
  year = {2003},
  abstract = {We have realized an experiment aimed at understanding the impact of
	distribution on time and quality of code developed with pair programming.
	From this experimental data's analysis the pair dismissal phenomenon
	has stemmed. After the experiment, we have conducted an assessment
	discussion guided by a questionnaire. The assessment confirmed the
	dismissal hypothesis and highlighted knowledge needs to be addressed
	when managing distributed pair programming in software projects.
	This paper focuses on the results of the assessment and discusses
	the lessons learned.},
  owner = {Katia},
  references = {(no available): "BUY ARTICLE: "http://www.computer.org/portal/web/search/simple?p_p_id=searchsimple_WAR_pluginssearch_INSTANCE_5aXm&p_p_lifecycle=1&p_p_state=normal&p_p_mode=view&p_p_col_id=column-1&p_p_col_count=1&_searchsimple_WAR_pluginssearch_INSTANCE_5aXm_formAction=search

	(no available): "BUY ARTICLE": Lessons learned about distributed pair
	programming: what are the knowledge needs to address?

	(no available): "BUY ARTICLE": Lessons learned about distributed pair
	programming: what are the knowledge needs to address?

	(no available): "BUY ARTICLE": Lessons learned about distributed pair
	programming: what are the knowledge needs to address?

	(no available): "BUY ARTICLE": Lessons learned about distributed pair
	programming: what are the knowledge needs to address?

	(no available): "BUY ARTICLE": Lessons learned about distributed pair
	programming: what are the knowledge needs to address?

	(no available): "BUY ARTICLE": Lessons learned about distributed pair
	programming: what are the knowledge needs to address?

	(no available): "BUY ARTICLE": Lessons learned about distributed pair
	programming: what are the knowledge needs to address?

	(no available): "BUY ARTICLE": Lessons learned about distributed pair
	programming: what are the knowledge needs to address?

	(no available): "BUY ARTICLE": Lessons learned about distributed pair
	programming: what are the knowledge needs to address?

	(no available): "BUY ARTICLE": Lessons learned about distributed pair
	programming: what are the knowledge needs to address?},
  timestamp = {2010.06.22}
}

@ARTICLE{E[31],
    inserir = {false},
  author = {L. Cao and X. Peng},
  title = {Activity Patterns of Pair Programming},
  year = {2005},
  abstract = {This paper reports results from an exploratory study investigating
	the activity patterns of pair programming using a student project
	conducted over a period of nine weeks. We found that pair programming
	engaged in activities that lead to more deeper-level thinking which
	may enable people to formulate a more complete mental model of the
	task. We also compared the activity patterns between different pair
	combinations. We found that there are differences in the patterns
	among different pair combinations.},
  owner = {Katia},
  references = {Toward an Assessment of software Development Risk

	Embracing change with extreme programming

	New Directions in Studies of Social Interactions and Cognitive Growth

	Get Ready for Agile Methods, with Care

	The Effects of Justification, Task Complexity and Experience/Training
	on Problem-Solving Performance

	Verbal Interaction and Problem-Solving Within Computer-Assisted Cooperative
	Learning Groups

	An Empirical Study of Computer System Learning: Comparison of Co-Discovery
	and Self-Discovery Methods

	The Effects of Pair-Programming on Performance in an Introductory
	Programming Course

	The Case for Collaborative Programming

	Preliminary Analysis of the Effects of Pair Programming on Job Satisfaction

	Pair Programming Illuminated

	The Effects of 'Pair-Pressure' and 'Pair-Learning' on Software Engineering
	Education

	Strengthening the Case for Pair-Programming

	In Support of Student Pair-Programming},
  timestamp = {2010.06.22}
}

@ARTICLE{I[12],
    inserir = {true},
  author = {J. C. Carver and L. Henderson and L. He and J. Hodges and D. Reese},
  title = {Increased Retention of Early Computer Science and Software Engineering
	Students Using Pair Programming},
  year = {2007},
  abstract = {An important problem faced by many Computer Science and Software Engineering
	programs is declining enrollment. In an effort to reverse that trend
	at Mississippi State University, we have instituted pair programming
	for the laboratory exercises in the introductory programming course.
	This paper describes a study performed to analyze whether using pair
	programming would increase retention. An important goal of this study
	was not only to measure increased retention, but to provide insight
	into why retention increased or decreased. The results of the study
	showed that retention significantly increased for those students
	already majoring in Computer Science, Software Engineering, or Computer
	Engineering. In addition, survey results indicated that the students
	viewed many aspects of pair programming to be very beneficial to
	their learning experience.},
  owner = {Katia},
  references = {Extreme Programming Explained: Embrace Change

	Student Attitudes toward Pair Programming

	The Effect of Pair Programming on Performance in an Introductory Programming
	Course

	The impact of pair programming on student performance, perception,
	and persistence

	Pair programming improves student retention, confidence, and program
	quality

	Improving the CS1 Experience with Pair Programming

	Pair-Programming Helps Female Computer Science Students

	Strengthening the Case for Pair-Programming

	In Support of Pair Programming in the Introductory Computer Science
	Course

	Building Pair Programming Knowledge Through a Family of Experiments

	Debunking the Nerd Stereotype with Pair Programming},
  timestamp = {2010.06.22}
}

@ARTICLE{I[13],
    inserir = {true},
  author = {J. Chao and G. Atli},
  title = {Critical Personality Traits in Successful Pair Programming},
  year = {2006},
  abstract = {Pair programming (PP) is a common practice in Extreme programming,
	in which two programmers work together using a single computer. The
	close interaction required by PP makes it difficult to apply. The
	hypothesis is that certain personality traits are crucial for the
	success of PP, and PP partners should be chosen based on these personality
	traits. In this research, we first survey the programmers in industry
	to identify the perceived important personality traits for PP, and
	then conduct experiments to determine the significance of these personality
	traits in successful PP.},
  owner = {Katia},
  references = {Extreme Programming Explained: Embrace Change

	The Costs and Benefits of Pair Programming

	Design and Analysis of Experiments, Springer--Verlag

	Paired Programming and Personality Traits

	Analyzing the Cost and Benefit of Pair Programming

	On Understanding Compatibility of Student Pair Programmers

	An Approximate Distribution of Estimates of Variance Components

	Code Warriors and Code-a-Phobes: A Study in Attitude and Pair Programming

	Personality Characteristic

	Pair programming illuminated},
  timestamp = {2010.06.22}
}

@ARTICLE{I[14],
    inserir = {true},
  author = {E. A. Chaparro},
  title = {Factors affecting the perceived effectiveness of pair programming
	in higher education},
  year = {2005},
  abstract = {This paper reports the findings of a study conducted on postgraduate
	students of an Object Oriented Programming (OOP) course in which
	pair programming was applied as an educational technique. This study
	addressed the question Why is pair programming sometimes ineffective?
	The focus of the study was on exploring the factors that may affect
	the success of pair programming. We employed a combination of data
	gathering techniques and triangulated them to analyze the data. We
	observed, recorded and interviewed students who pair programmed.
	They also completed questionnaires. There was evidence that matching
	by skill level and the task in hand are the main factors in the success
	of a pair programming session.},
  owner = {Katia},
  references = {The problem of teaching object-oriented programming, Part 2: Environments

	Object-Oriented Analysis and Design with Applications

	The problem of teaching object-oriented programming, Part 1: Languages

	Object-Oriented Software Construction

	Assessing the cognitive consequences of the object-oriented approach:
	A survey of empirical research on object-oriented design by individuals
	and teams

	Scaffolding with Object Diagrams in First Year Programming Classes:
	Some Unexpected Results

	Objects first with Java: a practical introduction using BlueJ

	Improving the CS1 experience with Pair Programming

	Analyzing Distributed Cognition in Software Teams: A Case Study of
	Team Programming During Perfective Software Maintenance

	A study of Human Solutions in eXtreme Programming

	Experiences in Learning XP Practices: A Qualitative Study. in Extreme
	Programming and Agile Processes in Software Engineering

	The guided Construction of Knowledge: Talk among teachers and learners

	Mind in Society: The development of higher Psychological Processes

	A historical and conceptual perspective

	Exploring foundations for computer-supported collaborative learning

	The evolution of research on collaborative learning

	Critical Components for Successful Collaborative Learning in CS1.
	J

	On Understanding the Compatibility of Student Pair Programmers

	Code warriors and code-a-phobes: a study in attitude and pair programming

	Coupling pair programming and writing: learning about students' perceptions
	and processes

	A pair programming experience

	Pair Programming Illuminated

	The cost and benefits of pair programming

	Program Quality with pair programming in CS1

	The impact of pair-programming on student performance, perception
	and persistence

	Strengthening the case for pair-programming

	Empirical Studies of Pair Programming

	Perceptions of Agile Practices: A Student Survey

	XP: Taking the psychology of programming to the eXtreme

	Integrating algorithm visualization technology into an undergraduate
	algorithm course: ethnographic studies of a social constructivist
	approach

	Research Methods in Education

	Triangulation in educational research},
  timestamp = {2010.06.22}
}

@ARTICLE{E[32],
    inserir = {false},
  author = {T. Chintakovid and S. Wiedenbeck and M. Burnett and V. Grigoreanu},
  title = {Pair collaboration in end-user debugging},
  year = {2006},
  abstract = {The problem of dependability in end-user programming is an emerging
	area of interest. Pair collaboration in end-user software development
	may offer a way for end users to debug their programs more effectively.
	While pair programming studies - primarily of computer science students
	and professionals - report positive outcomes in terms of overall
	program quality, little is known about specific activities that pairs
	engage in that lead to those outcomes, or of how the previous results
	may pertain to end-user programmers. In this paper we analyze protocols
	of end-user pairs debugging spreadsheets. The results suggest that
	end-user pairs can achieve rich reasoning, effective planning, and
	systematic evaluation. Furthermore, end-user pairs provide specific
	types of mutual support that facilitate the accomplishment of their
	goals.},
  owner = {Katia},
  references = {Effectiveness of End-User Debugging Software Features: Are There Gender
	Issues?

	End-User Software Engineering

	Analyzing Distributed Cognition in Software Teams

	Distributed Cognition: A New Foundation for Human-Computer Interaction
	Research

	Interaction Analysis: Foundations and Practice

	Supporting End-User Debugging: What Do Users Want to Know?”

	Content Analysis: An Introduction to Its Methodology

	The impact of pair programming on student performance, perception
	and persistence

	The Case for Collaborative Programming

	What We Know About Spreadsheet Errors

	Fun Learning Stagecast Creator: An Exercise in Minimalism and Collaboration

	Experiments with Industry’s ‘Pair-Programming’ Model in the Computer
	Science Classroom

	Pairs Programming Illuminated

	In Support of Pair Programming the Introductory Computer Science Course},
  timestamp = {2010.06.22}
}

@ARTICLE{I[73],
    inserir = {true},
  author = {K. S. Choi},
  title = {A discovery and analysis of influencing factors of pair programming},
  year = {2004},
  abstract = {The exploration into the underlying psychosocial links of pair programming,
	a new and unorthodox programming paradigm in which two programmers
	share one keyboard and monitor during real-time programming sessions,
	is undertaken. These complex psychosocial relationships, along with
	cognitive process exchanges, ultimately mold the programming output
	as well as determine the level of communication, satisfaction, confidence
	and compatibility. Laying the framework for this research, a thorough
	review of traditional and contemporary paradigms with a special focus
	on their limitations and a list of current software development problems
	are presented. Next, a detailed summary of pair programming and related
	agile software paradigms, such as extreme programming, which lists
	pair programming as one of its twelve principles, is given. From
	earlier pair programming studies, a number of programming benefits
	have been unveiled and these are listed and discussed. However, a
	lack of formal studies pertaining to the psychosocial aspects of
	pair programming exists. Given this void, a field survey is administered
	to a group of professional programmers and a resulting list of influencing
	factors on pair programming emerges. From the list, the most popular
	factor, personality, and two other factors, communication and gender,
	have been selected in order to study their impact on pair programming
	product outcome and the level of communication, satisfaction, confidence
	and compatibility. An experiment focusing on these factors is designed
	and implemented. From the experimental findings, the personality
	of the two partners in pair programming is found to have a significant
	impact on the pair programming output. Also, it is discovered that
	same gender pairs exhibited an unusually high level of communication,
	satisfaction and compatibility between each other, especially among
	female-female pairs. A detailed statistical experiment result based
	on research hypotheses is reported.},
  owner = {Katia},
  references = {Agile software development manifesto

	New directions on agile methods: a comparative analysis

	Chrysler goest to Extreme

	Aerospace software engineering: a collection of concepts

	Agile software engineering environment over the internet

	PPT: a COTS integration case study

	Which Way, SQA?

	More programmers going "Extreme"

	COTS-based system top 10 list

	How Internet software companies negotiate quality

	Racing the E-Bomb: How the Internet is Redefining Information Systems
	Development Methodology

	EMethodology: Towards a systems development methodology for e-business
	and e-commerce applications

	Is internet-speed software development different?

	Constantine On Peopleware

	Mental representations of expert procedural and object-oriented programmers
	in a software maintenance task

	Software Engineering and the law

	Software development on Internet Time

	A strategy for comparing alternative software development life cycle
	models

	A Case Study in an Integrated Development and Problem Solving environment

	Peopleware: Productive Projects and Teams

	Complex Adaptive Systems: A Nominal Definition

	Requirements Engineering

	Toward a Comprehensive Framework for Software Process Modeling Evolution

	Redesigning Enterprise Process for e-Business

	Surviving global software development

	Pair programming on the C3 project

	Strengthening the case for pair programming

	All I really need to know about pair programming I learned in kindergarten

	Pair programming illuminated

	In Support of Student Pair Programming

	Collaborative Sofware Process},
  timestamp = {2010.06.23}
}

@ARTICLE{E[33],
    inserir = {false},
  author = {J. Chong and T. Hurlbutt},
  title = {The Social Dynamics of Pair Programming},
  year = {2007},
  abstract = {This paper presents data from a four month ethnographic study of professional
	pair programmers from two software development teams. Contrary to
	the current conception of pair programmers, the pairs in this study
	did not hew to the separate roles of "driver" and "navigator". Instead,
	the observed programmers moved together through different phases
	of the task, considering and discussing issues at the same strategic
	"range" or level of abstraction and in largely the same role. This
	form of interaction was reinforced by frequent switches in keyboard
	control during pairing and the use of dual keyboards. The distribution
	of expertise among the members of a pair had a strong influence on
	the tenor of pair programming interaction. Keyboard control had a
	consistent secondary effect on decision-making within the pair. These
	findings have implications for software development managers and
	practitioners as well as for the design of software development tools.},
  owner = {Katia},
  references = {The effects of pair-programming on performance in an introductory
	programming course

	A multiple case study on the impact of pair programming on product
	quality

	The case for collaborative programming

	Experimental evaluation of pair programming

	The collaborative software process(sm)

	Pair Programming Illuminated

	Extreme programming explained: embrace change

	XP Practices: Pair Programming

	Factors affecting the perceived effectiveness of pair programming
	in higher education

	Double Trouble: Mixing Qualitative and Quantitative Methods in the
	Study of eXtreme Programmers

	Rating expertise in collaborative software development

	Coupling pair programming and writing: learning about students' perceptions
	and processes

	On understanding compatibility of student pair programmers

	Investigating the Impact of Personality Types on Communication and
	Collaboration-Viability in Pair Programming

	An Empirical Study about the Feelgood Factor in Pair Programming

	Sangam: a distributed pair programming plug-in for Eclipse

	A study of human solutions in eXtreme programming},
  timestamp = {2010.06.22}
}

@ARTICLE{E[34],
    inserir = {false},
  author = {J. Chong and R. Siino},
  title = {Interruptions on Software Teams: A Comparison of Paired and Solo
	Programmers},
  year = {2006},
  abstract = {This study explores interruption patterns among software developers
	who program in pairs versus those who program solo. Ethnographic
	observations indicate that interruption length, content, type, occurrence
	time, and interrupter and interruptee strategies differed markedly
	for radically collocated pair programmers versus the programmers
	who primarily worked alone. After presenting an analysis of 242 interruptions
	drawn from more than 40 hours of observation data, we discuss how
	team configuration and work setting influenced how and when developers
	handled interruptions. We then suggest ways that CSCW systems might
	better support pair programming and, more broadly, provide interruption-handling
	support for workers in knowledge-intensive occupations.},
  owner = {Katia},
  references = {Managing attention by preparing to forget

	Task interruption: Resumption lag and the role of cues

	The effects of interruptions on task performance

	Evaluation and analysis of users' activity organization

	The aware architecture: Supporting context-mediated social awareness
	in mobile cooperation

	Extreme programming explained

	Lilsys: Sensing unavailability

	Exchange and power in social life

	Managing multiple tasks: Reducing the resumption time of the primary
	task

	A diary study of task switching and interruptions

	Cyberminder: A context-aware system for supporting reminders

	Examining task engagement in sensor-based statistical models of human
	interruptibility

	Constant, constant, multitasking craziness

	Convergent activities: Line control and passenger information on the
	London Underground

	I'd be overwhelmed, but it's just one more thing to do: Availability
	and interruption in research management

	The MIT Press

	Distributed cognition in an airline cockpit

	Work interrupted: A closer look at the role of interruptions in organizational
	life

	Clipping lists and change borders: Improving multitasking efficiency
	with peripheral information design

	Comparison of four primary methods for coordinating the interruption
	of people in human-computer interaction

	Timespace in the workplace: Dealing with interruptions

	The time famine: Toward a sociology of work time

	Working with "constant interruption": CSCW and the small office

	The contracts of individuals and organizations

	The effects of task interruption and information presentation on individual
	decision making

	Plans and situated actions: The problem of human machine communication

	Informal workplace communication: What is it like and how might we
	support it?},
  timestamp = {2010.06.22}
}

@ARTICLE{I[25],
    inserir = {true},
  author = {M. Ciolkowski and M. Schlemmer},
  title = {Experiences with a Case Study on Pair Programming},
  year = {2002},
  abstract = {Agile methods are becoming more and more popular. Most well known
	among them is probably Extreme Programming (XP) [2]. One key practice
	of XP is Pair Programming (PP), where two developers work simultaneously
	on a programming task. However, despite their popularity, few is
	known about limitations of these methods in terms of empirical knowledge.
	Some empirical studies exist on Pair Programming [5][8]. These studies
	compared PP to solo programming and were conducted for small, isolated
	tasks. In this paper, we describe a case study conducted in the context
	of a more realistic task within a university practical course, conducted
	in teams of six students and comprising about 700 person-hours of
	total effort. Within our case study setting, we were able to find
	weak support for the results achieved in earlier studies. More importantly,
	we describe experiences we made in conducting the case study and
	suggest improvements for future investigations.},
  owner = {Katia},
  references = {Agile software development methods – Review and analysis

	Extreme Programming Explained: Embrace Change

	The Costs and Benefits of Pair Programming

	You can’t even ask them to push a button: Toward ubiquitous, developer-centric,
	empirical software engineering

	The Case for Collaborative Programming

	Eine Fallstudie zum Vergleich von Pairprogramming mit herkömmlicher
	Programmierung

	All I Really Need to Know about Pair Programming I Learned In Kindergarten

	The Effects of “Pair-Pressure” and “Pair-Learning” on Software Engineering
	Education},
  timestamp = {2010.06.23}
}

@ARTICLE{I[15],
    inserir = {true},
  author = {D. C. Cliburn},
  title = {Experiences with Pair programming at a Small College},
  year = {2003},
  abstract = {Pair programming is a technique in which two programmers work side-by-side
	at one computer on the same program or problem. This paper discusses
	the use of pair programming in an introductory programming course
	at a small college and includes the results of a survey given to
	the students at the conclusion of the fall 2002 semester. The use
	of pair programming produces better projects in less time, and results
	in fewer assignments for the teaching staff to grade. Exam scores
	seem to be comparable with courses that do not allow students to
	program in pairs. Student evaluation of pair programming seems to
	be very positive; most students enjoy the class more when allowed
	to program in pairs and the group work promoted in the course teaches
	students important collaboration skills they will need in industry.
	The results discussed in this paper seem to suggest that pair programming
	is an effective teaching tool for introductory programming courses.},
  owner = {Katia},
  references = {Collaboration Versus Plagiarism in CS Programming Courses

	All I Ever Needed to Know About Pair Programming I Learned in Kindergarten

	Pair Programming Illustrated

	Strengthening the Case for Pair Programming

	Pair Programming in an Introductory Computer Science Course: Initial
	Results and Recommendations

	Guidelines for the Use of Pair Programming in a Freshman Programming
	Class

	The Effects of Pair Programming on Performance in an Introductory
	Programming Course

	Improving the CS1 Experience with Pair Programming

	Code Warriors and Code-a-Phobes: A Study in Attitude and Pair Programming},
  timestamp = {2010.06.22}
}

@ARTICLE{E[35],
    inserir = {false},
  author = {A. Cockburn and L. Williams},
  title = {The costs and benefits of pair programming},
  year = {2000},
  abstract = {Pair or collaborative programming is where two programmers develop
	software side by side at one computer. Using interviews and controlled
	experiments, the authors investigated the costs and benefits of pair
	programming. They found that for a development-time cost of about
	15%, pair programming improves design quality, reduces defects, reduces
	staffing risk, enhances technical skills, improves team communications
	and is considered more enjoyable at statistically significant levels.},
  owner = {Katia},
  references = {Distributed Cognitions: Psychological and educational considerations

	Constantine on Peopleware

	Extreme Programming Explained: Embrace Change

	Strengthening the Case for Pair-Programming

	The Collaborative Software Process

	The Case for Collaborative Programming

	A Discipline for Software Engineering

	Introduction to the Personal Software Process

	Analyzing Distributed Cognition in Software Teams: A Case Study of
	Team Programming During Perfective Software Maintenance

	Advances in software inspections to reduce errors in program development

	Reengineering Inspection: The Future of Formal Technical Review

	Situated Learning: Legitimate peripheral participation

	The Psychology of Computer Programming Silver Anniversary Edition

	Peopleware

	Crystal "Clear": A human-powered software development methodology
	for small teams

	Adaptive Software Development

	Characterizing People as Non-Linear},
  timestamp = {2010.06.21}
}

@ARTICLE{E[36],
    inserir = {false},
  author = {D. Cubranic and M. -A. D. Storey},
  title = {Collaboration Support for Novice Team Programming},
  year = {2005},
  abstract = {Learning computer programming in a modern university course is rarely
	an individual activity; however, IDEs used in introductory programming
	classes do not support collaboration at a level appropriate for novices.
	The goal of our research is to make it easier for first-year students
	to experience working in a team in their programming assignments.
	Based on our previous work developing and evaluating IDEs for novice
	programmers, we have identified two main areas of required functionality:
	1) features for code sharing and coordination; and 2) features to
	support communication. We have extended an existing teaching-oriented
	integrated development environment (called Gild) with features to
	support code sharing and coordination. We report on a preliminary
	study in which pairs of students used a prototype of our collaborative
	IDE to work on a programming assignment. The goals of this study
	were to evaluate the effectiveness and usability of the new features
	and to determine requirements for future communication support.},
  owner = {Katia},
  references = {Building Collaboration into IDEs

	It's all in the words: supporting work activites with lightweight
	tools

	Anchored conversations: chatting in the context of a document

	Using a configuration management tool to coordinate software development

	The impact of pair programming on student performance, perception
	and persistence

	Developing marking support within Eclipse

	Nifty assignments

	Palantír: raising awareness among configuration management workspaces},
  timestamp = {2010.06.22}
}

@ARTICLE{E[37],
    inserir = {false},
  author = {E. Damiani and G. Gianini},
  title = {A Non-invasive Method for the Conformance Assessment of Pair Programming
	Practices Based on Hierarchical Hidden Markov Models},
  year = {2007},
  abstract = {We specify a non-invasive method allowing to estimate the time each
	developer of a pair spends over the development activity, during
	Pair Programming. The method works by performing first a behavioural
	fingerprinting of each developer – based on low level event logs
	– which then is used to operate a segmentation over the log sequence
	produced by the pair: in a timelined log event sequence this is equivalent
	to estimating the times of the switching between developers. We model
	the individual developer’s behaviour by means of a Markov Chain –
	inferred from the logs – and model the developers’ role-switching
	process by a further, higher level, Markov Chain. The overall model
	consisting in the two nested Markov Chains belongs to the class of
	Hierarchical Hidden Markov Models. The method could be used not only
	to assess the degree of conformance with respect to predefined Pair
	Programming switch-times policies, but also to capture the characteristics
	of a given programmers pair’s switching process, namely in the context
	of Pair Programming effectiveness studies.},
  owner = {Katia},
  references = {Extreme programming explained: embrace change, Addison-Wesley Longman
	Publishing Co., Inc., Boston, MA, 1999

	Experimental Evaluation of Pair Programming

	Defining a Distributed Agile Methodology for an Open Source Scenario

	XPSuite: tracking and managing XP projects in the IDE

	Empirical Findings in Agile Methods

	Empirical Evaluation of Agile Processes

	New directions on agile methods: a comparative analysis

	Extreme Programming: First Results from a Controlled Case Study

	Discovering the software process by means of stochastic workflow analysis

	Collecting, Integrating and Analyzing Software Metrics and Personal
	Software Process Data

	Monitoring the Development Process with Eclipse

	Non-invasive product metrics collection: an architecture

	A non-invasive approach to product metrics collection

	Deploying, updating, and managing tools for collecting software metrics

	Managing non-invasive measurement tools

	Segregation of speakers for speech recognition and speaker identification

	Video Segmentation Techniques for News

	Hidden Markov models in computational biology

	Cascaded Markov Models},
  timestamp = {2010.06.22}
}

@ARTICLE{I[16],
    inserir = {true},
  author = {T. H. DeClue},
  title = {Pair Programming and Pair trading:Effects on Learning and motivation
	in a CS2 courses},
  year = {2003},
  abstract = {Pair programming is a seemingly powerful addition to the tool kit
	of educators wishing to enhance learning in software engineering
	students. This technique, found among professional software development
	practices associated with extreme programming (Beck), has probably
	existed informally for some time in various forms of collaborative
	software development. More recently pair programming has been formalized
	and used as an intentional pedagogical tool in the classroom. During
	the Spring semester of 2002, the author implemented a multi-phase
	project in CS2 similar to the one described by Newhall and Meeden
	(2002). The author used pair-programming and pair-trading to facilitate
	the production of high quality code. Qualitative data were collected
	from the students throughout the project. This paper documents the
	qualitative study and sheds some light on why pair programming can
	be successful in educational applications, and also how pair programmers
	can be assessed.},
  owner = {Katia},
  references = {Extreme Programming Explained

	Pairing Promiscously

	The Costs and Benefits of Pair Programming

	A Comprehensive Project for CS2: Combining Key Data Strctures and
	Algorithms into an Integrated Web Browser and Search Engine

	In Support of Student Pair-Programming

	Conversant Pairing},
  timestamp = {2010.06.22}
}

@ARTICLE{E[38],
    inserir = {false},
  author = {A. van Deursen},
  title = {Program comprehension risks and opportunities in extreme programming},
  year = {2001},
  abstract = {Investigates the relationship between reverse engineering and program
	comprehension on the one hand, and the software process on the other.
	To understand this relationship, we select one particular existing
	software process, extreme programming (XP), and study the role played
	in it by program comprehension and reverse engineering. To that end,
	we analyze five key XP practices in depth: pair programming, unit
	testing, refactoring, evolutionary design and collaborative planning.
	The contributions of this paper are: (1) the identification of promising
	research areas in the field of program comprehension; (2) the identification
	of new application perspectives for reverse engineering technology;
	(3) a critical analysis of XP resulting in research questions that
	could help resolve some of the uncertainties surrounding XP; and
	(4) a discussion of the role that comprehension and reverse engineering
	can play in software process design.},
  owner = {Katia},
  references = {Clone detection using abstract syntax trees

	Extreme Programming Explained

	Planning Extreme Programming

	Test infected: Programmers love writing tests

	Reverse engineering processes

	A staged model for the software life cycle

	Linux as a case study: Its extracted software architecture

	The Mythical Man Month

	Reverse engineering and design recovery: A taxonomy

	The costs and benefits of pair programming

	Program understanding: Challenge for the 1990s

	Episodes: A pattern language of competitive development

	Building documentation generators

	Legacy to the extreme

	Refactoring test code

	Analyzing distributed cognition in software teams: A case study of
	team programming during perfective software maintenance

	Refactoring: Improving the Design of Existing Code

	Is design dead?

	Handbook of Walkthroughs, Inspections, and Technical Reviews

	Software process: A roadmap

	Managing the Software Process

	Comments on extreme programming

	Extreme Programming Installed

	Pattern-based reverse-engineering of design components

	Pattern matching for clone and concept detection

	The Rational Unified Process

	Program comprehension during software maintenance and evolution

	Code Complete

	Understanding software systems using reverse engineering technologies:
	Research and practice

	Reverse engineering: A roadmap

	The case for collaborative programming

	Practical Software Maintenance – Best Practices for Managing Your
	Software Investment

	Distributed Cognitions: Psychological and Educational Considerations

	Planning the reengineering of legacy systems

	Strengthening the case for pair-programming

	The Reverse Engineering Notebook},
  timestamp = {2010.06.21}
}

@ARTICLE{E[39],
    inserir = {false},
  author = {A. Dick and B. Zarnett},
  title = {Paired programming \& personality traits},
  year = {2002},
  abstract = {Paired programming is an essential element of extreme programming
	--a methodology comprised of applying best practices to software
	development. Not all developers are suited for paired development
	however, and care should be taken when building a team for extreme
	programming. The team members should be selected with personality
	traits that are beneficial to paired programming. These personality
	traits can be determined through various interview techniques and
	the corresponding behavioral responses of the candidates.},
  owner = {Katia},
  references = {no references: http://www.redhookgroup.com/downloads/paired-presentation.pdf},
  timestamp = {2010.06.21}
}

@ARTICLE{E[40],
    inserir = {false},
  author = {T. Dingsoyr and G. K. Hanssen},
  title = {Extending agile methods: postmortem reviews as extended feedback},
  year = {2002},
  owner = {Katia},
  abstract = {Agile software development methods, such as extreme programming, focus
	on informal learning mechanisms like pair programming. Yet powerful
	methods, new knowledge that is gained in a project does not spread
	rapidly in an organisation if knowledge and experience is not externalised.
	We propose to combine a lightweight externalisation method: postmortem
	reviews with agile methods to strengthen the overall learning, and
	suggest how this can be done. We use practical experience from an
	Extreme Programming development project, and from conducting postmortem
	analysis in several companies in our discussion.},
  references = {Embracing Change with Extreme Programming

	The Social Life of Information

	Experiental Learning: Experience as the Source of Learning and Development

	The Knowledge-Creating Company

	Extreme Programming: A Humanistic Discipline in Software Developmen

	Get Ready for Agile Methods, with Care

	Introduction to Action Research

	Action Research

	Postmortem: Never leave a project without it

	A Defined Process For Project Post Mortem Review

	Post Mortem - An Assessment of Two Approaches

	Augmenting Experience Reports with Lightweight Postmortem Reviews

	The KJ Method: A Technique for Analyzing Data Derived from Japanese
	ethnology

	Extreme Programming Explained},
  timestamp = {2010.06.21}
}

@ARTICLE{E[41],
    inserir = {false},
  author = {M. A. Domino},
  title = {Three studies of problem solving in collaborative software development},
  year = {2006},
  abstract = {A potential solution to producing quality software in an acceptable
	time frame may be found by using the newer, innovative methods, such
	as collaborative software development. The purpose of this dissertation
	is to examine the individual developer characteristics, developmental
	settings, collaborative methods and the processes during development
	that impact collaborative programming performance and satisfaction
	outcomes. Understanding individual differences in performance in
	the collaborative development setting is important, since it may
	help us understand how the collaborative setting may raise the lowest
	level of performance to much higher levels, as well as how to select
	individuals for collaborative development. Exploring the impact of
	the virtual setting on collaborative development processes is important
	as it may help us improve performance outcomes in different work
	settings. Investigating how adaptations of pair programming impact
	collaborative processes may assist in implementing changes to the
	method that enhance quality and individual satisfaction. A multi-phase
	methodology is used, consisting of an intensive process study (Study
	1) and two laboratory experiments (Studies 2 and 3). Study 1 illustrates
	that collaborative programming (pair programming) outcomes are moderated
	by both individual developer differences and the processes used during
	development. While cognitive ability and years of IT experience are
	important factors in performance, the impacts of conflict and the
	faithful appropriation of the method are highlighted. Distributed
	cognition is used as a theoretical foundation for explaining higher
	performance. Study 2 findings suggest that while collaborative programming
	is possible in a virtual setting, performance is negatively impacted.
	Face-to-face programmers have significantly higher levels of task
	performance, as well as satisfaction with the method, when compared
	to virtual programmers. Study 3 results suggests that the use of
	structured problem solving (preparing test cases before writing code)
	may be a key factor in producing higher quality code, while collaboration
	may be indusive to higher levels of developer satisfaction. By understanding
	how, why and when collaborative programming techniques produce better
	performance outcomes and what factors contribute to that success,
	we add to the body of knowledge on methodologies in the MIS domain.},
  owner = {Katia},
  references = {(no available): http://portal2.acm.org/citation.cfm?id=1269219&coll=GUIDE&dl=GUIDE&CFID=93468120&CFTOKEN=35338465

	(no available): Three studies of problem solving in collaborative
	software development

	(no available): Three studies of problem solving in collaborative
	software development

	(no available): Three studies of problem solving in collaborative
	software development

	(no available): Three studies of problem solving in collaborative
	software development

	(no available): Three studies of problem solving in collaborative
	software development

	(no available): Three studies of problem solving in collaborative
	software development

	(no available): Three studies of problem solving in collaborative
	software development

	(no available): Three studies of problem solving in collaborative
	software development

	(no available): Three studies of problem solving in collaborative
	software development

	(no available): Three studies of problem solving in collaborative
	software development},
  timestamp = {2010.06.22}
}

@ARTICLE{E[7],
    inserir = {false},
  author = {M. A. Domino and R. W. Collins and A. R. Hevner},
  title = {Controlled experimentation on adaptations of pair programming},
  year = {2007},
  abstract = {The use of agile methods is growing in industrial practice due to
	the documented benefits of increased software quality, shared programmer
	expertise, and user satisfaction. These methods include pair programming
	(two programmers working side-by-side producing the code) and test-driven
	approaches (test cases written first to prepare for coding). In practice,
	software development organizations adapt agile methods to their environment.
	The purpose of this research is to understand better the impacts
	of adapting these methods. We perform a set of controlled experiments
	to investigate how adaptations, or variations, to the pair programming
	method impact programming performance and user satisfaction. We find
	that method variations do influence programming results. In particular,
	better performance and satisfaction outcomes are achieved when the
	pair programming is performed in face-to-face versus virtual settings,
	in combination with the test-driven approach, and with more experienced
	programmers. We also find that limiting the extent of collaboration
	can be effective, especially when programmers are more experienced.
	These experimental results provide a rigorous foundation for deciding
	how to adapt pair programming methods into specific project contexts.},
  owner = {Katia},
  references = {Technical and human perspectives on pair programming

	On the adaptation of an agile information systems development method

	Extreme Programming Explained

	Using risk to balance agile and plan-driven methods

	Balancing Agility and Discipline: A Guide for the Perplexed

	Pair programming: development times two

	The Mythical Man-Month

	Conflict in collaborative software development

	Agile modeling, agile software development, and extreme programming:
	the state of research

	An empirical study of system development method tailoring in practice

	Software development tailoring at Motorola

	Analyzing distributed cognition in software teams: a case study of
	team programming during perfective software maintenance

	Applying adaptive structuration theory to investigate the process
	of group support systems use

	Teaching extreme programming to large groups of students

	Organizational Psychology: A Scientist-Practitioner Approach

	Extreme programming and agile software development methodologies

	The Odyssey and other code science success stories

	Questioning Extreme Programming

	Interaction and Performance

	On the economic valuation of XP Projects

	Experimental evaluation of pair programming

	The case for collaborative programming

	A field study of developer pairs: productivity impacts and implications

	Use of group decision support systems as an appropriation process

	Understanding the use of group decision support systems: the theory
	of adaptive structuration

	A proposal for context-specific method engineering

	Information modeling and method engineering: a psychological perspective

	A survey of controlled experiments in software engineering

	Limitations of agile software processes

	Assumptions underlying agile software-development processes

	An emerging distributed work arrangement: an investigation of computer-based
	supplemental work at home

	Strengthening the case for pair programming},
  timestamp = {2010.06.22}
}

@ARTICLE{I[18],
    inserir = {true},
  author = {M. A. Domino and R. W. Collins and A. R. Hevner},
  title = {Controlled experimentation on adaptations of pair programming},
  year = {2007},
  abstract = {The use of agile methods is growing in industrial practice due to
	the documented benefits of increased software quality, shared programmer
	expertise, and user satisfaction. These methods include pair programming
	(two programmers working side-by-side producing the code) and test-driven
	approaches (test cases written first to prepare for coding). In practice,
	software development organizations adapt agile methods to their environment.
	The purpose of this research is to understand better the impacts
	of adapting these methods. We perform a set of controlled experiments
	to investigate how adaptations, or variations, to the pair programming
	method impact programming performance and user satisfaction. We find
	that method variations do influence programming results. In particular,
	better performance and satisfaction outcomes are achieved when the
	pair programming is performed in face-to-face versus virtual settings,
	in combination with the test-driven approach, and with more experienced
	programmers. We also find that limiting the extent of collaboration
	can be effective, especially when programmers are more experienced.
	These experimental results provide a rigorous foundation for deciding
	how to adapt pair programming methods into specific project contexts.},
  owner = {Katia},
  references = {Technical and human perspectives on pair programming

	On the adaptation of an agile information systems development method

	Extreme programming explained: embrace change

	Using Risk to Balance Agile and Plan-Driven Methods

	Balancing Agility and Discipline: A Guide for the Perplexed

	Pair programming: development times two

	The mythical man-month

	Conflict in collaborative software development

	Agile modeling, agile software development, and extreme programming:
	the state of research

	An empirical study of system development method tailoring in practice

	Software development method tailoring at Motorola

	Analyzing distributed cognition in software teams: a case study of
	team programming during perfective software maintenance

	Applying adaptive structuration theory to investigate the process
	of group support systems use

	Teaching extreme programming to large groups of students

	Organizational Psychology: A Scientist-Practitioner Approach

	Extreme programming and agile software development methodologies

	The Odyssey and other code science success stories

	Questioning Extreme Programming

	Groups: Interaction and Performance

	On the economic evaluation of XP projects

	Experimental evaluation of pair programming

	The case for collaborative programming

	A Field Study of Developer Pairs: Productivity Impacts and Implications

	Use of group decision support systems as an appropriation process

	Understanding the use of group decision support systems: the theory
	of adaptive structuration

	A proposal for context-specific method engineering

	Information modeling and method engineering: a psychological perspective

	A Survey of Controlled Experiments in Software Engineering

	Limitations of agile software processes

	Assumptions underlying agile software-development processes

	An emerging distributed work arrangement: an investigation of computer-based
	supplemental work at home

	Strengthening the Case for Pair Programming},
  timestamp = {2010.06.23}
}

@ARTICLE{I[17],
    inserir = {true},
  author = {M. A. Domino and R. W. Collins and A. R. Hevner and C. F. Cohen},
  title = {Conflict in Collaborative Software Development},
  year = {2003},
  abstract = {Pair Programming is an innovative collaborative software development
	methodology. Anecdotal and empirical evidence suggests that this
	agile development method produces better quality software in reduced
	time with higher levels of developer satisfaction. To date, little
	explanation has been offered as to why these improved performance
	outcomes occur. In this qualitative study, we focus on how individual
	differences, and specifically task conflict, impact results of the
	collaborative software development process and related outcomes.
	We illustrate that low to moderate levels of task conflict actually
	enhance performance, while high levels mitigate otherwise anticipated
	positive results.},
  owner = {Katia},
  references = {Adopting Extreme Programming

	Interpersonal Conflict and its Management in Information Systems Development

	Relating Member Ability and Personality to Workteam Processes and
	Team Effectiveness

	Extreme Programming Explained

	The Managerial Grid

	Derivation and Implications of a Meta-analytic Matrix Incorporating
	Cognitive Ability, Alternative Predictors, and Job Performance

	The Mythical Man Month

	Methods of resolving superior-subordinate conflict: The constructive
	use of subordinate differences and disagreements

	Conflict Resolution

	Managing Conflict in Software Testing: Lessons from the Field

	Just-In-Time Methodology Construction: Humans and Technology

	Extreme Programming: What is a Lightweight Mythology?

	Fundamentals of Software Engineering

	Cognitive Ability, Cognitive Aptitudes, Job Knowledge, and Job Performance

	A Multimethod Examination of the Benefits and Detriments of Intragroup
	Conflict

	A Qualitative Analysis of Conflict Types and Dimensions in Organizational
	Groups

	Manager conflict

	management style and leadership effeteness: The Moderating effects
	of gender

	Adaptability to

	Changing Task Contexts: Effects of General Cognitive Ability, Conscientiousness,
	and Openness to Experience

	The Background of Conflict in Marriage

	Questioning Extreme Programming

	Searching for Common Threads:

	Understanding the Multiple Effects of Diversity in Organizational
	Groups

	A Social Process Model of User-Analyst Relationships

	The Case for Collaborative Programming

	Demographic Diversity, Conflict, and Work Group Outcomes: An Intervening
	Process Theory

	Rahim Organizational Conflict Inventory-II

	A Measure of styles of handling interpersonal conflict

	Managing organizational conflict: a model for diagnosis and intervention

	A Comparison of the Value Systems of Adaptive

	Software Development and Extreme Programming: How Methodologies May
	Learn from Each Other

	Task Differences and the Validity of Aptitude Tests in Selection:
	A Red Herring

	Adverse Impact and Predictive Efficiency of Various Predictor Combinations

	Leadership Emergence in Autonomous Work Teams: Antecedents and Outcomes

	Information Systems Development: Can There be "Good" Conflict?

	The Conflict Positive Organization

	An emerging distributed

	work arrangement: an investigation of computer-based supplemental
	work at home

	The impact of remote work on information organizational communication

	Strengthening the Case for Pair Programming

	Wonderlic Personnel Test & Scholastic Level Exam Users Manual

	Practice, ability and expertise in computer programming},
  timestamp = {2010.06.22}
}

@ARTICLE{E[42],
    inserir = {false},
  author = {J. Drobka and D. Noftz and R. Raghu},
  title = {Piloting XP on four mission-critical projects},
  year = {2004},
  abstract = {According to proponents, extreme programming creates focused, efficient
	software development that heavily emphasizes customer involvement.
	As software developers for mission-critical two-way radio systems
	in Motorola's commercial, government, and industrial solutions sector,
	we'd been hearing a lot about XP's benefits. Software development
	teams constantly battle to increase productivity while maintaining
	or improving quality . Four Motorola teams piloted extreme programming
	to see if it would let them satisfy their customers' constantly changing
	requirements while improving productivity.},
  owner = {Katia},
  references = {Extreme programming explained: embrace change

	Extreme Programming Installed

	Pair Programming Illuminated

	Refactoring: improving the design of existing code

	Balancing Agility and Discipline: A Guide for the Perplexed

	Writing Effective Use Cases},
  timestamp = {2010.06.22}
}

@ARTICLE{E[43],
    inserir = {false},
  author = {Y. Dubinsky and O. Hazzan},
  title = {Using a role scheme to derive software project metrics},
  year = {2006},
  abstract = {Roles' playing is common in our lives. We play different roles with
	our family, at work as well as in other environments. Role allocation
	in software development projects is also accepted though it may be
	implemented differently by different software development methods.
	In a previous work [Y. Dubinsky, O. Hazzan, Roles in agile software
	development teams, in: 5th International Conference on Extreme Programming
	and Agile Processes in Software Engineering, 2004, pp. 157-165] we
	have found that personal roles may raise teammates' personal accountability
	while maintaining the essence of the software development method.
	In this paper we present our role scheme, elaborate on its implementation
	and explain how it can be used to derive metrics. We illustrate our
	ideas by data gathered in student projects in the university.},
  owner = {Katia},
  references = {Extreme programming explained: embrace change

	Roles in agile software development teams

	The construction process of a framework for teaching software development
	methods

	Team research and team training: A state-of-the-art review

	Agile software development ecosystems

	Introduction to the team software process

	The Social System

	A quantitative approach to software management: the AMI handbook

	Industrial Strength Software - Effective Management Using Measurement},
  timestamp = {2010.06.22}
}

@ARTICLE{E[44],
    inserir = {false},
  author = {S. H. Edwards},
  title = {Improving Student Performance by Evaluating How Well Students Test
	Their Own Programs},
  year = {2004},
  abstract = {Students need to learn more software testing skills. This paper presents
	an approach to teaching software testing in a way that will encourage
	students to practice testing skills in many classes and give them
	concrete feedback on their testing performance, without requiring
	a new course, any new faculty resources, or a significant number
	of lecture hours in each course where testing will be practiced.
	The strategy is to give students basic exposure to test-driven development,
	and then provide an automated tool that will assess student submissions
	on-demand and provide feedback for improvement. This approach has
	been demonstrated in an undergraduate programming languages course
	using a prototype tool. The results have been positive, with students
	expressing appreciation for the practical benefits of test-driven
	development on programming assignments. Experimental analysis of
	student programs shows a 28% reduction in defects per thousand lines
	of code.},
  owner = {Katia},
  references = {Production programming in the classroom

	Reliable benchmarks using numerical instability

	Guidelines for Software Engineering Education Version 1.0

	Test Driven Development: By Example

	Software testing techniques (2nd ed.)

	Software engineering

	Guide to the Software Engineering Body of Knowledge--Stone Man Trial
	Version 1.00

	Design early considered harmful: graduated exposure to complexity
	and structure based on levels of cognitive development

	Checkstyle home page

	Clover: a code coverage tool for Java.

	Rethinking computer science education from a test-first perspective

	A gimmick to integrate software testing throughout the curriculum

	Testing: a roadmap

	Software quality: a curriculum postscript?

	Developing an automated program checkers

	Grading student programs using ASSYST

	Software testing in the computer science curriculum -- a holistic
	approach

	SPRAE: A framework for teaching software testing in the undergraduate
	curriculum

	Integrating testing into the curriculum — arsenic in small doses

	An experiential approach to incorporating software testing into the
	computer science curriculum

	Grading student programs - a software testing approach

	Unit home page

	A secure on-line submission system, Software—Practice & Experience

	Improving the CS1 experience with pair programming

	The effective integration of software engineering principles throughout
	the undergraduate computer science curriculum

	The assimilation of software engineering into the undergraduate computer
	science curriculum (panel session)

	Curator: An electronic submission management environment

	A case study of the static analysis of the quality of novice student
	programs

	A software infrastructure to support introductory computer science
	courses

	The state of software: Quality

	More testing should be taught

	In support of student pair-programming

	UNIX test tools and benchmarks: methods and tools to design, develop,
	and execute functional, structural, reliability, and regression tests},
  timestamp = {2010.06.22}
}

@ARTICLE{E[45],
    inserir = {false},
  author = {H. H. Emurian and H. K. Holden and R. A. Abarbanel},
  title = {Managing programmed instruction and collaborative peer tutoring in
	the classroom: Applications in teaching Java(TM)},
  year = {2007},
  abstract = {To fulfill part of the course requirements, 34 undergraduate students
	in two courses completed an online programmed instruction tutor as
	the first technical training exercise in a Java(TM) programming course
	designed for information systems majors. The tutor taught a simple
	JApplet program to display a text string within a browser window
	on the Web. Students in the first course next participated in a collaborative
	peer tutoring session, based on the JApplet program, followed by
	a lecture on the program and by successfully running the program
	on the Web. For the second course, the peer tutoring session was
	scheduled after the lecture and after successfully running the program.
	Students in both courses completed tests of far transfer ("meaningful
	learning") and software self-efficacy before using the tutor and
	on several subsequent occasions following that initial learning.
	Students in the second course also completed a 4-item scale to assess
	the development of classification and functionality knowledge regarding
	elements of the program. Students in both courses showed progressive
	improvement in all performance measures across the several assessment
	occasions. Students' positive ratings of the effectiveness of both
	the tutor and the collaborative peer tutoring supported the value
	of these learning experiences in a technical knowledge domain. The
	results of this study, based on student performance observed within
	the context of the classroom, show the importance of providing a
	range of synergistic learning experiences that culminate in a level
	of skill and confidence that prepares and motivates all students
	for advanced instruction in Java. They also show how to manage the
	instructional techniques in the classroom to accomplish that educational
	outcome.},
  owner = {Katia},
  references = {Skill acquisition and the LISP tutor

	Cognitive tutors: Lessons learned

	The automated tutoring of introductory computer programming

	Self-efficacy: Toward a unifying theory of behavioral change

	Design-based research: Putting a stake in the ground (Introduction
	to a special issue)

	Understanding and verbal regulation

	When and where do we apply what we learn? A taxonomy for far transfer

	The technology of teaching revisited: A reader's companion to B.F.
	Skinner's book

	Cooperative learning techniques in CS1: design and experimental evaluation

	On the theoretical breadth of design-based research in education

	Design-based research in education

	Interteaching: A strategy for enhancing the user-friendliness of behavioral
	arrangements in the college classroom

	Design experiments: Theoretical and methodological challenges in creating
	complex interventions in classroom settings

	Item-by-item versus end-of-test feedback in a computer-based PSI course

	Toward a design science of education

	Design research: Theoretical and methodological issues

	The impending revolution in undergraduate science education

	Design-Based Research Collective

	Design research: What we learn when we engage in design

	Ecological/developmental theory, context-based best practice, and
	school-based action research: Cornerstones of school psychology training
	and policy

	The consequences of e-Learning (Editorial)

	A programmed instruction tutoring system for Java: Consideration of
	learning performance and software self-efficacy

	Web-based programmed instruction: Evidence of rule-governed learning

	A web-based tutor for Java: Evidence of meaningful learning

	Assessing the effectiveness of programmed instruction and collaborative
	peer tutoring in teaching Java

	Computer-based tutoring systems: a behavioral approach

	Analysis of learner performance on a tutoring system for Java

	Inference and classification learning of abstract coherent categories

	Providing complete and integrated information science education

	Evaluating and improving undergraduate teaching in science, technology,
	engineering, and mathematics


	Methodological alignment in design-based research

	Taming Java for the classroom

	Internet self-efficacy and electronic service acceptance

	After All--the Nature of Learning Computer Programming

	The psycho-social processes and cognitive effects of peer-based collaborative
	interactions with computers

	Teaching programming - A journey from teacher to motivator

	An empirical investigation of sources of application-specific computer-self-efficacy
	and mediators of the efficacy: performance relationship

	Lowering the barriers to programming: A taxonomy of programming environments
	and languages for novice programmers

	Research as design (Introduction to special issue: The role of design
	in educational research)

	Creating a sense of "presence" in a web-based PSI course: The search
	for Mark Hopkins' log in a digital log

	The BlueJ system and its pedagogy

	The Keller plan in science teaching

	Treatment integrity: An essential - but often forgotten - component
	of school-based interventions

	Building a practically useful theory of goal setting and task motivation

	Individual and organisational factors influencing academics' decisions
	to pursue the scholarship of teaching ICT

	Category number impacts rule-based but not information-integration
	category learning: Further evidence for dissociable category-learning
	systems

	Evaluating outcomes

	Self-regulated learning, social cognitive theory, and agency

	Fostering the intelligent novice: Learning from errors with metacognitive
	tutoring

	Designing experiments and analyzing data: A model comparison perspective

	Teaching and learning computer programming: Multiple research perspectives

	The promise of educational psychology

	Should there be a three-strikes rule against pure discovery learning?

	Teaching of subject matter

	Improving undergraduate instruction in science, technology, engineering,
	and mathematics

	Learning from programmed instruction: Examining implications for modern
	instructional technology

	Mindstorms: children, computers, and powerful ideas

	An online problem-based model for the learning of Java

	Identifying and implementing educational practices supported by rigorous
	evidence

	Taking the load off a learner's mind: Instructional design for complex
	learning

	Programmed instruction: What it is and how to do it

	Experiment with industry's "pair-programming" model in the computer
	science classroom

	In support of pair programming in the introductory computer science
	course

	Programming pedagogy—a psychological overview

	Educational psychology

	Can computer-based learning environments (CBLEs) be used as self-regulatory
	tools to enhance learning?},
  timestamp = {2010.06.22}
}

@ARTICLE{E[46],
    inserir = {false},
  author = {H. Erdogmus and L. Williams},
  title = {The economics of software development by pair programmers},
  year = {2003},
  abstract = {Evidence suggests that pair programmers - two programmers working
	collaboratively on the same design, algorithm, code, or test-perform
	substantially better than the two would work alone. Improved quality,
	teamwork, communication, knowledge management, and morale have been
	among the reported benefits of pair programming. This paper presents
	a comparative economic evaluation that strengthens the case for pair
	programming. The evaluation builds on the quantitative results of
	an empirical study conducted at the University of Utah. The evaluation
	is performed by interpreting these findings in the context of two
	different, idealized models of value realization. In the first model,
	consistent with the traditional waterfall process of software development,
	code produced by a development team is deployed in a single increment;
	its value is not realized until the full project completion. In the
	second model, consistent with agile software development processes
	such as extreme programming, code is produced and delivered in small
	increments; thus its value is realized in an equally incremental
	fashion. Under both models, our analysis demonstrates a distinct
	economic advantage of pair programmers over solo programmers. Based
	on these preliminary results, we recommend that organizations engaged
	in software development consider adopting pair programming as a practice
	that could improve their bottom line. To be able to perform quantitative
	analyses, several simplifying assumptions had to be made regarding
	alternative models of software development, the costs and benefits
	associated with these models, and how these costs and benefits are
	recognized. The implications of these assumptions are addressed in
	the paper.},
  owner = {Katia},
  references = {XP Applied

	Building Knowledge Through Families of Experiments

	Extreme Programming Explained: Embrace Change

	The Agile Manifesto

	Optional Scope Contracts

	Planning Extreme Programming

	Software Engineering Economics

	The Costs and Benefits of the Earned Value Management Process

	The Costs and Benefits of Pair Programming

	The Costs and Benefits of Pair Programming

	Constantine on Peopleware

	A Development Process Generative Pattern Language

	Communication Metrics for Software Development

	Comparative evaluation of software development strategies based on
	Net Present Value

	Quantitative Approaches for Assessing the Value of COTS-centric Development

	Value-Based Software Reuse Investment

	Put Your Process on a Diet

	Software Hell

	The Personal Software Process: An Empirical Study of the Impact of
	PSP on Individual Engineers

	Managing the Software Process

	A Discipline for Software Engineering

	Software Quality: Analysis and Guidelines for Success

	Taming the Tiger: Software Engineering and Software Economics

	The Case for Collaborative Programming

	Knowledge Management through Pair Programming Masters Thesis

	The Scrum Software Development Process for Small Teams

	Managing the development of large software systems: concepts and techniques

	Experience with Inspection in Ultralarge-Scale Developments

	Extreme Programming Examined

	Extreme Programming Explored

	Programming In Pairs

	Pair Programming Illuminated

	Strengthening the Case for Pair-Programming

	The Collaborative Software Process PhD Dissertation

	All I Ever Needed to Know About Pair Programming I Learned in Kindergarten,

	GAAP 2003: Interpretation and Application of Generally Accepted Accounting
	Principles},
  timestamp = {2010.06.22}
}

@ARTICLE{E[47],
    inserir = {false},
  author = {J. Erickson and K. Lyytinen and K. Siau},
  title = {Agile modeling, agile software development, and extreme programming:
	the state of research},
  year = {2005},
  abstract = {While there are many claims for the successful use of extreme programming
	(XP) and agile modeling (AM), and the proponents can often be vocal
	in the extreme regarding their supposed benefits, research evidence
	supporting proponents' claims is somewhat lacking. Currently, the
	only research appearing to investigate the phenomena consists of
	two prominent streams. A small number of case studies and experience
	reports that generally promote the success of XP in various development
	environments, and a well-established stream of research into pair
	programming has generated results that in part support the idea of
	XP. Research into AM appears to be even more sparse than that for
	XP. Case studies, comparative analyses, and experience reports comprise
	the majority of the research in the area, while very few empirical
	research efforts have been conducted. This article reviews the state
	of research in XP and AM, and recommends areas that could benefit
	from further study. Since nearly all empirical XP research relates
	to pair programming, a closer look into the unstudied XP core practices
	would be beneficial, although interaction between related core practice
	areas could confound such efforts. It might also be possible to group
	related core XP concepts and study the groups individually. Finally,
	there are those who claim that XP and AM, or even agility in general,
	are really nothing more than a repackaging of old concepts. This
	claim needs to be investigated .},
  owner = {Katia},
  references = {no references: http://cba.unl.edu/outreach/unl-ibm/coursemod/materials/documents/Agile_Modeling.pdf},
  timestamp = {2010.06.22}
}

@ARTICLE{E[49],
    inserir = {false},
  author = {J. Favela and H. Natsu and C. Pérez and O. Robles and A. L. Morán
	and R. Romero and A. M. Martínez-Enríquez and D. Decouchant},
  title = {Empirical evaluation of collaborative support for distributed pair
	programming},
  year = {2004},
  abstract = {Pair programming is an Extreme Programming (XP) practice where two
	programmers work on a single computer to produce an artifact. Empirical
	evaluations have provided evidence that this technique results in
	higher quality code in half the time it would take an individual
	programmer. Distributed pair programming could facilitate opportunistic
	pair programming sessions with colleagues working in remote sites.
	In this paper, we present the preliminary results of the empirical
	evaluation of the COPPER collaborative editor, developed explicitly
	to support pair programming. The evaluation was performed on three
	different conditions: pairs working collocated on a single computer;
	distributed pairs working in application sharing mode; and distributed
	pairs using collaboration aware facilities. In all three cases the
	subjects used the COPPER collaborative editor. The results support
	our hypothesis that distributed pairs could find the same amount
	of errors as their collocated counterparts. However, no evidence
	was found that the pairs that used collaborative awareness services
	had better code comprehension, as we had also hypothesized.},
  owner = {Katia},
  references = {The Cost and Benefits of Pair Programming

	Global Software Development

	Distributed Extreme Programming

	Document Presence Notification Services for Collaborative Writing

	Distributed Pair Programming in the Web

	Collaborative Authoring on the Web: Introducing WebDAV

	All I Really Need to Know about Pair Programming I Learned in Kindergarten

	Strengthening the Case for Pair Programming},
  timestamp = {2010.06.22}
}

@ARTICLE{E[50],
    inserir = {false},
  author = {B. Fitzgerald and G. Hartnett},
  title = {A study of the use of agile methods within Intel},
  year = {2005},
  abstract = {This study investigated the use of the agile methods, extreme programming
	(XP) and Serum, at the Intel Network Processor Division engineering
	team based in Shannon, Ireland, over a three-year-period The study
	is noteworthy as it is based on real industrial software projects
	involving experienced software engineers, with continuous reflection
	and monitoring of the application of these approaches. It provides
	evidence that agile methods are far from anti method; rather, they
	require disciplined application and careful customization to the
	particular needs of the development context. The study also shows
	how XP and Serum can complement each other to provide a comprehensive
	agile development method, with XP providing support for technical
	aspects and Serum providing support for project planning and tracking.
	The manner in which XP and Serum have been customized to suit the
	needs of the development environment at Intel Shannon is described,
	as are the lessons learned. The XP practices that were applied did
	lead to significant benefits, with pair-programming leading to reductions
	in code defect density, of a factor of seven, and one project actually
	achieving zero defect density However, some observed limitations
	of pair-programming are described. Intel Shannon also found that
	not all XP practices were applicable in their context. Thus. the
	study suggests that, contrary to suggestions that XP is not divisible
	or individually selectable, a la carte selection and tailoring of
	XP practices can work very well. In the case of Serum, some local
	customization has led to a very committed adoption by developers
	themselves, in contrast to many development methods whose use is
	decreed mandatory by management. The success of Scrum is significant.
	Projects of sLX-month and one-year duration have been delivered ahead
	of schedule, which bodes well for future ability to accurately plan
	development projects, a black art in software development up to now.},
  owner = {Katia},
  references = {New Directions on Agile Methods: A Comparative Analysis

	Extreme Programming Explained

	The Case Research Strategy in Studies oflnformation Systems

	A Spiral Model of Software Development and Maintenance

	Clystal Light Methods

	EPISODES: .4 Pattei-n Language of Competitive Development Part I

	Building Theory from Case Study Research

	An Empirical Investigation into the Adoption of Systems Development
	Methodologies

	Introducing Software Engineering by Means of Extreme Programming

	Extreme Programming and Scrum: A Local Experience Report from Geanvorks

	Does Agility Work?

	A Scientific Methodology for MIS Case Studies

	The Delphi Method: Techniques and Applications

	Desigrlirlg Qualitative Research

	Extreme Programming from a CMMl Perspective

	Lean Programming

	The Scruns ofhvare Development Process for Small Teams

	Will the Real Agile Processes Please Stand Up

	Agile Programming Techniques Spark Interest

	The Case Study: .4 Useful Research Method for Information Management

	A Study of the Interaction Between In Sonnation

	Applied Qualitative Research

	Study Research: Design and Methods

	Publications, C.4. 1994.},
  timestamp = {2010.06.22}
}

@ARTICLE{E[51],
    inserir = {false},
  author = {N. V. Flor},
  title = {Globally distributed software development and pair programming},
  year = {2006},
  abstract = {This paper examines whether globally distributed software development
	teams can enjoy the benefits that pair programming offers. The paper
	lists seven properties that need to exist before the benefits of
	pair programming can be realized. These properties emerge when two
	people work side-by-side in close proximity. This paper underscores
	the importance for "remote" pairs to exhibit these properties if
	they want to reap the same benefits as close-proximity pair programming.},
  owner = {Katia},
  references = {Extreme Programming Explained: Embrace Change

	Side-by-side collaboration: a case study

	Analyzing distributed cognition in software teams

	Strengthening the Case for Pair Programming},
  timestamp = {2010.06.22}
}

@ARTICLE{E[52],
    inserir = {false},
  author = {R. J. Fornaro and M. R. Heil and A. L. Tharp},
  title = {Reflections on 10 years of sponsored senior design projects: Students
	win-clients win!},
  year = {2007},
  abstract = {Undergraduate computer science degree programs often provide an opportunity
	for students to experience real software projects as a part of their
	programs of study. These experiences frequently reside in a course
	in which students form software development teams, are assigned to
	a project offered by a corporate sponsor and devote one or two semesters
	to the task of making progress on the project. In an ideal model,
	faculty mentor student teams who, in turn, behave as subcontractors
	or consultants to the sponsor. Students work for a grade, not directly
	for the sponsor as a true subcontractor would. In the ideal model,
	students demonstrate what they have learned about software engineering
	process, as well as their ability to implement programmed solutions.
	Student teams provide progress reports, both oral and written, and
	directly experience many of the challenges and successes of true
	software engineering professionals. This paper reports on one such
	program after 10 years of operation. The technologies and software
	development processes of student projects are summarized and presented
	as an informal survey. Student response is discussed in terms of
	software systems they produced and how they went about producing
	them. The maturation of these students as software engineering professionals
	is also discussed.},
  owner = {Katia},
  references = {Eliminating Aversion to Software Process In Computer Science Students
	And Measuring the Results

	A framework in which to teach (technical) communication to computer
	science majors

	Offshore outsourcing: current conditions & diagnosis

	Computing, We Have a Problem?

	On becoming a winning student team: placing third in an international
	design competition

	Exploring Requirements: Quality Before Design

	Foundation Software Engineering Practices for Capstone Projects and
	Beyond

	Focusing Software Education on Engineering

	On a Partnership between Software Industry and Academia

	A Comparison of Computer Science and Software Engineering Programmes
	in English Universities

	Senior Design Team Projects Presented at Spring Posters and Pies

	Incorporating Software Process in an Undergraduate Software Engineering
	Curriculum: Challenges and Rewards},
  timestamp = {2010.06.22}
}

@ARTICLE{E[53],
    inserir = {false},
  author = {P. Freedman},
  title = {Pair programming a la dijkstra},
  year = {2002},
  abstract = {(no abstract)},
  owner = {Katia},
  references = {(not founded): Pair programming a la dijkstra

	(not founded): Pair programming a la dijkstra

	(not founded): Pair programming a la dijkstra

	(not founded): Pair programming a la dijkstra

	(not founded): Pair programming a la dijkstra

	(not founded): Pair programming a la dijkstra

	(not founded): Pair programming a la dijkstra

	(not founded): Pair programming a la dijkstra

	(not founded): Pair programming a la dijkstra

	(not founded): Pair programming a la dijkstra},
  timestamp = {2010.06.21}
}

@ARTICLE{I[19],
    inserir = {true},
  author = {S. F. Freeman and B. K. Jaeger and J. C. Brougham},
  title = {Pair programming: More learning and less anxiety in a first programming
	course},
  year = {2003},
  abstract = {The impact of pair programming in education design to enhance the
	student's learning experience through team is discussed. It involves
	the students undertaking and completing some aspect of their programming
	work as a team of two. The objective of this course is to teach first-year
	engineering student logic and problem solving skill through algorithm
	programming. The objective analysis taking into consideration the
	students grades and timesheet support, at a prima facie level, the
	students' accounts of their experiences.},
  owner = {Katia},
  references = {Extreme Programming Explained: Embrace Change

	Organizing Genius: The Secrets of Creative Collaboration

	KBN Grant 8T11AO1618

	The Effects of Pair Programming on Performance in an Introductory
	Programming Course.

	The Case for Collaborative Programming

	Pair Programming

	The Collaborative Software Process

	Strengthening the Case for Pair Programming

	The Effects of "Pair-Pressure" and "Pair-Learning" on Software Engineering
	Education

	Experimenting with Industry's "Pair-Programming" model in the computer
	science classroom

	In Support of Student Pair Programming

	In support of Pair Programming in the Introductory Computer Science
	Course

	Pair Programming Questionnaire},
  timestamp = {2010.06.22}
}

@ARTICLE{E[54],
    inserir = {false},
  author = {T. Frever and P. Ingalls},
  title = {The pairing session as the atomic unit of work},
  year = {2006},
  abstract = {We have an extreme programming team at a small company dedicated to
	the agile approach. Our team of 7 developers decided to use the pairing
	session as the fundamental unit of work for all organizing, planning,
	estimating, tracking, and of course, pair programming. It's been
	a great way to structure the day, provide rhythm and facilitate partner
	swaps. Estimating and tracking in pairing sessions provides us concrete
	feedback for improving estimates. This approach constitutes a hybrid
	between real time and abstract-unit estimating, resulting in highly
	effective planning and an extremely stable velocity. We have been
	working this way for about a year and have been exceptionally pleased
	with the results.},
  owner = {Katia},
  references = {(not available): http://www.computer.org/portal/web/csdl/doi/10.1109/AGILE.2006.55

	(not available): The pairing session as the atomic unit of work

	(not available): The pairing session as the atomic unit of work

	(not available): The pairing session as the atomic unit of work

	(not available): The pairing session as the atomic unit of work

	(not available): The pairing session as the atomic unit of work

	(not available): The pairing session as the atomic unit of work

	(not available): The pairing session as the atomic unit of work

	(not available): The pairing session as the atomic unit of work

	(not available): The pairing session as the atomic unit of work

	(not available): The pairing session as the atomic unit of work},
  timestamp = {2010.06.22}
}

@ARTICLE{E[55],
    inserir = {false},
  author = {A. Fruhling and G. J. De Vreede},
  title = {Field experiences with eXtreme programming: Developing an emergency
	response system},
  year = {2006},
  abstract = {eXtreme Programming (XP) is a well-known agile software development
	method. While a number of reports have been published on explaining
	the XP methodology and the perceived benefits when using XP for system
	development in recent years, less is known about the actual operationalization
	of the XP principles. This paper presents an action research study
	reporting on the experiences of implementing the XP methodology in
	a development project for a Web-based, distributed information system.
	The goal of this research was to increase the understanding of how
	to effectively operationalize XP techniques so that the system being
	developed catered to today's fast-paced technological environment
	by allowing the developers to respond quickly to innovative and changing
	requirements. Overall, the research indicates that most of the XP
	principles could be effectively implemented; however, three of the
	principles required modification (i.e., testing, pair programming,
	customer collocation). Several benefits resulted from the usage of
	XP. The rapid prototyping enabled information technology developers
	and users to clarify system requirements, communicate openly, quickly
	build rapport, and create an interface that was easy to use and learn.
	Further, the research found that where the technology was new or
	foreign to the development team and the user, the XP process was
	flexible enough to support several iterations of technology and produce
	prototypes in a timely manner. Pair programming appeared to work
	effectively and offer value; however, it is not always practically
	feasible.},
  owner = {Katia},
  references = {Extreme Programming: A Survey of Empirical Data from a Controlled
	Case Study

	Action Science--Concepts, Methods and Skills for Research and Intervention

	Are agile methods good for design?

	The Practical Guide to Extreme Programming

	Extreme programming applied: playing to win

	Investigating information systems with action research

	Embracing Change with Extreme Programming

	Extreme programming explained: embrace change

	Manifesto for agile software development

	Value-Based Software Engineering

	A Spiral Model of Software Development and Enhancement

	Get Ready for Agile Methods, with Care

	Value-based software engineering: reinventing

	How Extreme Does Extreme Programming Have to Be?

	Systems Thinking

	Agile software development

	Agile Software Development: The People Factor

	The costs and benefits of pair programming

	Recognizing and responding to "bad smells" in extreme programming

	Matching methodology to problem domain

	Integrating Collaborative Processes and Quality Assurance Techniques:
	Experiences from Requirements Negotiation

	Agile processes for small public projects and PD outside of office
	hours

	A Unified Model of Requirements Elicitation

	Agile Software Development: The Business of Innovation

	A Dynamic Framework for Classifying Information Systems Development
	Methodologies and Approaches

	eXtreme testing

	Introducing eXtreme programming--An experience report

	Using Extreme Programming in a capstone project

	Pair programming: An alternative to reviews and inspections?

	How Software Engineers Use Documentation: The State of the Practice

	Developing Complex Projects Using XP with Extensions

	eXtreme Programming Development through Dialog

	Agile Software Development: Principles, Patterns, and Practices

	Five lessons from transitioning to eXtreme programming

	On the economic evaluation of XP projects

	Qualitative research in information systems

	Analyzing the Cost and Benefit of Pair Programming

	Extreme Maintenance

	An empirical test of the contingency approach to user participation
	in information systems development

	Introduction to Object-Oriented Systems Analysis and Design with Uml
	and the Unified Process

	Agile Software Development with Scrum

	Continuous Design

	What we can learn from extreme programming

	Software Engineering

	The CHAOS report into project failure

	The irony of eXtreme programming

	People factors in software management: Lessons from comparing agile
	and plan-driven methods

	Assuring homeland security: Continuous monitoring, control and assurance
	of emergency preparedness

	Key issues in information systems management: an international perspective

	Action Research for Change and Development},
  timestamp = {2010.06.22}
}

@ARTICLE{E[56],
    inserir = {false},
  author = {H. Gallis},
  title = {Collaboration on software tasks},
  year = {2003},
  abstract = {In pair programming (PP), two developers work together on the same
	task using one computer and keyboard. PP involves not just coding,
	but many phases of the software development process such as design
	and testing. PP has been proposed by several authors since the 70's,
	but it is primarily during the last three to four years that some
	of the claimed benefits have been tested empirically.},
  owner = {Katia},
  references = {The effects of pair-programming on performance in an introductory
	programming course

	Strengthening the Case for Pair Programming

	Case study: extreme programming in a university environment

	Experimental Evaluation of Pair Programming

	The costs and benefits of pair programming

	Rapid software development through team collocation

	Pair Programming on the C3 Project

	Albert Einstein and Empirical Software Engineering

	Faster, Better, and Cheaper},
  timestamp = {2010.06.22}
}

@ARTICLE{E[57],
    inserir = {false},
  author = {H. Gallis and E. Arisholm and T. Dyba},
  title = {An Initial Framework for Research on Pair Programming},
  year = {2003},
  abstract = {In recent years, several claims have been put forward in favour of
	pair programming, as opposed to individual programming. However,
	results from existing studies on pair programming contain apparent
	contradictions. The differences in the context in which the studies
	were conducted may be one explanation for such results. The paper
	presents an initial framework for research on pair programming. The
	aim is to support empirical studies and meta-analysis for developing
	theories about pair programming. The framework is based on: (1) existing
	studies on pair programming, (2) ongoing studies by the authors,
	and (3) theories from group dynamics.},
  owner = {Katia},
  references = {(not available): http://www.computer.org/portal/web/csdl/doi/10.1109/ISESE.2003.1237972

	(not available): An Initial Framework for Research on Pair Programming

	(not available): An Initial Framework for Research on Pair Programming

	(not available): An Initial Framework for Research on Pair Programming

	(not available): An Initial Framework for Research on Pair Programming

	(not available): An Initial Framework for Research on Pair Programming

	(not available): An Initial Framework for Research on Pair Programming

	(not available): An Initial Framework for Research on Pair Programming

	(not available): An Initial Framework for Research on Pair Programming

	(not available): An Initial Framework for Research on Pair Programming

	(not available): An Initial Framework for Research on Pair Programming},
  timestamp = {2010.06.22}
}

@ARTICLE{E[59],
    inserir = {false},
  author = {E. F. Gehringer},
  title = {Is pair programming an effective way to learn computer architecture?},
  year = {2003},
  abstract = {Pair programming is a concept where two programmers work side by side
	at the same computer, writing code jointly. One of them, called the
	driver, is in control of the keyboard and mouse. The other, called
	the navigator, observes what the driver is doing and offers advice.
	It is the driver's job to write the code. The navigator has a chance
	to observe the larger picture, evaluating the driver's code for correctness
	of design and implementation. Studies have shown that pair programming
	is very effective. Two programmers can finish a task in little over
	half the elapsed time that a single programmer takes. And the quality
	of the code - measured in terms of absence of defects - is much higher.
	In the past few years, pair programming has made inroads into industry
	and into programming courses. However, it has not typically been
	used in courses that teach subjects other than programming or software
	engineering, nor has it been used in the analysis of experimental
	results. This paper reports on an experiment in a combined senior/masters
	level computer architecture class, using Hennessy & Patterson's Computer
	Architecture: A Quantitative Approach as a text. Students were required
	to implement three projects simulating various aspects of a microarchitecture
	(cache, branch predictor, dynamic instruction scheduler). Then they
	engaged in an experimental analysis to find the best configuration
	in a design space. They were encouraged to pair-program, and data
	were gathered on their experience.},
  owner = {Katia},
  references = {Pair programming

	The Collaborative Software Process PhD Dissertation

	The case for collaborative programming

	Pair Programming Illuminated

	Strengthening the case for pair-programming

	The costs and benefits of pair programming

	The effects of pair programming on performance in an introductory
	programming course

	The impact of pair programming on student performance and pursuit
	of computer science-related majors

	Exploring the efficacy of distributed pair programming

	Exploring pair programming in distributed object-oriented team projects},
  timestamp = {2010.06.22}
}

@ARTICLE{I[20],
    inserir = {true},
  author = {E. F. Gehringer},
  title = {A Pair-Programming experiment in a Non-Programming courses},
  year = {2003},
  abstract = {Pair programming is a concept where two programmers work side by side
	at the same computer, writing code jointly. One of them, called the
	driver, is in control of the keyboard and mouse. The other, called
	the navigator, observes what the driver is doing and offers advice.
	It is the driver’s job to write the code. The navigator has a chance
	to observe the larger picture, evaluating the driver’s code for correctness
	of design and implementation. Studies have shown that pair programming
	is very effective. Two programmers can finish a task in little over
	half the elapsed time that a single programmer takes. And the quality
	of the code measured in terms of absence of defects—is much higher.
	In the past few years, pair programming has made inroads into industry
	and into programming courses. However, it has not typically been
	used in courses that teach subjects other than programming or software
	engineering, nor has it been used in the analysis of experimental
	results. This paper reports on an experiment in a combined senior/masters-level
	computer architecture class, using Hennessy & Patterson’s Computer
	Architecture: A Quantitative Approach as a text. Students were required
	to implement three projects simulating various aspects of a microarchitecture
	(cache, branch predictor, dynamic instruction scheduler). Then they
	engaged in an experimental analysis to find the best configuration
	in a design space. Students reported high levels of satisfaction
	with the experience of pair programming. Pair programmers obtained
	significantly higher grades on Project 1; however, differences on
	the other projects were not statistically significant.},
  owner = {Katia},
  references = {Pair programming

	The Collaborative Software Process PhD Dissertation

	The case for collaborative programming

	Pair Programming Illuminated

	Strengthening the case for pair-programming

	The costs and benefits of pair programming

	The effects of pair programming on performance in an introductory
	programming course

	The impact of pair programming on student performance and pursuit
	of computer science-related majors

	Exploring the efficacy of distributed pair programming

	Exploring pair programming in distributed object-oriented team projects},
  timestamp = {2010.06.22}
}

@ARTICLE{E[60],
    inserir = {false},
  author = {E. F. Gehringer and K. Deibel and K. J. Whittington},
  title = {Panel: cooperative learning - beyond pair programming and team projects},
  year = {2006},
  abstract = {In traditional college teaching, most class time is spent with the
	instructor lecturing and students passively listening and taking
	notes. Homework is done individually, and collaboration is penalized
	as cheating. Instructor-centric teaching methods have repeatedly
	been found inferior to cooperative learning, in which students work
	in teams on problems and projects that foster interdependence while
	maintaining individual accountability. In recent years, the CS education
	community has enthusiastically embraced two collaborative-learning
	practices: pair programming and team projects. But why stop there?
	Classroom time can be devoted to group exercises, and homework assignments
	can be arranged so that each student plays a role in educating other
	members of the class. Cooperative learning has been shown to increase
	retention and boost the performance of at-risk students. This panel
	presents cooperative-learning exercises that can be used in any class,
	without special hardware or proprietary software.},
  owner = {Katia},
  references = {An Introduction to Object-Oriented Design and Design Patterns Using
	Java

	Team formation methods for increasing interaction during in-class
	group work

	Effects of small-group learning on undergraduates in science,mathematics,
	engineering, and technology

	Cooperative Learning for Higher Education Faculty

	Implementation of Alternative Pacing in an Introductory Programming
	Sequence

	Infusing Active Learning Into Introductory Programming Courses

	The contributing student: A blend of pedagogy and technology

	Forms of Intellectual and Ethical Development in the College Years:
	A Scheme},
  timestamp = {2010.06.22}
}

@ARTICLE{E[61],
    inserir = {false},
  author = {B. George and L. Williams},
  title = {A structured experiment of test-driven development},
  year = {2004},
  abstract = {Test Driven Development (TDD) is a software development practice in
	which unit test cases are incrementally written prior to code implementation.
	We ran a set of structured experiments with 24 professional pair
	programmers. One group developed a small Java program using TDD while
	the other (control group), used a waterfall-like approach. Experimental
	results, subject to external validity concerns, tend to indicate
	that TDD programmers produce higher quality code because they passed
	18% more functional black-box test cases. However, the TDD programmers
	took 16% more time. Statistical analysis of the results showed that
	a moderate statistical correlation existed between time spent and
	the resulting quality. Lastly, the programmers in the control group
	often did not write the required automated test cases after completing
	their code. Hence it could be perceived that waterfall-like approaches
	do not encourage adequate testing. This intuitive observation supports
	the perception that TDD has the potential for increasing the level
	of unit testing in the software industry.},
  owner = {Katia},
  references = {Extreme Programming Explained: Embrace Change

	Test Driven Development: By Example

	Aim, fire

	The Mythical Man-Month

	Experimental and Quasi-experimental Design for Research

	Test first programming

	Program understanding challenge for the 1990s

	Big ball of mud

	Software quality engineering

	Analysis and quantification of test driven development approach

	The Engineering of Software

	Managing the Software Process

	A history of iterative and incremental development

	Program Evolution: Processes of Software Change

	Agile Software Development: Principles, Patterns and Practices

	Assessing test-driven development at IBM

	Experiment about test-first programming

	Foundations for the study of software architecture

	Managing the development of large software systems: concepts and techniques

	Program comprehension risks and opportunities in Extreme Programming

	Refactoring test code

	Test-driven development as a defect-reduction practice

	The Collaborative Software Process},
  timestamp = {2010.06.22}
}

@ARTICLE{E[62],
    inserir = {false},
  author = {E. Germain and P. N. Robillard},
  title = {Engineering-based processes and agile methodologies for software
	development: a comparative case study},
  year = {2005},
  abstract = {The emergence of various software development methodologies raises
	the need to evaluate and compare their efficiencies. One way of performing
	such a comparison is to have different teams apply different process
	models in the implementation of multiple versions of common specifications.
	This study defines a new cognitive activity classification scheme
	which has been used to record the effort expended by six student
	teams producing parallel implementations of the same software requirements
	specifications. Three of the teams used a process based on the Unified
	Process for Education (UPEDU), a teaching-oriented process derived
	from the Rational Unified Process. The other three teams used a process
	built around the principles of the Extreme Programming (XP) methodology.
	Important variations in effort at the cognitive activity level between
	teams shows that the classification could scarcely be used without
	categorization at a higher level. However, the relative importance
	of a category of activities aimed at defining "active" behaviour
	was shown to be almost constant for all teams involved, possibly
	showing a fundamental behaviour pattern. As secondary observations,
	aggregate variations by process model tend to be small and limited
	to a few activities, and coding-related activities dominate the effort
	distribution for all the teams.},
  owner = {Katia},
  references = {Successful software projects need requirements planning

	Embracing change with Extreme Programming

	Extreme Programming Explained: Embrace Change

	Agility through discipline: a debate

	Teaching an object-oriented software development lifecycle in undergraduate
	software engineering education

	The Mythical Man-Month: Essays on Software Engineering

	Agile Software Development

	The costs and benefits of pair programming

	Software engineering process

	Measuring software process activities in student settings

	Process activities in a project based course in software engineering

	Teaching the Unified Process to undergraduate students

	Adaptive Software Development: a Collaborative Approach to Managing
	Complex Systems

	Agile Software Development Ecosystems

	Introducing Empirical Software Engineering Methods in Education

	Extreme Programming Installed

	The Rational Unified Process: An Introduction

	I Know What I Know

	A Practical Guide to Feature-Driven Development

	Software Engineering: a Practioner's Approach

	The Scrum software development process for small teams

	Teaching software engineering through a project-oriented course

	Measuring team activities in a process-oriented software engineering
	course

	YOOPEEDOO (UPEDU): a process for teaching software process

	Software Engineering Process with the UPEDU

	Dynamic Systems Development Method: the Method in Practice

	Software Process as a Foundation for Teaching

	Don't solve a problem before you get to it

	In Support of Student Pair-Programming},
  timestamp = {2010.06.22}
}

@ARTICLE{I[74],
    inserir = {true},
  author = {H. Gevaert},
  title = {Pair programming unearthed},
  year = {2007},
  abstract = {Extreme Programming (XP) is an emerging development methodology. To
	get a better understanding of XP, the practices which constitute
	this process need to be critically analyzed. In particular, the practice
	of pair programming is analyzed as it is both an interesting practice
	and one that provides a large area of research. The goal of this
	thesis, therefore, is to analyze pair programming in an effort to
	determine how this practice relates to solo (traditional) programming,
	the personality characteristics of the developers and the XP practice
	of refactoring. By undertaking a thorough examination of pair programming,
	a deeper understanding of this important XP practice can be gained
	and a deeper understanding of XP can also be gained. To accomplish
	this goal, two experiments were designed and implemented using fourth
	year computer science students at the University of Manitoba. The
	first experiment compared solo programming with pair programming
	while using personality characteristics, as determined by Eysenck
	Personality Questionnaire (EPQ-R), as factors. The second experiment
	compared solo programming and pair programming in terms of what kind
	of refactorings the subjects carried out while working individually
	as opposed to in pairs.re (EPQ-R), as factors. The second experiment
	compared solo programming and pair programming in terms of what kind
	of refactorings the subjects carried out while working individually
	as opposed to in pairs. These experiments were designed in an attempt
	to confirm or deny five hypotheses. These hypotheses are as follows:
	(1) H1: (H1null) Pair programmers are not more efficient at software
	development than solo programmers. (H1a) Pair programmers are more
	efficient at software development than solo programmers. (2) H2:
	(H2null) Personality characteristics play no role in how efficiently
	an individual develops code when working in a pair programming situation.
	(H2a) Personality characteristics do play a role in how efficiently
	an individual develops code when working in a pair programming situation.
	(3) H3: (H3null) The individual efficiency of each partner in a pairing
	has no effect on how well the two individuals pair program. (H3a)
	Pair programming efficiency can be seen as a function of the solo
	programming efficiency of each of the individuals in the pairing.
	(4) H4: (H4null) Individuals and pairs undertake refactorings at
	the same difficulty level. (H4a) Pair programmers undertake refactorings
	at higher difficulty levels than individuals. (5) H5: (H5null) Pair
	programming satisfaction is unrelated to the personality characteristics
	and software development skill levels of the developers. (H5a) Pair
	programming satisfaction is linked to the personality characteristics
	of developers and their software development skill level. The findings
	were such that the null hypothesis was demonstrated for H1 and H2,
	although some interesting statistics were still recorded. In particular,
	it is thought that with a larger sample size, the alternate H2 could
	be shown to be true. H1 yielded data which could suggest that pairs
	develop higher quality code while individuals develop code more quickly.
	In both cases, however, no statistically significant correlations
	were found. For H3 and H5, the alternate hypotheses were adopted.
	In the case of H3, the higher the individual ability of the subjects,
	the higher the pair programming efficiency. For H5, it was clear
	that the more extroverted an individual tends to be, the more satisfied
	that individual tends to be with the pair programming experience.
	The data for H3 was a little harder to analyze. While there was no
	statistical difference in the difficulty levels of refactorings individuals
	chose as opposed to pairs, there was a negative correlation in that
	a subject who undertook difficult refactorings individually would
	undertake less difficult refactorings when paired and vice versa.
	In general, I believe this thesis was successful in broadening and
	deepening our understanding of the pair programming practice as the
	experiments yielded a l rge amount of interesting data in how the
	practice of pair programming relates to solo programming, personality
	characteristics, and refactoring.},
  owner = {Katia},
  references = {Software Project Dynamics: An Integrated Approach

	Manifesto for Agile Software Development

	Technical and human perspectives on pair programming

	A framework for understanding the factors influencing pair programming
	success

	An empirical study of relationships among extreme programming engineering
	activities

	Effective Practices for eXtremme Programming and the Unified Process

	Test-Driven Development: A Practical Guide

	Extreme Programming Applied: Playing to Win

	Embracing change with extreme programming

	Extrame Programming Explained: Embrace Change

	Agility through discipline: A debate

	Working in pairs as a means for design knowledge building: an empirical
	study

	The agile methods fray

	Extreme programming: It´s worth a look

	The economics of software development by pair programmers

	Manual of the Eysenck Personality Questionnaire

	Industrial dynamics: A major breakthrough for decision makers

	Refactoring: Improving the design of existing code

	An initial framework for research on pair programming

	A structered experiment of test-driven development

	Personality and type considerations for programming teams in computer
	science classes

	Qualitative studies of xp in a medium sized business

	Extreme programming: A more musical approach to software development?

	Extreme programming and its development practices

	System Dynamics Modelling for the Management of Long Term Software
	Evolution Processes

	A quantitative evaluation of maintainability enhancement by refactoring

	On understanding compatibility of student pair programmers

	The effects of individual xp practices on software development effort

	Exploring extreme programming in context: An industrial case study

	Junit: Unit testing and coding in tandem

	When does a pair outperform two individuals?

	Less extreme programming

	Analyzing the cost and benefit of pair programming

	Modeling the impact of a learning phase on the business value of a
	pair programming project

	A field study of developer pairs: productivity impacts and implications

	Time in system dynamics

	Integration of system dynamics modelling with descriptive process
	modelling and goal-oriented measurement

	A note on the quantification of computer programming skill

	Qunatitative assessment of extreme programming practices

	Code warriors and code-a-phobes: A study in attitude and pair programming

	A comparison of pair programming to inspections for software defect
	reduction

	Coupling pair programming and writing: Learning about student´s perceptions
	and processes

	Extreme Programming Explored

	Refactoring Workbook

	The impact of using pair programming on system evolution: a simulation-based
	study

	Building pair programming knowledge through a family of experiments

	An initial exploration of the relationship between pair programming
	and Brook´s law

	Pair Programming Illuminated

	Strengthening the case for pair programming

	Experiments with industry´s pair programming model in the computer
	science classroom},
  timestamp = {2010.06.22}
}

@ARTICLE{E[63],
    inserir = {false},
  author = {C. Ghezzi and M. Monga},
  title = {"Extreme programming" - extreme programming or extreme revisionism?},
  year = {2002},
  abstract = {Outlines the software programming problems considered in the relevant
	April 1987 IEEE paper. Details the fundamental activities of extended
	programming to cope with them: code writing; testing; listening to/observing
	the market; and the actual process of design.. Breaks down the basic
	steps of the XP process and emphasises the novel and important aspect
	of pair programming. Compares the cost/time curves, the programming
	time, the error rate and number of instructions required in pair-programming
	as opposed to single-programming. Suggests that the XP process may
	fail to provide the software 'silver bullet' because of its inability
	to take account of individual requirements.},
  owner = {Katia},
  references = {(not founded): "Extreme programming" - extreme programming or extreme
	revisionism?

	(not founded): "Extreme programming" - extreme programming or extreme
	revisionism?

	(not founded): "Extreme programming" - extreme programming or extreme
	revisionism?

	(not founded): "Extreme programming" - extreme programming or extreme
	revisionism?

	(not founded): "Extreme programming" - extreme programming or extreme
	revisionism?

	(not founded): "Extreme programming" - extreme programming or extreme
	revisionism?

	(not founded): "Extreme programming" - extreme programming or extreme
	revisionism?

	(not founded): "Extreme programming" - extreme programming or extreme
	revisionism?

	(not founded): "Extreme programming" - extreme programming or extreme
	revisionism?

	(not founded): "Extreme programming" - extreme programming or extreme
	revisionism?},
  timestamp = {2010.06.21}
}

@ARTICLE{I[71],
    inserir = {true},
  author = {B. Hanks},
  title = {Problems encountered by novice pair programmers},
  year = {2007},
  abstract = {In a study of the types of problems encountered by students that led
	them to seek assistance, Robins et al. [2006] found that the most
	common problems were related to trivial mechanics. The students in
	this study worked by themselves on their programming exercises. This
	article discusses a replication of the Robins et al. study in which
	the subjects pair programmed. The types of problems encountered by
	the pairing students were similar to those of the solo students.
	The number of problems requiring assistance was much smaller for
	the pairing students, which suggests that they were able to resolve
	more problems on their own.},
  owner = {Katia},
  references = {My program is correct but it doesn't run: a preliminary investigation
	of novice programmers' problems

	Program quality with pair programming in CS1

	A multi-national study of reading and tracing skills in novice programmers

	Research perspectives on the objects-early debate, Working group reports
	on ITiCSE on Innovation and technology in computer science education

	A multi-national, multi-institutional study of assessment of programming
	skills of first-year CS students

	Pair programming improves student retention, confidence, and program
	quality

	Improving the CS1 experience with pair programming

	Problem distributions in a CS1 course

	Studying the Novice Programmer},
  timestamp = {2010.06.23}
}

@ARTICLE{I[22],
    inserir = {true},
  author = {B. Hanks},
  title = {Student attitudes toward pair programming},
  year = {2006},
  abstract = {Students in four introductory programming classes who participated
	in a pair programming study had very positive attitudes toward pair
	programming: they liked it, thought that it was fun, would like to
	do it again, and believed that they learned more because they paired.
	Although the students as a whole had positive attitudes, the results
	were not consistent between instructors; in particular, the students
	in one of the courses were significantly less positive about pair
	programming. The implications of instructor-based differences in
	attitude are discussed. This paper also examines the relationship
	between student confidence and attitudes toward pair programming.
	The most confident students liked pairing the most, while the least
	confident students liked it the least. This finding contradicts results
	that have been reported elsewhere.},
  owner = {Katia},
  references = {Introductory Statistics with R. Springer

	Distributed pair programming: An empirical study

	Empirical Studies of Distributed Pair Programming

	Student performance in CS1 with distributed pair programming

	Program quality with pair programming in CS1

	Unlocking the Clubhouse: Women in Computing

	Experimenting with pair programming in the classroom

	The impact of pair programming on student performance, perception
	and persistence

	Perceptions of agile practices: A student survey

	A language and environment for statistical computing

	Nonparametric Statistics for the Behavioral Sciences

	Code warriors and code-a-phobes: A study in attitude and pair programming

	Pair programming helps female computer science students persist

	Pair Programming Illuminated

	Strengthening the case for pair programming},
  timestamp = {2010.06.22}
}

@ARTICLE{E[64],
    inserir = {false},
  author = {B. Hanks},
  title = {Student performance in CS1 with distributed pair programming},
  year = {2005},
  abstract = {Pair programming has been shown to provide many pedagogical benefits,
	particularly for students who are learning to program. One drawback
	with pair programming is its collocation requirement, which makes
	it difficult for some students to enjoy these benefits. We report
	on an experiment with a tool that allows students to pair program
	from separate locations. Our results indicate that students who experience
	the increased flexibility of distributed pairing perform as well
	in their introductory programming course as students who have to
	physically meet in order to pair. These students are also as confident
	as the collocated students. We also confirm earlier results reported
	by others that pair programming results in greater student confidence
	and increased student performance.},
  owner = {Katia},
  references = {The costs and benefits of pair programming

	Distributed Pair Programming on the Web

	Program quality with pair programming in CS1

	The effects of pair-programming on performance in an introductory
	programming course

	Experimenting with pair programming in the classroom

	The impact of pair programming on student performance, perception
	and persistence

	Perceptions of Agile Practices: A Student Survey

	The case for collaborative programming]

	Virtual Network Computing

	Virtual teaming: Experiments and experiences with distributed pair
	programming

	Pair-programming helps female computer science students

	Pair Programming Illuminated

	Strengthening the Case for Pair Programming},
  timestamp = {2010.06.22}
}

@ARTICLE{E[65],
    inserir = {false},
  author = {B. Hanks},
  title = {Distributed pair programming: an empirical study},
  year = {2004},
  abstract = {Pair programming provides many benefits, both to the programmers and
	to the product that they develop. However, pair programming is limited
	to those situations in which the developers can collocate, preventing
	its benefits from being enjoyed by the widest possible audience.
	A software tool that allowed the pair to work from separate locations
	would address this limitation. This paper presents some initial results
	from a distributed pair programming experiment in which students
	in an introductory programming class used such a tool. Student perceptions
	of distributed pair programming are also discussed.},
  owner = {Katia},
  references = {Pair Programming Illuminated

	The costs and benefits of pair programming

	Strengthening the case for pair programming

	The impact of pair programming on student performance, perception
	and persistence

	The case for collaborative programming

	Experimenting with pair programming in the classroom

	Program quality with pair programming in CS1

	The (currently) unique advantages of collocated work

	Support for distributed teams in extreme programming

	Supporting distributed extreme programming

	Exploring the efficacy of distributed pair programming

	Lessons learned about distributed pair programming: What are the knowledge
	needs to address?

	Virtual teaming: Experiments and experiences with distributed pair
	programming

	Virtual network computing

	Sharing views and interactions with single-user applications

	Gesturing through cursors: Implementing multiple pointers in group
	support systems

	Semantic telepointers for groupware

	Trust breaks down in electronic contexts but can be repaired by some
	initial face-to-face contact},
  timestamp = {2010.06.22}
}

@ARTICLE{I[21],
    inserir = {true},
  author = {B. Hanks and C. McDowell and D. Draper and M. Krnjajic},
  title = {Program quality with pair programming in CS1},
  year = {2004},
  abstract = {Prior research on pair programming has found that compared to students
	who work alone, students who pair have shown increased confidence
	in their work, greater success in CSl, and greater retention in computer-related
	majors. In these earlier studies, pairing and solo students were
	not given the same programming assignments. This paper reports on
	a study in which this factor was controlled by giving the same programming
	assignments to pairing and solo students. We found that pairing students
	were more likely to turn in working programs, and these programs
	correctly implemented more required features. Our findings were mixed
	when we looked at some standard complexity measures of programs.
	An unexpected but significant finding was that pairing students were
	more likely to submit solutions to their programming assignments.},
  owner = {Katia},
  references = {The costs and benefits of pair programming

	Bayesian Data Analysis

	JavaNCSS - a source measurement suite for Java

	A complexity measure

	Experimenting with pair programming in the classroom

	The impact of pair programming on student performance, perception
	and persistence

	Pair learning: With an eye toward future success

	Pair Programming Illuminated

	The Collaborative Software Process},
  timestamp = {2010.06.22}
}

@ARTICLE{E[66],
    inserir = {false},
  author = {J. Haungs},
  title = {Pair programming on the C3 project},
  year = {2001},
  abstract = {Chrysler's Comprehensive Compensation (C3) project was one of the
	first large-scale IT projects on which Extreme Programming (XP) precepts
	were attempted. As XP was being invented, we didn't really think
	of it as a theoretical or methodological breakthrough; it was simply
	an opportunity to get the job done. The "theory" came about later
	because of the practice's success. In my opinion, XP is not a theory,
	but a cogent descriptive body of successful praxis. Some people consider
	pair programming, an XP technique, to be difficult, unworkable, or
	downright weird. After all, what does the workstation represent,
	if not finally having your own computer? The idea of sharing your
	machine with someone seems like a lot of bother without much reward.
	How can you talk if you're trying to think? And how can you think
	if you first have to explain what you're thinking about? Having participated
	on the C3 project as a performance-tuning consultant beginning in
	1996, I can attest to the success of pair programming. At the same
	time, I can show instances where it did not work or was not emphasized
	in this early XP project. In a sense, this pragmatism is the strength
	of XP: Use a technique where it works, ignore it where it doesn't.
	XP has never been prescribed as a panacea. XP's pair programming
	helps programmers synthesize their individual expertise into an effective
	combination.},
  owner = {Katia},
  references = {no references: Pair programming on the C3 project},
  timestamp = {2010.06.21}
}

@ARTICLE{E[67],
    inserir = {false},
  author = {O. Hazzan},
  title = {The reflective practitioner perspective in software engineering education},
  year = {2002},
  abstract = {This paper focuses on the application of the reflective practitioner
	(RP) perspective to the profession of software engineering (SE).
	The RP perspective guides professional people to rethink their professional
	creations during and after the accomplishment of the creation process.
	Analysis of the field of SE supports the adoption of the RP perspective
	to SE in general and to SE education in particular. The RP perspective
	emphasizes the studio––the basic training method in architecture
	schools––as the educational environment for design studies. In such
	studios students develop projects with a close guidance of a tutor.
	Analysis of the kind of tasks that architecture students are working
	on and a comparison of these tasks to the problems that SE students
	are facing, suggest that the studio may be an appropriate teaching
	method in SE as well. The paper presents the main ideas of the RP
	perspective and examines its fitness to SE in general and to SE education
	in particular. The discussion is based on analysis of the RP perspective
	and of the SE profession, visits to architecture studios, and conversations
	with tutors in architecture studios and with computing science practitioners.},
  owner = {Katia},
  references = {Rethinking the education of architects: emotional phenomena in the
	student-instructor relationship

	Developing software as a human, social and organizational activity

	Quantitative evaluation of software quality

	Declaration by design: rhetoric, argument, and demonstration in design
	practice

	Curriculum guidelines for undergraduate programs in computing

	Social processes and proofs of theorems and programs

	ducating a new engineer

	On a cultural gap

	An innovative design and studio-based CS degree

	Outline of a paradigm change in software engineering

	Revisiting the industry/academe communication chasm

	Computer programs and mathematical proofs

	The Engineering of Software

	Teaching the human aspect of software engineering - a case study

	Mathematics of programming

	A Discipline for Software Engineering

	The Art of Computer Programming Volumes 1-3 Boxed Set

	Computer science and its relation to mathematics

	The Software Design Studio: An Exploration

	Priorities for the education and training of software engineers

	Abstraction and specification in program development

	Constructive mathematics and computer programming

	Software Design: Methods and Techniques

	The Reflective Practitioner

	Educating the Reflective Practitioner: Towards a New Design for Teaching
	and Learning in The Profession

	Reflective conversation with materials

	Software psychology: Human factors in computer and information systems
	(Winthrop computer systems series)

	Towards a definition of software design

	Software Engineering

	Teaching software development in a studio environment

	Software Development Studio: A Five Year Retrospectiv

	The ACM/IEEE-CS joint curriculum task force report

	Software engineering: methods and management

	Thinking objectively: management in the small

	Communicating mathematics: useful ideas from computer science

	All I really need to know about pair programming I learned in kindergarten},
  timestamp = {2010.06.21}
}

@ARTICLE{E[68],
    inserir = {false},
  author = {G. Hedin and L. Bendix and B. Magnusson},
  title = {Teaching extreme programming to large groups of students},
  year = {2005},
  abstract = {We find the extreme programming methodology highly suitable for introducing
	undergraduate students to software engineering. To be able to apply
	this methodology at a reasonable teaching cost for large student
	groups, we have developed two courses that work in tandem: a team
	programming course taken by more than 100 students, and a coaching
	course taken by around 25 students. In this paper we describe our
	view of how extreme programming fits into the software engineering
	curriculum, our approach to teaching it, and our experiences, based
	on two years of running these courses. Particularly important aspects
	of our set up include team coaching (by older students), fixed working
	hours, and colocation during development. Our experiences so far
	are very positive, and we see that students get a good basic understanding
	of the important concepts in software engineering, rooted in their
	own practical experience.},
  owner = {Katia},
  references = {Bringing Extreme Programming to the Classroom

	Extreme programming applied: playing to win

	Software configuration management: coordination for team productivity

	Embracing Change with Extreme Programming

	Extreme programming explained: embrace change

	Test Driven Development: By Example

	JUnit Cookbook

	Summary of the subworkshop on extreme programming

	The impact of pair programming on student performance, perception
	and persistence

	Peopleware (2nd ed.): productive projects and teams

	Using metaphors in extreme programming projects

	Design Patterns: Abstraction and Reuse of Object-Oriented Design

	Introducing software engineering by means of Extreme Programming

	Coaching coaches

	Teaching XP for Real: Some Initial Observations and Plans

	Extreme Programming Installed

	Extreme programming and the software design course

	Project retrospectives: a handbook for team reviews

	The 4+1 View Model of Architecture

	Applying UML and Patterns: An Introduction to Object-Oriented Analysis
	and Design and the Unified Process

	Five challenges in teaching XP

	Case study: extreme programming in a university environment

	Some Observations of Extreme Programming for Student Projects

	En studie om parprogrammering i praktiken

	eXtreme Programming at universities: an educational perspective

	The Eclipse Java Development Tools subproject

	The Test Code Cycle in XP: Part 1

	Extreme Programming Explored

	Coaching for Performance: Growing People, Performance and Purpose

	Extreme programming for software engineering education?},
  timestamp = {2010.06.22}
}

@ARTICLE{I[23],
    inserir = {true},
  author = {S. Heiberg and U. Puus and P. Salumaa and A. Seeba},
  title = {Pair-programming effect on developers productivity},
  year = {2003},
  abstract = {This paper gives an overview of a pair programming experiment designed
	to verify how pair programming affects programmer's technical productivity.
	The experiment took place at the Institute of Computer Science, University
	of Tartu (UT), Estonia. The paper includes the problem statement,
	description of the experimental design, the experiment results, and
	a discussion about the validity of the results. During the experiment
	pair programming worked well in getting early testable programming
	results, pair programmers and nonpair programmers performed with
	similar final results.},
  owner = {Katia},
  references = {Experimental and Quasi-Experimental Designs for Research

	The Costs and Benefits of Pair Programming

	Normal Personality Assessment in Clinical Practice: The NEO Personality
	Inventory

	Statistical Inference Based on Ranks

	Experimental Evaluation of Pair Programming

	The case for collaborative programming

	Methods Toward a Science of Behavior and Experience

	All I Really Need to Know about Pair Programming I Learned in Kindergarten

	Strengthening the Case for Pair Programming

	Experimenting with Industry’s ”Pair-Programming” Model in the Computer
	Science Classroom

	The Collaborative Software Process

	The benefits of collaboration for student programmers},
  timestamp = {2010.06.22}
}

@ARTICLE{E[69],
    inserir = {false},
  author = {B. Henderson-Sellers},
  title = {Method engineering for OO systems development},
  year = {2003},
  abstract = {For the past 15 years, many proposed OO methodologies have sought
	to deliver full life-cycle support for systems development using
	OO tools. Many are highly prescriptive, that is, the methodology
	elements are highly interconnected. This inherent complexity makes
	it difficult for a methodology to be adapted to project-specific
	circumstances, especially (and usually) when project managers and
	developers are advised by the methodology's creator that they must
	use all or none of the components of the methodology. Indeed, even
	with the advent of agile methodologies, frequently touted by their
	developers as offering more people-focus and flexibility, proponents
	often say an agile methodology like extreme programming (XP) is followed
	in its entirety and that XP without, say, pair programming is not
	XP. This metamodel-based framework helps distill the key ingredients
	in software engineering processes in ways that facilitate method
	engineering, along with process understanding.},
  owner = {Katia},
  references = {Method engineering: Engineering of information systems development
	methods and tools

	Assembly Techniques for Method Engineering

	The PIE Methodology - Concept and Application

	The OPEN Process Framework

	Supporting Web Development in the OPEN Process: Additional Roles and
	Techniques

	Agile or rigorous OO methodologies: Getting the best of both worlds

	Process Metamodelling and Process Construction: Examples Using the
	OPEN Process Framework (OPF)

	Using OPEN's Deontic Matrices for E-Business

	Creating a process for transitioning to object technology

	Information Technology: Software Life-cycle Processes

	Requirements Definition for the Situational Method Engineering

	Organizational Transition to Object Technology: Theory and Practice},
  timestamp = {2010.06.22}
}

@ARTICLE{E[70],
    inserir = {false},
  author = {A. Herranz and J. J. Moreno-Navarro},
  title = {Formal extreme (and extremely formal) programming},
  year = {2003},
  abstract = {This paper is an exploratory work where the authors study how the
	technology of formal methods (FM) can interact with agile process
	in general and with extreme programming (XP) in particular. Our thesis
	is that most of XP practices (pair programming , daily build , the
	simplest design or the metaphor ) are technology independent and
	therefore can be used in FM based developments. Additionally, other
	essential pieces like test first , incremental development and refactoring
	can be improved by using FM. In the paper we explore in a certain
	detail those pieces: when you write a formal specification you are
	saying what your code must do, when you write a test you are doing
	the same so the idea is to use formal specifications as tests. Incremental
	development is quite similar to the refinement process in FM: specifications
	evolve to code maintaining previous functionality. Finally FM can
	help to remove redundancy, eliminate unused functionality and transform
	obsolete designs into new ones, and this is refactoring.},
  owner = {Katia},
  references = {Extreme Programming Explained: Embrace Change

	Relevance, intergration and classification of specification formalism
	and formal specification techniques

	Refactoring: Improving the Design of Existing Code

	Design Patterns-Elements of Reusable Object Oriented Software

	Declarative reflection and its application as a pattern language

	Generation of and debugging with logical pre and post conditions

	On the design of an object-oriented formal notation

	Systematic Software Development Using VDM

	The Z Notation: A Reference Manual

	Software Development with Z},
  timestamp = {2010.06.22}
}

@ARTICLE{E[71],
    inserir = {false},
  author = {T. J. Hickey},
  title = {Enhancing CS Programming Lab Courses Using Collaborative Editors},
  year = {2004},
  abstract = {This paper describes the pedagogical implications of the GREWPtool
	(the Groupware Research in Education and the Workforce Project),
	a same time different place groupware tool built to support synchronous,
	collaborative coding among small to medium sized groups. GREWPtool
	exploits the educational benefits of paired programming while extending
	the model to allow students synchronous control of the same code.
	This effectively drops the constraints of turn taking, and allows
	for a richer interaction. The result was a powerful tool that can
	be used to provide interactive lectures, structure classroom activity,
	and facilitate paired programming during labs. In this paper we present
	the design and use of GREWPtool with an emphasis on how it enhances
	the classroom experience. In particular, we give a qualitative analysis
	of how this tool has been used in six lab courses over the past two
	years.},
  owner = {Katia},
  references = {Pair programming and pair trading: effects on learning and motivation
	in a CS2 course

	Concurrency control in groupware systems

	Elastic Windows: evaluation of multi-window operations

	Analysis Techniques for Modeling Group Interaction

	Incorporating Scheme-based Web Programming into Computer Literacy
	Courses

	Groupware

	Tool support for collaborative teaching and learning of object-oriented
	modeling

	Analyzing Usage of Groupware

	Building Groupware On THYME

	Analyzing Usage of Groupware

	Integrating tools and resources: a case study in building educational
	groupware for collaborative programming

	Use of Virtual Science Park resource rooms to support group work in
	a learning environment

	The effects of pair-programming on performance in an introductory
	programming course

	Experimenting with pair programming in the classroom

	Learning to write together using groupware

	Improving the CS1 experience with pair programming

	Issues in the design of computer support for co-authoring and commenting

	The case for collaborative programming

	High-latency, low-bandwidth windowing in the Jupiter collaboration
	system

	eTutorials with voice groupware: real-time conferencing to support
	computing students at a distance

	Towards an integrated learning laboratory environment for first-year
	computer science students

	WYSIWIS revised: early experiences with multiuser interfaces

	Achieving convergence, causality preservation, and intention preservation
	in real-time cooperative editing systems

	GREWPTool: A System for Studying Online Collaborative Learning

	Experimenting with Industry's 'Pair-Programming' Model in the Computer
	Science Classroom

	In support of student pair-programming

	Constructive and collaborative learning of algorithms

	NetEdit: a Collaborative Editor

	Lecture recording and its use in a traditional university course},
  timestamp = {2010.06.22}
}

@ARTICLE{E[72],
    inserir = {false},
  author = {K. Hiranabe},
  title = {XP(Extreme Programming): Software Development Process Nouvelle Vague.
	Part I: Overview of XP and its Surroudings},
  year = {2002},
  abstract = {The following topics are discussed: Extreme Programming; a planning
	game; pair programming; the software life-cycle; daily schema migration;
	and object-oriented programming.},
  owner = {Katia},
  references = {(not available): XP(Extreme Programming): http://sciencelinks.jp/j-east/article/200213/000020021302A0317167.php

	(not available): XP(Extreme Programming): Software Development Process
	Nouvelle Vague. Part I: Overview of XP and its Surroudings

	(not available): XP(Extreme Programming): Software Development Process
	Nouvelle Vague. Part I: Overview of XP and its Surroudings

	(not available): XP(Extreme Programming): Software Development Process
	Nouvelle Vague. Part I: Overview of XP and its Surroudings

	(not available): XP(Extreme Programming): Software Development Process
	Nouvelle Vague. Part I: Overview of XP and its Surroudings

	(not available): XP(Extreme Programming): Software Development Process
	Nouvelle Vague. Part I: Overview of XP and its Surroudings

	(not available): XP(Extreme Programming): Software Development Process
	Nouvelle Vague. Part I: Overview of XP and its Surroudings

	(not available): XP(Extreme Programming): Software Development Process
	Nouvelle Vague. Part I: Overview of XP and its Surroudings

	(not available): XP(Extreme Programming): Software Development Process
	Nouvelle Vague. Part I: Overview of XP and its Surroudings

	(not available): XP(Extreme Programming): Software Development Process
	Nouvelle Vague. Part I: Overview of XP and its Surroudings

	(not available): XP(Extreme Programming): Software Development Process
	Nouvelle Vague. Part I: Overview of XP and its Surroudings},
  timestamp = {2010.06.21}
}

@ARTICLE{I[24],
    inserir = {true},
  author = {C. Ho},
  title = {Examining Impact of Pair Programming on Female Students},
  year = {2004},
  abstract = {There has been low representation of women in Computer Science. Numerous
	studies have been conducted to identify the cause of this under-representation
	and to provide suggestions to improve the situation. Still not much
	progress in attracting women to computer science has been observed.
	The research discussed in this paper was done during the pilot study
	phase of a three-year project about women in information

	technology field. During the first semester of this project, pair
	programming was used in a junior/senior Software Engineering class
	at North Carolina State University. The goal of this research is
	to examine the effect of pair programming on female students. We
	interviewed three female students and analyzed all female students’
	project retrospective reports. Theoretical models were developed
	to describe (a) the source of project

	enjoyment, (b) context that influenced female students’ study habits,
	and (c) the effectiveness of pair programming. The cause and effect
	of each component of the theoretical models were identified and are
	illustrated with narrative data.},
  owner = {Katia},
  references = {Exploring the Efficacy of Distributed Pair Programming

	Extreme Programming Explained: Embrace Change

	Collaboration through Agile Software Development Practices: Student
	Interviews and Lab Observations

	The Accuracy of Academic Gender Stereotypes

	Deterrents to Women Taking Computer Science Courses

	Gender Differences in Computer Science Students

	The Mythical Man-Month

	The Costs and Benefits of Pair Programming

	Toward Improving Female Retention in the Computer Science Major

	Must There Be So Few? Including Women in CS

	Research Design: Qualitative, Quantitative, and Mixed Methods Approaches

	Handbook of Qualitative Research

	The Discovery of Grounded Theory: Strategies for Qualitative Research

	Priming the Pipeline

	Mixing Qualitative and Quantitative Methods: Triangulation in Action

	On Understanding Compatibility of Student Pair Programmers

	Geek Mythology and Attracting Undergraduate Women to Computer Science

	Caring about Connections: Gender and Computing

	The Impact of Pair Programming on Student Performances, Perception,
	and Persistence

	Improving the CS1 Experience with Pair Programming

	Digest of Education Statistics

	Data Management and Analysis

	Student Perceptions of the Suitability of Extreme and Pair Programming

	Qualitative Methods in Empirical Studies of Software Engineering

	Basics of Qualitative Research

	Code Warriors and Code-a-Phobes: A Study in Attitude and Pair Programming

	Survey Results Show Better Balance in Supply and Demand

	Student Culture vs Group Work in Computer Science

	The effects of "pair-pressure" and "pair-learning" on software engineering
	education

	Strengthening the Case for Pair-Programming

	Pair Programming Illuminated

	Pair Programming in an Introductory Computer Science Course: Initial
	Results and Recommendations},
  timestamp = {2010.06.22}
}

@ARTICLE{E[74],
    inserir = {false},
  author = {C. Ho and S. Raha and E. Gehringer and L. Williams},
  title = {Sangam - A Distributed Pair Programming Plug-in for Eclipse},
  year = {2004},
  abstract = {In pair programming, two programmers traditionally work side-by-side
	at one computer. However, in globally distributed organizations,
	long-distance collaboration is frequently necessary. Sangam is an
	Eclipse plug-in that allows Eclipse users in different locations
	to share a workspace so that they may work as if they were using
	the same computer. In this paper, we discuss the Sangam plug-in,
	and our experience developing it via distributed and collocated pair
	programming.},
  owner = {Katia},
  references = {Exploring the Efficacy of Distributed Pair Programming

	Extreme programming explained: embrace change

	The costs and benefits of pair programming

	Groupware: some issues and experiences

	Distance Matters

	Pair Programming Illuminated

	Strengthening the Case for Pair Programming},
  timestamp = {2010.06.22}
}

@ARTICLE{E[73],
    inserir = {false},
  author = {C. Ho and K. Slaten and L. Williams and S. Berenson},
  title = {Work in progress-unexpected student outcome from collaborative agile
	software development practices and paired programming in a software
	engineering course},
  year = {2004},
  abstract = {There has been low representation of women in computer science. This
	paper describes the initial findings of a three-year research project
	about women in the field of information technology. The goal of this
	research is to examine the effect of pair programming and agile software
	development on students. During the first semester of this project,
	pair programming was used in a junior/senior software engineering
	class at North Carolina State University. In this paper, we share
	the grounded theory analysis of three interviews and thirteen project
	retrospective essays of the female students. Theoretical models were
	developed to describe: (a) the factors of students' enjoyment in
	a software design course that employs agile software methods, (b)
	context that influenced students' study habits, and (c) the effectiveness
	of pair programming and agile methods. Initial findings indicate
	that pair programming is an effective practice for the female students,
	but it also brings new challenges for the instructors.},
  owner = {Katia},
  references = {Redesign of a Freshman Engineering Program for the New Millenium

	Why Hands-on Design? A First Year Hands-on Design & Dissection Laboratory

	Providing early design/build opportunities to Freshman Engineering
	Students

	Objects First with Java - A Practical Introduction using BlueJ

	Teaching objects-first in introductory computer science},
  timestamp = {2010.06.22}
}

@ARTICLE{I[66],
    inserir = {true},
  author = {E. V. Howard},
  title = {Attitudes on using pair-programming},
  year = {2006},
  abstract = {During a research study conducted over four semesters, students enrolled
	in an introductory programming class at a commuter campus used the
	pair-programming approach for both in-class labs and out-of-class
	programming assignments. This study was a comprehensive assessment
	of pair-programming using multiple measures of both quantitative
	and qualitative feedback about students' experiences with pair-programming.
	The results show that overwhelmingly, students reported positive
	reactions to working with a partner using the pair-programming paradigm.
	As expected at a commuter campus, the most common challenge students
	reported was difficulty of coordinating schedules. This article provides
	the results of the study and offers suggestions for managing pair-programming
	on a commuter campus.},
  owner = {Katia},
  references = {On understanding compatibility of student pair programmers

	Effects of agile practices on social factors

	Teaching software engineering practices with Extreme Programming

	Redesigning introductory computer programming with HTML, JavaScript,
	and Java

	Experimenting with pair programming in the classroom

	The effects of pair-programming on performance in an introductory
	programming course

	The impact of pair programming on student performance, perception
	and persistence

	A cross-program investigation of students’ perceptions of agile methods

	Investigating pair-programming in a 2nd-year software development
	and design computer science course

	Improving the CS1 experience with pair programming

	Pair programming as a model of collaborative learning: A review of
	the research

	Some social factors of software engineering: The maverick, community
	and technical practices

	What we can learn from extreme programming

	Code warriors and code-a-phobes: A study in attitude and pair programming

	Coupling pair programming and writing: Learning about students’ perceptions
	and processes

	Student culture vs group work in computer science

	All I really need to know about pair programming I learned in kindergarten

	In support of student pair-programming},
  timestamp = {2010.06.22}
}

@ARTICLE{E[75],
    inserir = {false},
  author = {H. Hulkko and P. Abrahamsson},
  title = {A multiple case study on the impact of pair programming on product
	quality},
  year = {2005},
  abstract = {Pair programming is a programming technique in which two programmers
	use one computer to work together on the same task. There is an ongoing
	debate over the value of pair programming in software development.
	The current body of knowledge in this area is scattered and unorganized.
	Review shows that most of the results have been obtained from experimental
	studies in university settings. Few, if any, empirical studies exist,
	where pair programming has been systematically under scrutiny in
	real software development projects. Thus, its proposed benefits remain
	currently without solid empirical evidence. This paper reports results
	from four software development projects where the impact of pair
	programming on software product quality was studied. Our empirical
	findings appear to offer contrasting results regarding some of the
	claimed benefits of pair programming. They indicate that pair programming
	may not necessarily provide as extensive quality benefits as suggested
	in literature, and on the other hand, does not result in consistently
	superior productivity when compared to solo programming.},
  owner = {Katia},
  references = {Pair Programming Illuminated

	Extreme Programming Explained: Embrace Change

	New Directions on Agile Methods: A Comparative Analysis

	Tool Support for Distributed Pair Programming

	Empirical Evaluation of Agile Software Development: A Controlled Case
	Study Approach

	The Case for Collaborative Programming

	The Collaborative Software Process

	Strengthening the Case for Pair Programming

	When Does a Pair Outperform Two Individuals?

	Are Reviews an Alternative to Pair Programming?

	Experimental Evaluation of Pair Programming

	A Discipline for Software Engineering

	Integrating Pair Programming into a Software Development Process

	Experiences with a Case Study on Pair Programming

	An Initial Exploration of the Relationship Between Pair Programming
	and Brooks' Law

	A Pair Programming Experience

	Exploring XP for Scientific Research

	An Initial Framework for Research on Pair Programming

	The Costs and Benefits of Pair Programming

	A Comparison of Pair Programming to Inspections for Software Defect
	Reduction

	The Impact of Pair Programming on Student Performance, Perception
	and Persistence

	Building Pair Programming Knowledge through a Family of Experiments

	A Summary from a Pair Programming Survey - Increasing Quality with
	Pair Programming

	Pair Programming and Pair Trading: Effect on Learning and Motivation
	in a CS2 Course

	Case Study: Extreme Programming in a University Environment

	The Effects of “Pair-Pressure” and “Pair-Learning” on Software Engineering
	Education

	Mobile-D: An Agile Approach for Mobile Application Development

	The Adherence of Open Source Java Programmers to Standard Coding Practices

	Using a Coding Standard to Improve Program Quality

	An Integrated Measure of Software Maintainability

	Extreme Programming: a University Team Design Experience

	Coupling Pair Programming and Writing: Learning about Students' Perceptions
	and Processes},
  timestamp = {2010.06.22}
}

@ARTICLE{I[58],
    inserir = {true},
  author = {T. V. Toll III and R. Lee and T. Ahlswede},
  title = {Evaluating the Usefulness of Pair Programming in a Classroom Setting},
  year = {2007},
  abstract = {Pair programming, the practice of two programmers working side by
	side on the same task on one computer, is a practice that is becoming
	increasingly prevalent in the computer science industry. Although
	there has been a large amount of research investigating pair programming
	in an industry setting, there has been little work done with pair
	programming in a classroom setting. Furthermore, the studies that
	have been done have concentrated on programming students with ample
	programming experience in a variety of languages. In addition to
	this, industry studies have focused in on the amount of work being
	completed rather than what is learned by the programmers. Therefore,
	this work will concentrate on students with considerably less programming
	experience, and focus on whether they learn better while working
	in teams. In addition, we will investigate how the difference in
	programming skill contributes to the amount learned. To do so, we
	have observed and interviewed students participating in pair programming
	to determine whether they are able to learn more and enjoy their
	work more when working in pairs. Finally, we participated in pair
	programming in a variety of settings to test it first hand. We found
	that despite some drawbacks, pair programming can be extremely beneficial.
	When used correctly, pair programming can be a valuable asset to
	the computer science classroom.},
  owner = {Katia},
  references = {Strengthening the Case for Pair-Programming

	5 Lessons from Transitioning to eXtreme Programming

	What Managers Can Learn from Extreme Programming: Grassroots Learning
	from Developers

	A Pair Programming Experience

	Experi-menting with Industry’s ‘Pair-Programming’ Model in the Computer
	Science Classroom

	Constantine on Peopleware

	Extreme Programming Refactored: The Case Against XP

	Pair Programming Illuminated

	The case for collaborative programming

	A Multiple Case Study on the Impact of Pair Programming on Product
	Quality

	Pair programming improves student retention, confidence, and program
	quality},
  timestamp = {2010.06.22}
}

@ARTICLE{E[76],
    inserir = {false},
  author = {L. S. Indrusiak and J. Becker and M. Glesner and R. A. da L. Reis},
  title = {Distributed collaborative design over Cave2 framework},
  year = {2002},
  abstract = {This paper presents the research and development of mechanisms to
	allow distributed collaborative design of integrated systems. Those
	mechanisms were implemented over the software infrastructure developed
	under the Cave Project, taking advantage on both definitions of the
	framework concept: classical electronic design frameworks and object-oriented
	extensible data modeling. The final result is a design environment
	accessible over Internet-like networks, where groups of designers
	can work over the design representation in a collaborative way. In
	order to organize the interaction between the designers, an extension
	to the Pair Programming collaboration methodology was developed and
	implemented in a case study.},
  owner = {Katia},
  references = {(not available): http://portal.acm.org/citation.cfm?id=647031.715106:
	Distributed collaborative design over Cave2 framework

	(not available): Distributed collaborative design over Cave2 framework

	(not available): Distributed collaborative design over Cave2 framework

	(not available): Distributed collaborative design over Cave2 framework

	(not available): Distributed collaborative design over Cave2 framework

	(not available): Distributed collaborative design over Cave2 framework

	(not available): Distributed collaborative design over Cave2 framework

	(not available): Distributed collaborative design over Cave2 framework

	(not available): Distributed collaborative design over Cave2 framework

	(not available): Distributed collaborative design over Cave2 framework

	(not available): Distributed collaborative design over Cave2 framework},
  timestamp = {2010.06.21}
}

@ARTICLE{I[26],
    inserir = {true},
  author = {S. D. James and J. C. Hansen},
  title = {Student-based pair programming: an examination},
  year = {2002},
  abstract = {This paper examines the retention and learning of unfamiliar material
	to undergraduate students through the use of pair programming. Students
	in a networking class were asked to develop software applications
	together in the hope that each student would learn more and develop
	better applications. A survey was then distributed to assess the
	outcome and analyze the results.},
  owner = {Katia},
  references = {E-Government - Elektronische Informationsdienste auf Bundesebene in
	Osterreich

	Arbeitsgruppe e-government der Koordinationsgruppe Informationsgesellschaft

	Bericht uber die Studien zu den Guichets Virtuels in der Welt

	Grunbuch EU KOM

	Momorandum Electronic Government

	Tagung des Europaischen Rates

	E-Gocernment - Verwaltung online

	Prozessmanagement als Grundlage fur integriertes eGovernment

	Classification portofolio for electronic Government approaches

	Future trends of electronic government

	Electronic services within the public sector},
  timestamp = {2010.06.21}
}

@ARTICLE{E[77],
    inserir = {false},
  author = {S. I. Jami and Z. A. Shaikh},
  title = {Teaching Computer Science Courses Using Extreme Programming (XP)
	Methodology},
  year = {2005},
  abstract = {This paper describes the extreme programming (XP) methodology and
	its effectiveness in incorporating its practices in computer science
	curriculum. We explored several merits and demerits of this incorporation
	based on our experiences and observations which are supported by
	other researchers. In this study we considered those courses of computer
	science that involve the processes of software development and analysis.
	It has been found that XP in full practice is vulnerable against
	a single course of software engineering, so some of its practices
	should be incorporated in the first semester of computer science
	curriculum and rest should be incorporated in later years. We start
	our work from the introductory course in computer science where we
	first implement the concept of pair programming and then implement
	other practices. Some suggestions are included in this work that
	can be helpful in implementing this methodology.},
  owner = {Katia},
  references = {Strengthening the Case for Pair Programminig

	The Costs and Benefits of Pair Programming

	A Practical Application of XP

	Limitations of Agile Software Processes

	All I reaIly need to know about pair programming I learned

	Bringing Extreme Programming to the Classroom

	Extreme programming explained

	What is Extreme Programming

	Extreme Programming and the Software Design Course

	Extreme Programming for Software Engineering Education

	The Impact of Pair Programming on Student Performance, Perception
	and Persistence

	Teaching XP for Real: some initial observations and plans

	Positive Experiences with an Open ProjeCt Assignment in an Introductory
	Programming Course},
  timestamp = {2010.06.22}
}

@ARTICLE{I[27],
    inserir = {true},
  author = {A. Janes and B. Russo and P. Zuliani and G. Succi},
  title = {An empirical analysis on the discontinuous use of pair programming},
  year = {2003},
  abstract = {Pair programming has been shown to increase communication and teamwork
	skills and to provide better code. The aim of this work is to show
	the efficacy of pair programming in transferring knowledge and skills
	over an environment where people met only occasionally. In a quasi
	experiment, we find that pair programming is effective in sharing
	knowledge among 15 students who met once a week for a half day, and
	did their internship individually or in couple for the remaining
	4 half days.},
  owner = {Katia},
  references = {Distributed eXtreme Programming

	The Costs and Benefits of Pair Programming

	Strengthening the Case for Pair Programming

	Distributed Pair Programming Empirical Studies and Supporting Environments

	The TAME Project: Towards Improvement-Oriented Software Environments

	Experimentation in Software Engineering: An Introduction

	Preliminary Analysis of the Effects of Pair Programming on Job Satisfaction},
  timestamp = {2010.06.22}
}

@ARTICLE{E[78],
    inserir = {false},
  author = {D. Janzen and H. Saiedian},
  title = {Test-driven development: Concepts, taxonomy, and future direction},
  year = {2005},
  abstract = {The test-driven development strategy requires writing automated tests
	prior to developing functional code in small, rapid iterations. XP
	is an agile method that develops object-oriented software in very
	short iterations with little upfront design. Although not originally
	given this name, TDD was described as an integral XP practice necessary
	for analysis, design, and testing that also enables design through
	refactoring, collective ownership, continuous integration, and programmer
	courage. Along with pair programming and refactoring, TDD has received
	considerable individual attention since XP's introduction. Developers
	have created tools specifically to support TDD across a range of
	languages and have written numerous books explaining how to apply
	TDD concepts. Researchers have begun to examine TDD's effects on
	defect reduction and quality improvements in academic and professional
	practitioner environments, and educators have started to examine
	how to integrate TDD into computer science and software engineering
	pedagogy.},
  owner = {Katia},
  references = {Test-Driven Development Concepts, Taxonomy, and Future Direction},
  timestamp = {2010.06.22}
}

@ARTICLE{E[79],
    inserir = {false},
  author = {V. Jari and K. Harri},
  title = {Experiences of Using Pair Programming in an Agile Project},
  year = {2007},
  abstract = {The interest in pair programming (PP) has increased recently, e.g.
	by the popularization of agile software development. However, many
	practicalities of PP are poorly understood. We present experiences
	of using PP extensively in an industrial project. The fact that the
	team had a limited number of high-end workstations forced it in a
	positive way to quick deployment and rigorous use of PP. The developers
	liked PP and learned it easily. Initially, the pairs were not rotated
	frequently but adopting daily, random rotation improved the situation.
	Frequent rotation seemed to improve knowledge transfer. The driver/navigator
	roles were switched seldom, but still the partners communicated actively.
	The navigator rarely spotted defects during coding, but the released
	code contained almost no defects. Test-driven development and design
	in pairs possibly decreased defects. The developers considered that
	PP improved quality and knowledge transfer, and was better suited
	for complex tasks than for easy tasks.},
  owner = {Katia},
  references = {Pair Programming Illuminated

	The Collaborative Software Process

	The Case for Collaborative Programming

	Effects of Pair Programming at the Development Team Level: An Experiment

	The Costs and Benefits of Pair Programming

	Experimental Evaluation of Pair Programming

	Tracking Test First Pair Programming – An Experiment

	The Benefits of Collaboration for Student Programmers

	Extreme Programming Explained

	Software Development Worldwide: The State of the Practice

	An Initial Framework for Research on Pair Programming

	Subclassing XP: Breaking its rules the right way

	Agile Methods Applied to Embedded Firmware Development

	Application of Tightly Coupled Engineering Team for Development of
	Test Automation Software – A Real World Experience

	Extreme Programming Practices: What’s on Top?

	Qualitative Studies of XP in a Medium Sized Business

	Technical and Human Perspectives on Pair Programming

	Social Behaviors on XP and non-XP teams: A Comparative Study

	Paired Programming & Personality Traits

	An Ethnographic Study of XP Practice

	Promiscuous Pairing and Beginner’s Mind: Embrace Inexperience

	Double trouble: Mixing qualitative and quantitative methods in the
	study of eXtreme Programmers

	A Framework for Understanding the Factors Influencing Pair Programming
	success

	Pair programming and the re-appropriation of individual tools for
	collaborative programming

	Experiences in Learning XP Practices: A qualitative Study

	Case Study Research: Design and Methods},
  timestamp = {2010.06.22}
}

@ARTICLE{E[80],
    inserir = {false},
  author = {A. Johnston and C. S. Johnson},
  title = {Extreme programming: a more musical approach to software development?},
  year = {2003},
  abstract = {This paper considers the relationship between software development
	as it is typically practiced, the extreme programming methodology
	and the learning and working environment of those involved in a creative
	art - music. In particular we emphasise how pair programming can
	facilitate an increase in the overall skill level of individuals
	and teams, and relate this to musicians' development of models of
	excellence through ensemble playing. Consideration is also given
	to the psychology of music performance and its relevance to the pursuit
	of excellence in software development.},
  owner = {Katia},
  references = {Software Craftsmanship: The New Imperative

	Extreme Programming Explained: Embrace Change

	The Costs and Benefits of Pair Programming

	The Case for Collaborative Programming

	String Instruments

	The development of expertise in young musicians: Strategy, use knowledge
	acquisition and individual diversity

	The role of deliberate practice in the acquisition of expert performance

	Developing Talent in Young People},
  timestamp = {2010.06.22}
}

@ARTICLE{E[81],
    inserir = {false},
  author = {R. Juric},
  title = {Extreme programming and its development practices},
  year = {2000},
  abstract = {Extreme programming (XP) has attracted attention because of its fierce
	denial of many well-accepted software engineering practices considered
	as a sound approach to the development of intensive software systems.
	XP has been declared to be a new way of software development: a lightweight
	methodology, which is efficient, low-risk, flexible, predictable,
	scientific, and distinguishable from any other methodology. In the
	core of XP practices are programming activities, with strong emphasis
	on oral communications, automated tests, pair programming, storytelling
	culture and collective code-ownership at any time in the XP project.
	The paper gives an overview of XP practices and raises some serious
	concerns regarding their role in conceptual modelling and code generation;
	which directly affects software architecture solutions. The paper
	also tackles similarities between rational unified process (RUP)
	and XP, which have often been juxtaposed by software developers.},
  owner = {Katia},
  references = {Extreme Programming Explained

	Crysler Goes to Extreme

	The Unified Modelling Language User Guide

	Structured Analysis and System Specification

	The Unified Software Development Process

	The UML Rules

	Inside COMA Distributed Object Standards and OMG (1999) UML version
	1.3

	Object Oriented Modelling and Design

	Software Architecture, Perspectives on an Emerging Discipline},
  timestamp = {2010.06.21}
}

@ARTICLE{E[82],
    inserir = {false},
  author = {L. Karlsson and sa G. Dahlstedt and B. Regnell and J. N. och Dag
	and A. Persson},
  title = {Requirements engineering challenges in market-driven software development
	- An interview study with practitioners},
  year = {2007},
  abstract = {Requirements engineering for market-driven software development entails
	special challenges. This paper presents results from an empirical
	study that investigates these challenges, taking a qualitative approach
	using interviews with fourteen employees at eight software companies
	and a focus group meeting with practitioners. The objective of the
	study is to increase the understanding of the area of market-driven
	requirements engineering and provide suggestions for future research
	by describing encountered challenges. A number of challenging issues
	were found, including bridging communication gaps between marketing
	and development, selecting the right level of process support, basing
	the release plan on uncertain estimates, and managing the constant
	flow of requirements.},
  owner = {Katia},
  references = {The world's a stage: a survey on requirements engineering using a
	real-life case study

	A Usability Perspective on Requirements Engineering - From Methodology
	to Product Development

	Release planning in market-driven software product development: provoking
	an understanding

	A Process Model for Packaged Software Development

	Factors Affecting Completion of the Requirements Capture Stage of
	Projects with Different Characteristics

	Making Sense of Qualitative Data

	Winning at new products: accelerating the process from idea to launch

	A field study of the software design process for large systems

	RE challenges in multi-site software development organisations

	A Process Model for Requirements Engineering of CCOTS

	Avoiding Common Pitfalls in Qualitative Data Collection and Transcription

	A field study of requirements engineering practices in information
	systems development

	UML distilled (2nd ed.): a brief guide to the standard object modeling
	language

	The Discovery of Grounded Theory: Strategies for Qualitative Research

	Requirements Problems in Twelve Software Companies: An Empirical Analysis

	Managing Requirements for Medical IT Products

	Choosing Qualitative Research: A Primer for Technology Education Researchers

	Requirements Engineering as a Success Factor in Software Projects

	Principles of Commercial Systems Engineering

	The unified software development process

	Requirements Engineering in Small and Medium Enterprises: State-of-the-Practice,
	Problems, Solutions and Technology Transfer

	Software Requirements Prioritizing

	A Systematic Approach for Prioritizing Software Requirements

	Challenges in Market-Driven Requirements Engineering - an Industrial
	Interview Study

	A Review of the State of the Practice in Requirements Modelling

	Qualitative research in information systems

	A State-of-the-Practice Survey on Requirements Engineering in Small-
	and Medium-Sized Enterprises

	Benefits of Structured Requirements Methods for Market-Based Enterprises

	Qualitative Research and Evaluation Methods

	Invented requirements and imagined customers: requirements engineering
	for off-the-shelf software

	Real World Research

	Packaged Software: Challenges for RE

	Improving Market-Driven RE Processes

	Packaged software: implications of the differences from custom approaches
	to software development},
  timestamp = {2010.06.22}
}

@ARTICLE{I[29],
    inserir = {true},
  author = {N. Katira and L. Williams and J. Osborne},
  title = {Towards Increasing the Compatibility of Student Pair Programmers},
  year = {2005},
  abstract = {As pair programming is used widely in software engineering education,
	instructors may wish to proactively form pairs to increase the likelihood
	of compatible pairs. A study involving 361 software engineering students
	was carried out at North Carolina State University to understand
	and predict pair compatibility. We have found that students are compatible
	with partners whom they perceive of similar skill, although instructors
	cannot proactively manage this perception. Pairing of two minority
	students is more likely and mixed gender pairs are less likely to
	be compatible. Additionally, pairing of students with similar actual
	skill level as measured by midterm grades in class, GPA, and SAT/GRE
	scores also likely results in compatible pairs. Our research addresses
	the following challenges faced by instructors in software engineering:
	1) organizational concern in pairing of students; 2) increasing the
	retention rates of female and minority students in classes; and 3)
	proactively forming mutually-compatible pairs.},
  owner = {Katia},
  references = {On Understanding the Compatibility of Student Pair Programmers

	Caring about Connections: Gender and Computing

	Perceptions of Agile Practices: A Student Survey, Extreme Programming/Agile
	Universe

	Student Diversity Requires Different Approaches to College Teaching,
	Even in Math and Science

	Code Warriors and Code-a-Phobes: A study in attitude and pair programming

	Studying students studying calculus: A look at the lives of minority
	mathematics students in college},
  timestamp = {2010.06.22}
}

@ARTICLE{I[28],
    inserir = {true},
  author = {N. Katira and L. Williams and E. Wiebe and C. Miller and S. Balik
	and Ed. Gehringer},
  title = {On understanding compatibility of student pair programmers},
  year = {2004},
  abstract = {In recent years, educators have increasingly used pair programming
	in their computer science courses. Pair programming has been shown
	to be beneficial for both the teaching staff and the students in
	the courses. Occasionally, though, students are not compatible with
	their partners. An extensive study was done at the North Carolina
	State University to provide guidance on forming student pairs to
	improve the chances that pairs will be compatible and have a productive
	work relationship. We examined compatibility among freshman, advanced
	undergraduate, and graduate students. We have found that the students'
	perception of their partner's skill level has a significant influence
	on their compatibility. Graduate students work well with partners
	of similar actual skill level. Freshmen seem to work better with
	partners with different Myers Briggs personality type. Students'
	self-esteem does not appear to be a major contributor to pair compatibility.},
  owner = {Katia},
  references = {Guidelines for the User of Pair Programming in a Freshman Programming
	Class

	The Myers-Briggs personality type and its relationship to computer
	programming

	Group Dynamics and Collaborative Group Performance

	Please Understand Me II

	The Effect of Pair Programming on Performance in an Introductory Programming
	Course

	The Impact of Pair Programming on Student Performance of Computer
	Science Related Majors

	Perceptions of Agile Practices: A Student Survey

	Improving the CS1 Experience with Pair Programming

	Pair Learning: With an Eye Toward Future Success

	Code Warriors and Code-a-Phobes: A study in attitude and pair programming

	Mind in Society: The Development of Higher Psychological Processes

	In Support of Pair Programming in the Introductory Computer Science
	Course

	Pair Programming Illuminated

	Building Pair Programming Knowledge Through a Family of Experiments},
  timestamp = {2010.06.22}
}

@ARTICLE{E[83],
    inserir = {false},
  author = {G. Keefer},
  title = {Pair programming: An alternative to reviews and inspections?},
  year = {2005},
  abstract = {The benefits of pair programming in relation to reviews and inspections
	applied to software development are discussed. Pair programming is
	defined as a practice in which two programmers sit side by side at
	one computer for developing software. Pair programming supports a
	higher focus on the task as a result of the peer pressure that comes
	along with it. Program code knowledge is distributed among two or
	more developers as soon as the code is typed. It is suggested that
	traditional QA processes, such as inspections and reviews, must be
	adapted to accommodate today's need for distributed development,
	low overhead, electronic processing, and storage of process data
	and artifacts.},
  owner = {Katia},
  references = {(not available): "Buy this article": http://direct.bl.uk/bld/PlaceOrder.do?UIN=164025444&ETOC=RN&from=searchengine

	(not available): Pair programming: An alternative to reviews and inspections?

	(not available): Pair programming: An alternative to reviews and inspections?

	(not available): Pair programming: An alternative to reviews and inspections?

	(not available): Pair programming: An alternative to reviews and inspections?

	(not available): Pair programming: An alternative to reviews and inspections?

	(not available): Pair programming: An alternative to reviews and inspections?

	(not available): Pair programming: An alternative to reviews and inspections?

	(not available): Pair programming: An alternative to reviews and inspections?

	(not available): Pair programming: An alternative to reviews and inspections?

	(not available): Pair programming: An alternative to reviews and inspections?},
  timestamp = {2010.06.22}
}

@ARTICLE{E[84],
    inserir = {false},
  author = {G. Keefer},
  title = {Extreme programming considered harmful for reliable software development},
  year = {2002},
  abstract = {This paper presents and discusses various facts and data collected
	on extreme programming and how this method relates to traditional
	software engineering practices. The paper presents reasons, albeit
	no scientific proofs, why extreme programming fails to provide answers
	to significant questions that contemporary software development methods
	have to answer. This paper is an attempt to contribute to a discussion
	that is based on data and facts.},
  owner = {Katia},
  references = {Chrysler goes to “Extremes”

	Embracing Change with Extreme Programming

	Extreme Programming Explained

	Planning Extreme Programming

	Software Testing Techniques

	The Mythical Man-Month

	Selecting a Project’s Methodology

	Extreme Rules of the Road

	Peopleware

	XP und “Pair Programming”

	Resistance to change: Issues with early and often delivery?

	Launching Extreme Programming at a Process-Intensive Company

	Managing Problem People in XP Implementation

	The school of Niklaus Wirth: the art of simplicity

	Pair Programming on the C3 project

	Will Extreme Programming kill your customer?

	Extreme Testing

	The CMMI in 45 Minutes

	A CMMI Compatible Risk Management Process

	Interview with Robert C. Martin

	The Art of Software Testing

	Experimental Evaluation of Pair Programming

	The Case for Collaborative Programming

	A Personal View of Education

	Using Metrics to Manage the End Game of a Software Project

	Mastering the Requirements Process

	Recovery, Redemption and Extreme Programming

	Avalanche Rescue Systems in Switzerland: Experience and Limitations

	The Collaborative Software Process

	Strengthening the Case for Pair Programming

	Experimenting with Industry's "Pair-Programming" Model in the Computer
	Science Classroom

	The Costs and Benefits of Pair Programming

	In Support of Student Pair-Programming},
  timestamp = {2010.06.21}
}

@ARTICLE{E[85],
    inserir = {false},
  author = {P. Kettunen and M. Laanti},
  title = {How to steer an embedded software project: tactics for selecting
	the software process model},
  year = {2005},
  abstract = {Modern large new product developments (NPD) are typically characterized
	by many uncertainties and frequent changes. Often the embedded software
	development projects working on such products face many problems
	compared to traditional, placid project environments. One of the
	major project management decisions is then the selection of the project's
	software process model. An appropriate process model helps coping
	with the challenges, and prevents many potential project problems.
	On the other hand, an unsuitable process choice causes additional
	problems. This paper investigates the software process model selection
	in the context of large market-driven embedded software product development
	for new telecommunications equipment. Based on a quasi-formal comparison
	of publicly known software process models including modern agile
	methodologies, we propose a process model selection frame, which
	the project manager can use as a systematic guide for (re)choosing
	the project's process model. A novel feature of this comparative
	selection model is that we make the comparison against typical software
	project problem issues. Some real-life project case examples are
	examined against this model. The selection matrix expresses how different
	process models answer to different questions, and indeed there is
	not a single process model that would answer all the questions. On
	the contrary, some of the seeds to the project problems are in the
	process models themselves. However, being conscious of these problems
	and pitfalls when steering a project enables the project manager
	to master the situation.},
  owner = {Katia},
  references = {Software process improvement: blueprints versus recipes

	Agile Software Development Methods: Review and Analysis

	New Directions on Agile Methods: A Comparative Analysis

	Process Patterns—Building Large-Scale Systems Using Object Technology

	Framing Reuse: Lessons from the Real World

	Planning Extreme Programming

	A spiral model of software development and enhancement

	Software risk management: principles and practices

	Get ready for agile methods, with care

	Balancing Agility and Discipline—A Guide for the Perplexed

	No silver bullet: essence and accidents of software engineering

	The Mythical Man-Month: Essays on Software Engineering

	AntiPatterns in Project Management

	Selecting a project’s methodology

	Agile Software Development

	A field study of the software design process for large systems

	Why the Vasa Sank: 10 problems and some antidotes for software projects

	Software Runaways

	Matching methodology to problem domain

	Dispelling the process myth: having a process does not mean sacrificing
	agility or creativity

	The living software development process

	Adaptive Software Development—A Collaborative Approach to Managing
	Complex Systems

	Agile Software Development Ecosystems

	Patterns of Software System Failure and Success

	Agile Process Tailoring and Problem Analysis (APTLY)

	Managing embedded software project team knowledge

	The Rational Unified Process: An Introduction

	Achieving CMMI Level 2 with Enhanced Extreme Programming Approach

	Agile and Iterative Development—A Manager’s Guide

	Breaking the Ice for Agile Development of Embedded Software: An Industry
	Experience Report

	Identifying Extensions Required by RUP (Rational Unified Process)
	to Comply with CMM (Capability Maturity Model) Levels 2 and 3

	Software project casualty

	Rapid Development: Taming Wild Software Schedules

	Software Project Survival Guide

	Software quality management in turbulent times—are there alternatives
	to process oriented software quality management?

	Managing Software Quality and Business Risk

	A Practical Guide to Feature-Driven Development

	Ten deadly risks in internet and intranet software development

	Software development under stringent hardware constraints: Do agile
	methods have a chance?

	Components of software development risk: how to address them?

	Software Project Management

	Troubled IT Projects—Prevention and Turnaround

	The 40 root causes of troubled IT projects

	A Comparison of the IBM Rational Unified Process and eXtreme Programming

	Software process models

	Toward objective, systematic design method comparisons

	A comparison of software development methodologies

	Product-based software process improvement for embedded systems

	People factors in software management: lessons from comparing agile
	and plan-driven methods

	Practical experiences of agility in the telecom industry

	Engineering computer-based systems: meeting the challenge

	The Complete Software Developer’s Guide to Surviving “Mission Impossible”
	Projects},
  timestamp = {2010.06.22}
}

@ARTICLE{E[87],
    inserir = {false},
  author = {J. Kivi and D. Haydon and J. Hayes and R. Schneider and G. Succie},
  title = {Extreme programming: a university team design experience},
  year = {2000},
  abstract = {The paper discusses an experience in applying the extreme programming
	approach to the 4 year team design project course. Extreme programming
	is a methodology for software system development that focuses on
	high customer integration, extensive testing, code-centered development
	and documentation, refactoring and paired programming. Typically,
	the project course is managed using the standard waterfall or V-shaped
	development models with a faculty advisor acting as a customer for
	the project. In this project extreme programming has been used instead.
	Extreme programming is based on a sequence of development practices,
	including pair programming, very accurate configuration management,
	strong customer interaction based on "system stories", detailed testing.
	In this project, paired programmers are used for the duration of
	a release and then the pairs rotate. The distributed programming
	environment is handled using the JCVS suite of configuration management
	tools. Every 3-4 weeks, a new fully functional release is delivered
	and reviewed by the customer. The specifications for each release
	are captured incrementally using use case scenarios. Only the essential
	requirements for the current iteration are implemented. The JUnit
	test suite is also used to test each of the Java classes on an ongoing
	basis. The test suite verifies all aspects of the software at each
	build; this is necessary when refactoring components. Requirements
	capture, design and implementation of the deliverables are performed
	incrementally and result in quicker development times and reduced
	defects. Refactoring is applied wherever possible to simplify the
	code. Documentation is applied using the standard JavaDoc utility
	and is kept to a minimum. Finally, customer feedback is immediately
	incorporated into future iterations of the design process.},
  owner = {Katia},
  references = {Extreme Programming Explained: Embrace Change

	Refactoring: Improving the Design of Existing Code

	Probability and Statistics for Engineers and Scientists},
  timestamp = {2010.06.21}
}

@ARTICLE{E[88],
    inserir = {false},
  author = {A. G. Koru and A. A. Ozok and A. F. Norcio},
  title = {The Effect of Human Memory Organization on Code Reviews under Different
	Single and Pair Code Reviewing Scenarios},
  year = {2005},
  abstract = {Human memory organization has been shown to be related to how programmers
	understand programs. In recent years, agile methods brought the emphasis
	back on human and social aspects of software engineering with a set
	of new principles and practices. One of them, pair programming has
	been shown to improve quality and reduce the development costs. In
	this position paper, we propose a controlled experiment to evaluate
	the effect of human memory organization through chunking on code
	reviews under different single and pair code reviewing scenarios.},
  owner = {Katia},
  references = {Extreme programming explained: embrace change

	The costs and benefits of pair programming

	Managing the software process

	The magical number seven, plus or minus two: Some limits on our capacity
	for processing information

	Human memory organization for computer programs

	Strengthening the Case for Pair Programming

	Building Pair Programming Knowledge through a Family of Experiments},
  timestamp = {2010.06.22}
}

@ARTICLE{E[89],
    inserir = {false},
  author = {B. Kovitz},
  title = {Hidden skills that support phased and agile requirements engineering},
  year = {2003},
  abstract = {Phased development does requirements engineering in one or a small
	number of extended phases occurring early in a project. Agile development
	also does requirements engineering, but in thousands of small conversations
	spread throughout the development life cycle. Each depends on subtly
	different skills and expertise to perform its practices - agile development
	depending heavily on ability to change working code, phased development
	depending heavily on foresight. We survey the special skills that
	each style of requirements engineering depends on in order to promise
	and deliver.},
  owner = {Katia},
  references = {Natural documentation

	Essential XP: documentation

	What’s in it for the business? XP Mag 30 September

	Extreme programming explained

	The agile manifesto

	Test-driven development: by example

	Refactoring: improving the design of existing code

	Recommended practice for software requirements specifications

	The almighty thud

	Why does software cost so much?},
  timestamp = {2010.06.22}
}

@ARTICLE{E[90],
    inserir = {false},
  author = {G. Krajnc and V. Mahnic},
  title = {Programming in pairs in high schools},
  year = {2006},
  abstract = {Extreme programming (XP) is a new style of software development focusing
	on excellent applications of programming techniques, clear communication,
	and team work, which gives unimaginable results. A major practice
	of extreme programming is pair programming. There are two programmers
	working side by side at the same computer, collaborating on the same
	analysis, the same design, implementation and test. Proponents of
	pair programming argue that programs produced by pairs are of higher
	quality, with less errors, better design than those produced by one
	programmer. And they are made in the shortest time possible as well.
	We think that pair programming model has also been found to be beneficial
	for students. Initial quantitative and qualitative results demonstrate
	that the use of pair programming in the computer science classroom
	enhances student learning and satisfaction. We explore the nature
	of pair programming, then examine the ways such a practise may enhance
	teaching and learning in computer science education.},
  owner = {Katia},
  references = {Manifesto for Agile Software Development

	Programming In Pairs Testimonials

	What is Extreme programming

	PairDraw

	A Pair Programming Experience

	The Psychology of Computer Programming

	Pair Programming questionnaire},
  timestamp = {2010.06.22}
}

@ARTICLE{E[91],
    inserir = {false},
  author = {W. Krebs},
  title = {Turning the knobs: a coaching pattern for XP through agile metrics},
  year = {2002},
  abstract = {I want to turn the knobs to 10, but my job position doesn't allow
	me to dictate that my team do so. Even if it did, forcing XP may
	serve only to cause resentment and backlash. Though I've been learning
	XP for over a year, it's still new to the rest of our team, and we're
	used to our old habits. By giving team members control of how extreme
	to be through a 'teaching survey', the team has started at a comfortable
	level of XP and has opened the door to future extremes. We've used
	the survey to define, coach, and track our XP process and have increased
	our use of XP by 10% in three months.},
  owner = {Katia},
  references = {Multiple papers on Pair Programming

	Continuous Learning

	eXtreme Programming eXplained

	Extreme Programming Explored

	Extreme Programming Installed

	Extreme Programming Examined

	Java Tools for eXtreme Programming},
  timestamp = {2010.06.21}
}

@ARTICLE{I[30],
    inserir = {true},
  author = {S. Kuppuswami and K. Vivekanandan},
  title = {The effects of pair programming on learning efficiency in short programming
	assignments},
  year = {2004},
  abstract = {Pair programming is one of the important practices of a lightweight
	development methodology namely eXtreme Programming (XP). It emphasizes
	the practice of two persons working together at a single computer
	terminal, to design, code and test computer programs. The effects
	of pair programming on software development in industrial organizations
	were studied and it was found that pair programming increases the
	productivity by 15%. This evidence created an interest in amongst
	community of computer science educators to apply pair programming
	in educational settings. We have conducted an experiment with the
	students of computer science courses to compare the learning efficiency
	of students when they adopt pair programming with that of students
	using traditional method to do laboratory exercises of short duration.
	The learning efficiency was measured by evaluating design documents,
	completion time, and marks obtained in a written test that was conducted
	after every exercise. Our research confirms that the adoption of
	pair programming improves the design ability, reduces time taken
	to do a laboratory exercise and increases the knowledge and programming
	skill.},
  owner = {Katia},
  references = {The empirical investigation of perspective reading

	Extreme Programming Explained: Embrace Change

	Get ready for agile methods with care

	The costs and benefits of extreme programming

	Experiment Design and Statistical Methods

	Paired programming and personality traits

	Experiences gained from teaching and learning extreme programming

	Agile software development: the business of innovation

	EXtreme Adoption Experiences of B2B Start up

	Educational Research: Quantitative, Qualitative, and Mixed Approaches

	Using a formal collaborative learning paradigm for veterinary medical
	education

	Female students’ perspective on the adoption of pair programming to
	conduct laboratory experiments

	Code warriors and code-a-phoebes: a study in attitude and pair programming

	Extreme programming: rapid development for web-based applications

	Case study: extreme programming in a university environment

	The effects of pair-programming on performance in an introductory
	programming course

	Perceptions of agile practices: a student survey

	Experimental evaluation of pair programming

	No pain, No XP observations on teaching and mentoring extreme programming
	to university students

	Software Engineering: A Practitioner’s Approach

	Student perceptions of the suitability of extreme and pair programming

	Code warriors and code-a-phobes: a study in attitude and pair programming

	Pair programming and pair trading effects on learning and motivation
	in a CS2 Course

	Experimenting with industry‘s pair programming model in the computer
	science classroom

	Pair programming in an introductory computer science course: initial
	results and recommendations

	The Research Methods Knowledge Base},
  timestamp = {2010.06.22}
}

@ARTICLE{E[92],
    inserir = {false},
  author = {S. Kuppuswami and K. Vivekanandan and P. Ramaswamy and P. Rodrigues},
  title = {The Effects of Individual XP Practices on Software Development Effort},
  year = {2003},
  abstract = {Traditional heavyweight software development methodologies are rigid,
	heavily documentation oriented and process oriented. In the present
	E-Business dominated environment, the above methodolo-gies are hard
	to follow. In response to this, a new generation of lightweight methodologies
	such as Extreme Programming (XP) has evolved which has only a few
	simple rules to adopt, and insist on less documentation. XP proposes
	four values, a development process and twelve practices. One of the
	significant benefits among those claimed by the inventors of XP is
	the reduction of effort in the software development. However, the
	extent of ful-fillment of this claim remains unanswered by empirical
	and quantitative evidences. Hence, the effects of XP on software
	development effort are to be investigated. In this study, we devel-oped
	a process simulation model to analyze the effects of individ-ual
	XP practices on development effort. System dynamics based simulation,
	an effective modeling technique for software devel-opment process
	was chosen. This model has accounted for all the twelve practices
	and processes of XP. We have also introduced a measurement scale
	for measuring the level of usage of individual XP practices. The
	factors that affect the cost are collected from literature and a
	few XP project managers. The process model was simulated for a case
	study of a typical XP project to investigate the effects of individual
	XP practices on development effort by vary-ing their usage levels.
	The decrease in percentage of the develop-ment effort for each XP
	practice when its usage level is varied from minimum to maximum during
	which all the other practices were maintained at a constant usage
	level was found. The decrease in percentage of the development effort
	for each XP practice when its usage level is minimum and maximum
	was computed and is given below. (i) Planning game - 2.67% (ii) Small
	Release - 2.67% (iii) Metaphor - 2.01% (iv) Simple design - 2.5%
	(v) Con-tinuous Testing - 2.88% (vi) Refactoring -0.677% (vii) On-site
	Customer - 5.48% (viii) Pair programming - 4.4% (ix) Collective Code
	Ownership – 4.82% (x) Forty Hours Per Week - 2% (xi) Coding Standard
	- 4.82% (xii) Continuous Integration - 1.13%. The finding of the
	present study on the effects of individual XP practices depicts a
	reduction in software development effort by enhancing their usage
	levels.},
  owner = {Katia},
  references = {Software Engineering: A Practitioner's Approach

	What is lightweight methodology?

	Agile software Development Methods

	Extreme programming explained: embrace change

	Refactoring or Upfront Design

	The New Methodology

	Extreme Programming: Rapid Development for Web-Based Applications

	eXtreme Adoption Experiences of a B2B Start Up

	The Costs and Benefits of Extreme Programming

	An extensible model for evaluating the impact of process improvements
	on software development cycle time

	Software Process Simulation Modeling: Why? What? How?

	A System Dynamics Simulation Model to Find the Effects of XP on Cost
	of Change Curve

	Industrial Dynamics

	Software project dynamics: an integrated approach},
  timestamp = {2010.06.22}
}

@ARTICLE{I[11],
    inserir = {true},
  author = {C. Lan and B. Ramesh},
  title = {An exploratory study on the effects of pair programming},
  year = {2004},
  abstract = {This paper reports results from an exploratory study investigating
	the practice of pair programming using a student project conducted
	over a period of nine weeks. We collected qualitative data on the
	use and effectiveness of pair programming. We found that depending
	on the pairing combination used, the effects of pair programming
	can be both positive and negative.},
  owner = {Katia},
  references = {The Costs and Benefits of Pair Programming

	Agile Software Development: The business of Innovation

	Manifesto for Agile Software Development

	Embracing change with extreme programming

	Agile Software Development with SCRUM

	A Practical Guide to Feature-Driven Development

	DSDM: The method in practice

	Agile Software Development

	Agile Modeling

	Discovery colloquium: Quality software development

	The case for Collaborative Programming

	Strengthening the Case for Pair-Programming

	An Initial Investigation of Test Driven Development in Industry

	Experiment about Test-first programming

	The efects of "Pair-Learning"

	In Support of Student Pair-Programming

	The Effects of Justiciation, Task Complexity and Experience/Training
	on Problem-Solving Performance

	Toward an Assessment of software Development Risk

	Get Ready for Agile Methods, with care

	Quasi-Experimentation: Design & Analysis Issues for Field Settings

	Preliminary Analysis of the Effects of Pair Programming on Job Satisfaction

	The Effects of Pair-Programming on Perfomance in an Introductory Programming
	Course

	Pair Programming Illuminated},
  timestamp = {2010.06.22}
}

@ARTICLE{E[93],
    inserir = {false},
  author = {F. Lanubile and T. Mallardo},
  title = {Inspecting Automated Test Code: A Preliminary Study},
  year = {2007},
  abstract = {Testing is an essential part of an agile process as test is automated
	and tends to take the role of specifications in place of documents.
	However, whenever test cases are faulty, developers’ time might be
	wasted to fix problems that do not actually originate in the production
	code. Because of their relevance in agile processes, we posit that
	the quality of test cases can be assured through software inspections
	as a complement to the informal review activity which occurs in pair
	programming. Inspections can thus help the identification of what
	might be wrong in test code and where refactoring is needed. In this
	paper, we report on a preliminary empirical study where we examine
	the effect of conducting software inspections on automated test code.
	First results show that software inspections can improve the quality
	of test code, especially the repeatability attribute. The benefit
	of software inspections also apply when automated unit tests are
	created by developers working in pair programming mode.},
  owner = {Katia},
  references = {When Does(n’t) Agile Modeling Make Sense?

	Test Driven Development: By Example

	Extreme Programming Explained: Embrace Change

	Balancing Agility and Discipline: A Guide for the Perplexed

	On the Effectiveness of the Test-First Approach to Programming

	Design and Code Inspections to Reduce Errors in Program Development

	Improving the Design of Existing Code

	An encompassing life cycle centric survey of software inspection

	Tool Support for Geographically Dispersed Inspection Teams

	Assessing Test-Driven Development at IBM

	XUnit Test Patterns: Refactoring Test Code

	The Test Automation Manifesto

	Case Study: Extreme Programming in a University Environment

	Experiment about Test-First Programming

	Two controlled experiments concerning the comparison of pair programming
	to peer review

	Extreme Programming from a CMM Perspective

	Letters: Manifesto Elicits Cynicism

	Scaling Agile Methods

	Comparison of Pair Programming to Inspections for Software Defect
	Reduction

	Pair Programming Illuminated

	Strengthening the Case for Pair Programming

	Refactoring Test Code},
  timestamp = {2010.06.22}
}

@ARTICLE{I[32],
    inserir = {true},
  author = {L. Layman},
  title = {Changing students' perceptions: an analysis of the supplementary
	benefits of collaborative software development},
  year = {2006},
  abstract = {Collaborative work has been in use as an instructional tool to increase
	student understanding through collaborative learning and to improve
	student performance in computer science courses. However, little
	work has been done to understand how the act of collaboration, through
	pair programming or group work, impacts a student's knowledge of
	the benefits and difficulties of collaborative work experience in
	collaborative work is essential preparation for professional software
	development. A study was conducted at North Carolina State University
	to assess changes in advanced undergraduate students' perceptions
	of pair programming and collaboration. Student personality types,
	learning styles, and other characteristics were gathered during two
	semesters of an undergraduate software engineering course. The study
	found that, after experiencing pair programming, most students indicated
	a stronger preference to work with another student, believed that
	pairing made them more organized, and believed that pairing saved
	time on homework assignments. Students who disliked their collaborative
	experiences were predominantly reflective learners, introverts, and
	strong coders. Those students also cited that a non-participatory
	partner and difficulties scheduling meeting times outside of the
	classroom were primary reasons for disliking pair programming. Personality
	type and learning style had little effect on the changes in perceptions
	of collaboration.},
  owner = {Katia},
  references = {The Effects of Personality Type on Engineering Student Performance
	and Attitudes

	Learning and Teaching Styles in Engineering Education

	Pair Programming: Student Performance in CS1 with Distributed Pair
	Programming

	Towards Increasing the Compatibility of Student Pair Programmers

	On Understanding the Compatibility of Student Pair Programmers

	People Types and Tiger Stripes

	The MBTI and Individual Pathways in Engineering Design

	The Evidence Remains Stable: The MBTI Predicts Attraction and Attrition
	in an Engineering Program

	Learning Styles and Performance in the Introductory Programming Sequence

	Pair Programming Illuminated

	Building Pair Programming Knowledge through a Family of Experiments},
  timestamp = {2010.06.22}
}

@ARTICLE{E[94],
    inserir = {false},
  author = {L. Layman and L. Williams and L. Cunningham},
  title = {Motivations and measurements in an agile case study},
  year = {2006},
  abstract = {With the recent emergence of agile software development technologies,
	the software community is awaiting sound, empirical investigation
	of the mpacts of agile practices in a live setting. One means of
	conducting such research is through industrial case studies. There
	are a number of influencing factors that contribute to the success
	of such a case study. In this paper, we describe a case study performed
	at Sabre Airline SolutionsTM evaluating the effects of adopting Extreme
	Programming (XP) practices with a team that had characteristically
	plan-driven risk factors. We compare the team's business-related
	results (productivity and quality) to two published sources of industry
	averages. Our case study found that the Sabre team yielded above-average
	post-release quality and average to above-average productivity. We
	discuss our experience in conducting this case study, including specifics
	of how data was collected, the rationale behind our process of data
	collection, and what obstacles were encountered during the case study.
	We identify four factors that potentially impact the outcome of industrial
	case studies: availability of data, tool support, cooperative personnel
	and project status. Recognizing and planning for these factors is
	essential to conducting industrial case studies.},
  owner = {Katia},
  references = {Extreme Programming: First Results from a Controlled Case Study

	Building Knowledge Through Families of Experiments

	Planning Extreme Programming

	Extreme Programming Explained: Embrace Change

	Balancing Agility and Discipline: A Guide for the Perplexed

	Finding Success in Small Software Projects

	Software Metrics: A Rigorous and Practical Approach

	Software Assessments

	Metrics and Models in Software Quality Engineering

	Reliability of Function Point Measurement: A Field Experiment

	Software Metrics: Measurement for Software Process Improvement

	Case Studies for Method and Tool Evaluation

	Preliminary Guidelines for Empirical Research in Software Engineering

	A Coaching Pattern for XP Through Agile Metrics, in Extreme Programming/Agile
	Universe

	Exploring Extreme Programming in Context: An Industrial Case Study

	Extreme Programming: Rapid Development for Web-Based Applications

	Software Engineering Research Revisited

	How to Get the Most out of Extreme Programming/Agile Methods

	Extreme Programming Evaluation Framework for Object-Oriented Languages
	-- Version 1.4

	Toward a Framework for Evaluating Extreme Programming

	Case Study Research: Design and Method

	Culture Conflicts in Software Engineering Technology Transfer

	Experimental Models for Validating Technology},
  timestamp = {2010.06.22}
}

@ARTICLE{I[31],
    inserir = {true},
  author = {L. Layman and L. Williams and J. Osborne and S. Berenson and K. Slaten
	and M. Vouk},
  title = {How and Why Collaborative Software Development Impacts the Software
	Engineering Course},
  year = {2005},
  abstract = {This paper presents the results of an initial quantitative investigation
	to assess a variety of factors that potentially affect the collaborative
	software development experience. This research was conducted with
	119 students in two undergraduate software engineering classes at
	North Carolina State University. A survey was administered where
	students could reflect on their collaborative experiences. We analyzed
	these factors for interrelationships as well as for correlations
	with performance in the course, grade point average, and SAT scores.
	Our findings support the components of the proposed Social Interaction
	Model of Pair Programming. The substantiation of the Social Interaction
	Model of Pair Programming values suggests that they should be considered
	in course planning. We also find that work ethic and self-perceived
	programming ability positively correlate with GPA.},
  owner = {Katia},
  references = {Voices of Women in a Software Engineering Course: Reflections on Collaboration

	Using Pair Programming and Agile Development Methods in a University
	Software Engineering Course to Develop a Model of Social Interactions

	Guidelines for the Use of Pair Programming in a Freshman Programming
	Class

	A Longitudinal Study of Engineering Student Performance and Retention

	Situated Learning: Legitimate peripheral participation

	Unlocking the Clubhouse: Women in Computing

	The Effect of Pair Programming on Performance in an Introductory Programming
	Course

	Improving the CS1 Experience with Pair Programming

	Code Warriors and Code-a-Phobes: A study in attitude and pair programming

	Discourse and Learning in the Classroom: A Sociocultural Approach

	Pair Programming Illuminated

	In Support of Pair Programming in the Introductory Computer Science
	Course},
  timestamp = {2010.06.22}
}

@ARTICLE{E[48],
    inserir = {false},
  author = {N. F. LeJeune},
  title = {Teaching Software Engineering Practices with Extreme Programming},
  year = {2005},
  abstract = {Extreme Programming (XP), one of many models for software development,
	has challenged some traditional software engineering practices while
	taking others to the extreme. The controversial practices raise questions
	about the role of XP in teaching undergraduate software engineering
	courses, especially capstone project courses. Can an XP model for
	software development be successfully used in teaching software engineering
	practices? Specific educational goals for the course are that 1)
	students recognize the strengths and weaknesses of XP as a model
	for software development and 2) that students evaluate XP practices
	in the larger context of other software engineering practices. Students
	should also complete a software development project while following
	a defined set of processes and practices. Students in a 4 credit,
	one-semester software engineering practices course used XP for their
	project. A survey of fifteen practices representing both XP and more
	traditional software engineering practices was given to students
	upon completion of the course to determine the students’ perceptions
	and experiences. Overall, students were successful in using XP for
	their projects. Students liked pair programming, automated testing,
	and test-first and believed it contributed to their success. The
	XP practices of simple design and refactoring did not work well.
	XP’s practices for embracing change accommodates changing requirements,
	design, and code but do not manage change well for the overall goals
	of the product. Survey results and anecdotal evidence suggests that
	108 students were aware of the strengths and weaknesses of XP and
	its relationship to more traditional software engineering practices.},
  owner = {Katia},
  references = {Extreme programming explained: embrace change

	Balancing Agility and Discipline: A Guide for the Perplexed

	Agile software development

	User Stories Applied: For Agile Software Development

	Introducing software engineering by means of Extreme Programming

	Extreme Programming Installed

	Using Extreme Programming in a capstone project

	Extreme Programming: A university team design experience

	Engineering Notebook: An Extreme Programming Episode

	Questioning Extreme Programming

	Object-Oriented and Classical Software Engineering

	Extreme Software Engineering A Hands-On Approach

	Extreme Programming Refactored: The Case Against XP

	Extreme programming examined

	Extreme programming explored

	The Effects of "Pair-Pressure" and "Pair-Learning" on Software Engineering
	Education

	Pair Programming Illuminated},
  timestamp = {2010.06.22}
}

@ARTICLE{E[95],
    inserir = {false},
  author = {N. Lesiecki},
  title = {Applyinq AspectJ to J2EE application development},
  year = {2006},
  abstract = {(AOP) programming is a technique that allows programmers to modularize
	crosscutting concerns (behavior that cuts across the typical divisions
	of responsibility, such as concurrency or security). Aspect-oriented
	programming and the AspectJ language can reduce code size and defects
	while increasing understandability. Video Monitoring Services of
	America (VMS) began to investigate the adoption of AOP into the development
	of Adbase, the Java 2 Enterprise Edition-based application. Adbase
	supplies a Web-based search and e-commerce interface on VMS's library
	of advertising data. It uses a wide range of J2EE technologies, both
	commercial and open source. The Adbase team varied from four to seven
	full-time developers during the time frame covered by this article.
	We followed a modified version of extreme programming with a focus
	on emergent design and adherence to XP practices such as programmer
	testing-and pair programming.},
  owner = {Katia},
  references = {Improve Modularity with Aspect-Oriented Programming

	The AspectJ Programming Guide

	Mastering AspectJ: Aspect-Oriented Programming in Java

	Using AspectJ for Component Integration in Middleware},
  timestamp = {2010.06.22}
}

@ARTICLE{E[96],
    inserir = {false},
  author = {T. Little},
  title = {Value creation and capture: A model of the software development process},
  year = {2004},
  abstract = {Understanding software development dynamics can help managers and
	project team members maximize value delivery. Using functions and
	parameters applied in a spreadsheet, this process model facilitates
	this understanding by examining value creation and value capture
	in the presence of uncertainty. Items to explore include project
	staffing, optimal release dates, and potential impacts of process
	improvements such as pair programming.},
  owner = {Katia},
  references = {Software Project Dynamics

	Software Cost Estimation with COCOMO II

	Valuation of Learning Options in Software Development under Private
	and Market Risk

	Comparative Evaluation of Software Development Strategies Based on
	Net Present Value

	Developing Products in Half the Time: New Rules

	The Mythical Man-Month

	Software Assessments

	Software by Numbers: Low-Risk, High-Return Development

	Extreme Programming Explained: Embrace Change

	First Things First: Prioritizing Requirements

	Business-Driven Product Planning Using Feature Vectors and Increments

	The Economics of Software Development by Pair Programmers

	Analyzing the Cost and Benefit of Pair Programming

	The Costs and Benefits of Pair Programming

	Controlling Software Projects

	Optional Scope Contracts

	Waltzing with Bears},
  timestamp = {2010.06.22}
}

@ARTICLE{E[97],
    inserir = {false},
  author = {G. Luck},
  title = {Subclassing XP: breaking its rules the right way},
  year = {2004},
  abstract = {Extreme programming encourages adoption of all of its practices. In
	practice many projects drop practices. What remains can be an incomplete
	methodology, which is dangerous. This problem can be overcome by
	replacing each removed dropped practice with a compensating practice
	tailored to the circumstances of the project - effectively subclassing
	XP. This experience report recounts the experiences of subclassing
	of XP at Wotif.com, where pair programming was replaced with "pairing"
	and refactoring was replaced with "team refactoring" .},
  owner = {Katia},
  references = {(not available): http://www.computer.org/portal/web/csdl/doi/10.1109/ADEVC.2004.19:
	Subclassing XP: breaking its rules the right way

	(not available): Subclassing XP: breaking its rules the right way

	(not available): Subclassing XP: breaking its rules the right way

	(not available): Subclassing XP: breaking its rules the right way

	(not available): Subclassing XP: breaking its rules the right way

	(not available): Subclassing XP: breaking its rules the right way

	(not available): Subclassing XP: breaking its rules the right way

	(not available): Subclassing XP: breaking its rules the right way

	(not available): Subclassing XP: breaking its rules the right way

	(not available): Subclassing XP: breaking its rules the right way

	(not available): Subclassing XP: breaking its rules the right way},
  timestamp = {2010.06.22}
}

@ARTICLE{E[98],
    inserir = {false},
  author = {K. M. Lui and K. C. C. Chan},
  title = {Pair programming productivity: Novice-novice vs. expert-expert},
  year = {2006},
  abstract = {Agile Software Development methodologies have grown in popularity
	both among academic researchers and industrial practitioners. Among
	the various methodologies or practices proposed, pair programming,
	which is concerned with two programmers collaborating on design,
	coding and testing, has become a controversial focus of interest.
	Even though some success stories have been reported with the use
	of pair-programming in real software development environment, many
	people remain rather skeptical of the claims on pair-programming
	productivity. Previous studies in pair programming have only addressed
	the basic understanding of the productivity of pairs and they have
	not addressed the variation in productivity between pairs of varying
	skills and experience, such as between novice-novice and expert-expert.
	Statistical productivity measurements reported by different researchers
	also seem to lead to contradictory conclusions. Until now, the literature
	has not addressed how those results and experiments were related
	to each other. In this paper, we propose a controlled experiment
	called repeat-programming which can facilitate the understanding
	of relationships between human experience and programming productivity.
	Repeat-programming can be performed when controversial issues in
	non-traditional programming methodologies and development productivity
	need to be investigated into. To illustrate how the proposed empirical
	experiment can put arguable, divisive problems into perspective,
	we have examined the productivity in pair programming as a case study.
	With repeat-programming, we are able to (i) better understand why
	results of previous pair programming control experiments reached
	different conclusions as to the productivity of pair programming
	and (ii) most importantly, present a case in which novice-novice
	pairs against novice solos are much more productive than expert-expert
	pairs against expert solos.},
  owner = {Katia},
  reference = {Cognitive structure in the comprehension and memory of computer programs:
	an investigation of computer program debugging

	Exploring the efficacy of distributed pair programming

	eXtreme Programming Explained: Embrace Change

	Constantine on Peopleware

	Analyzing distributed cognition in software teams: a case study of
	team programming during adaptive software maintenance

	Software Assessment: Reliability, Safety, and Testability

	A transition from partner programming to pair programming—an industrial
	case study

	An initial framework for research on pair programming

	Design Patterns: Elements of Reusable Object-Oriented Software

	Pair programming effect on developers productivity

	Cognition in the Wild

	Extreme programming considered harmful for reliable software

	Selection and evaluation of computer personnel—the research history
	of SIG/CPR

	The impact of pair programming on student performance, perception,
	and persistence

	Knowledge organization and skill differences in computer programmers

	Are reviews an alternative to pair programming?

	Extreme programming from an engineering economics viewpoint

	Case study: extreme programming in a university environment

	Part IV: computer I.Q.—program procedure, Test Your IQ

	Experimental evaluation of pair programming

	Pair programming vs. side-by-side programming

	The case for collaborative programming

	Empirical studies of programming knowledge

	Extreme Programming Refactored: the Case against XP

	Towards the development of a cognitive model of programming: a software
	engineering approach

	Developmental sequences in small groups

	On cognitive informatics

	The Collaborative Software Process

	Strengthening the case for pair programming},
  references = {Cognitive structure in the comprehension and memory of computer programs:
	an investigation of computer program debugging

	Exploring the efficacy of distributed pair programming

	eXtreme Programming Explained: Embrace Change

	Constantine on Peopleware

	Analyzing distributed cognition in software teams: a case study of
	team programming during adaptive software maintenance

	Software Assessment: Reliability, Safety, and Testability

	A transition from partner programming to pair programming—an industrial
	case study

	An initial framework for research on pair programming

	Design Patterns: Elements of Reusable Object-Oriented Software

	Pair programming effect on developers productivity

	Extreme programming considered harmful for reliable software

	Selection and evaluation of computer personnel—the research history
	of SIG/CPR

	The impact of pair programming on student performance, perception,
	and persistence

	Knowledge organization and skill differences in computer programmers

	Extreme programming from an engineering economics viewpoint

	Case study: extreme programming in a university environment

	Experimental evaluation of pair programming

	Pair programming vs. side-by-side programming

	The case for collaborative programming

	Empirical studies of programming knowledge

	Extreme Programming Refactored: the Case against XP

	Towards the development of a cognitive model of programming: a software
	engineering approach

	Developmental sequences in small groups

	On cognitive informatics

	The Collaborative Software Process

	Strengthening the case for pair programming},
  timestamp = {2010.06.22}
}

@ARTICLE{E[99],
    inserir = {false},
  author = {K. M. Lui and K. C. C. Chan},
  title = {Software process fusion: Uniting pair programming and solo programming
	processes},
  year = {2006},
  abstract = {The role of pair programming process in software development is controversial.
	This controversy arises in part from their being presented as alternatives,
	yet it would be more helpful to see them as complementary software
	management tools. This paper describes the application of such a
	complementary model, software process fusion (SPF), in a real-world
	software management situation in China. Pair and solo programming
	are adopted at different stages of the process and according to the
	background of programmers, as appropriate. Unlike the usual practice
	of eXtreme Programming, in which all production code must written
	in pairs, all-the-time pair programming, the proposed model encourages
	programmers to design code patterns of their own in pairs and then
	to use these patterns to build sub-modules solo. The report finds
	that the longer team members work alone, the more code patterns they
	develop for reuse later in pairs.},
  owner = {Katia},
  references = {Extreme Programming Explained: Embraced Change

	Analyzing Distributed Cognition in Software Teams: A Case Study of
	Team Programming During Perfective Software Maintenance

	The Case for Collaborative Programming

	The Collaborative Software Process

	Extreme Programming from an Engineering Economics Viewpoint

	When Does a Pair Outperform Two Individuals

	A Cognitive Model for Solo Programming and Pair Programming

	Productivity of Pair Programming: Novice-Novice and Expert-Expert

	Extreme Programming Refactored: The Case Against XP

	Pair Programming to Facilitate the Training of Newly-Hired Programmers

	Experimental Evaluation of Pair Programming

	Active Learning: Creating Excitement in the Classroom

	Peer Lead Team Learning A Handbook for Team Leaders

	Can Vocabulary-Learning Strategies and Pair-Learning Formats Be Profitably
	Combined?

	Learning and Problem-Solving Transfer between Physics Problems using
	Web-based Homework Tutor

	Using Small Groups to Promote Active Learning in the Introductory
	Statistics Course

	Experimenting with Pair Programming in the Classroom

	The Impact of Pair Programming on Student Performance, Perception,
	and Persistence

	Crystal Clear: a human-powered methodology for small teams

	Why the Information Explosion Can Be Bad for Data Mining, and How
	Data Fusion Provides a Way Out},
  timestamp = {2010.06.22}
}

@ARTICLE{I[33],
    inserir = {true},
  author = {K. M. Lui and K. C. C. Chan},
  title = {Pair programming productivity: Novice-novice vs. expert-expert},
  year = {2006},
  abstract = {Agile Software Development methodologies have grown in popularity
	both among academic researchers and industrial practitioners. Among
	the various methodologies or practices proposed, pair programming,
	which is concerned with two programmers collaborating on design,
	coding and testing, has become a controversial focus of interest.
	Even though some success stories have been reported with the use
	of pair-programming in real software development environment, many
	people remain rather skeptical of the claims on pairprogramming productivity.
	Previous studies in pair programming have only addressed the basic
	understanding of the productivity of pairs and they have not addressed
	the variation in productivity between pairs of varying skills and
	experience, such as between novice–novice and expert–expert. Statistical
	productivity measurements reported by different researchers also
	seem to lead to contradictory conclusions. Until now, the literature
	has not addressed how those results and experiments were related
	to each other. In this paper, we propose a controlled experiment
	called repeat-programming which can facilitate the understanding
	of relationships between human experience and programming productivity.
	Repeat-programming can be performed when controversial issues in
	nontraditional programming methodologies and development productivity
	need to be investigated into. To illustrate how the proposed empirical
	experiment can put arguable, divisive problems into perspective,
	we have examined the productivity in pair programming as a case study.
	With repeat-programming, we are able to (i) better understand why
	results of previous pair programming control experiments reached
	different conclusions as to the productivity of pair programming
	and (ii) most importantly, present a case in which novice–novice
	pairs against novice solos are much more productive than expert–expert
	pairs against expert solos.},
  owner = {Katia},
  references = {Cognitive structure in the comprehension and memory of computer programs:
	an investigation of computer program debugging

	Exploring the efficacy of distributed pair programming. In: Proceedings
	of Extreme Programming and Agile Methods—XP/Agile Universe

	eXtreme Programming Explained: Embrace Change

	Constantine on Peopleware

	Analyzing distributed cognition in software teams: a case study of
	team programming during adaptive software maintenance

	Software Assessment: Reliability, Safety, and Testability

	A transition from partner programming to pair programming—an industrial
	case study

	An initial framework for research on pair programming

	Design Patterns: Elements of Reusable Object-Oriented Software

	Pair programming effect on developers productivity

	Cognition in the Wild

	Selection and evaluation of computer personnel—the research history
	of SIG/CPR

	The impact of pair programming on student performance, perception,
	and persistence

	Knowledge organization and skill differences in computer programmers

	Are reviews an alternative to pair programming?

	Extreme programming from an engineering economics viewpoint

	Case study: extreme programming in a university environment

	Experimental evaluation of pair programming

	Pair programming vs. side-by-side programming

	The case for collaborative programming

	Empirical studies of programming knowledge

	Extreme Programming Refactored: the Case against XP

	Towards the development of a cognitive model of programming: a software
	engineering approach

	Developmental sequences in small groups

	The Collaborative Software Process

	Strengthening the case for pair programming},
  timestamp = {2010.06.22}
}

@ARTICLE{E[100],
    inserir = {false},
  author = {K. M. Lui and K. C. C. Chan},
  title = {When does a pair outperform two individuals?},
  year = {2003},
  abstract = {This paper reports experimental measurements of productivity and quality
	in pair programming. The work complements Laurie Williams' work on
	collaborative programming, in which pair programming and solo programming
	student groups wrote the same programs and then their activities
	were measured to investigate productivity, quality, etc. In this
	paper, pair and solo industrial programmer groups are requested to
	complete algorithm-style aptitude tests so as to observe the capability
	of solving algorithms in singles and in pairs. So doing is independent
	of the familiarity of a programming language. Besides, we also take
	another approach to examining pair programming. A single group of
	industrial programmers carries out alternately pair programming and
	solo programming. All these demonstrate that productivity in pair
	programming hinges upon algorithm design at all levels from understanding
	problems and implementing solutions. In addition, we reach similar
	conclusions to Williams. Our findings indicate that simple design,
	refactoring, and rapid feedback provide an excellent continuous-design
	environment for higher productivity in pair programming.},
  owner = {Katia},
  references = {The Collaborative Software Process

	Pair Programming: Why Have Two Do the Work of One? Extreme Programming
	Perspective

	Swarm Intelligence

	Part IV: Computer I.Q. – Program Procedure Test Your IQ

	Collaborative Learning Enhances Critical Thinking

	Does Instruction in Computer Programming Improve Problem Solving Ability?},
  timestamp = {2010.06.22}
}

@ARTICLE{I[36],
    inserir = {true},
  author = {L. Madeyski},
  title = {On the Effects of Pair Programming on Thoroughness and Fault-Finding
	Effectiveness of Unit Tests},
  year = {2007},
  abstract = {Code coverage and mutation score measure how thoroughly tests exercise
	programs and how effective they are, respectively. The objective
	is to provide empirical evidence on the impact of pair programming
	on both, thoroughness and effectiveness of test suites, as pair programming
	is considered one of the practices that can make testing more rigorous,
	thorough and effective. A large experiment with MSc students working
	solo and in pairs was conducted. The subjects were asked to write
	unit tests using JUnit, and to follow test-driven development approach,
	as suggested by eXtreme Programming methodology. It appeared that
	branch coverage, as well as mutation score indicator (the lower bound
	on mutation score), was not significantly affected by using pair
	programming, instead of solo programming. However, slight but insignificant
	positive impact of pair programming on mutations score indicator
	was noticeable. The results do not support the positive impact of
	pair programming on testing to make it more effective and thorough.
	The generalization of the results is limited due to the fact that
	MSc students participated in the study. It is possible that the benefits
	of pair programming will exceed the results obtained in this experiment
	for larger, more complex and longer projects.},
  owner = {Katia},
  references = {Pair Programming Illuminated

	Extreme Programming Explained: Embrace Change

	Strengthening the Case for Pair Programming

	All I really need to know about pair programming I learned in kindergarten

	Evaluating Pair Programming with Respect to System Complexity and
	Programmer Expertise

	Test Driven Development: By Example

	How to Misuse Code Coverage

	Software Negligence and Testing Coverage

	The Effect of Code Coverage on Fault Detection under Different Testing
	Profiles

	Code Coverage Analysis

	Hints on Test Data Selection: Help for the Practicing Programmer

	Testing Programs with the Aid of a Compiler

	Uniting the Orthogonal. In: Mutation testing for the new century

	Software Unit Test Coverage and Adequacy

	A Measure of Test Case Completeness

	All-Uses vs Mutation Testing: An Experimental Comparison of Effectiveness

	An Experimental Evaluation of Data Flow and Mutation Testing

	Test-Driven Development. A Conversation with Martin Fowler

	Jester a JUnit test tester

	JUnit Project Home Page

	An Experimental Mutation System for Java

	MuJava: A Mutation System for Java

	A mutation analysis tool for Java programs

	Judy mutation testing tool project

	An Experimental Determination of Sufficient Mutant Operators

	Introduction to Software Testing

	The Case for Collaborative Programming

	Experimental Evaluation of Pair Programming

	Pair Programming vs. Sideby-Side Programming

	A Multiple Case Study on the Impact of Pair Programming on Product
	Quality

	Are Reviews an Alternative to Pair Programming?

	Preliminary Analysis of the Effects of Pair Programming and Test-Driven
	Development on the External Code Quality

	The Impact of Pair Programming and Test-Driven Development on Package
	Dependencies in Object-Oriented Design — An Experiment

	Experimentation in Software Engineering: An Introduction

	Is External Code Quality Correlated with Programming Experience or
	Feelgood Factor?

	Experimental and Quasi-Experimental Designs for Generalized Causal
	Inference

	Quasi-Experimentation: Design and Analysis Issues

	Verification of Process Conformance in Empirical Studies of Software
	Development

	Preliminary Guidelines for Empirical Research in Software Engineering

	Using Students as Subjects — A Comparative Study of Students and Professionals
	in Lead-Time Impact Assessment

	Hints for Reviewing Empirical Work in Software Engineering},
  timestamp = {2010.06.22}
}

@ARTICLE{I[35],
    inserir = {true},
  author = {L. Madeyski},
  title = {The impact of pair programming and test-driven development on package
	dependencies in object-oriented design - an experiment},
  year = {2006},
  abstract = {Test-driven development (TDD) and pair programming are software development
	practices popularized by extreme programming methodology. The aim
	of the practices is to improve software quality. Provide an empirical
	evidence of the impact of both practices on package dependencies
	playing a role of package level design quality indicators. An experiment
	with a hundred and eighty eight MSc students from Wroclaw University
	of Technology, who developed finance-accounting system in different
	ways (CS - classic solo, TS - TDD solo, CP - classic pairs, TP -
	TDD pairs). It appeared that package level design quality indicators
	(namely package dependencies in an object-oriented design) were not
	significantly affected by development method. Generalization of the
	results is limited due to the fact that MSc students participated
	in the study. Previous research revealed that using test-driven development
	instead of classic (test-last) testing approach had statistically
	significant positive impact on some class level software quality
	indicators (namely CBO and RFC metrics) in case of solo programmers
	as well as pairs. Combined results suggest that the positive impact
	of test-driven development on software quality may be limited to
	class level.},
  owner = {Katia},
  references = {Test Driven Development: By Example

	Pair Programming Illuminated

	Extreme Programming Explained: Embrace Change

	The case for collaborative programming

	Strengthening the case for pair programming

	The Collaborative Software Process

	Experimental evaluation of pair programming

	Pair Programming vs. Sideby-Side Programming

	Test-Driven Development as a Defect-Reduction Practice

	Assessing Test-Driven Development at IBM

	An Initial Investigation of Test Driven Development in Industry

	A structured experiment of test-driven development

	Preliminary Analysis of the Effects of Pair Programming and Test-Driven
	Development on the External Code Quality

	Experiment about test-first programming

	Are Reviews an Alternative to Pair Programming?

	Software Architecture Improvement through Test-Driven Development

	Implications of Test-Driven Development: A Pilot Study

	An empirical analysis of the impact of pair programming and testdriven
	development on CK design complexity metrics

	A Metrics Suite for Object Oriented Design

	A Multiple Case Study on the Impact of Pair Programming on Product
	Quality

	Test Driven Development

	OO Design Quality Metrics

	Agile Software Development

	Investigating quality factors in object-oriented designs: an industrial
	case study

	The Prediction of Faulty Classes Using Object-Oriented Design Metrics

	Experimentation in Software Engineering: An Introduction

	All I really need to know about pair programming I learned in kindergarten

	On the Effectiveness of the Test-First Approach to Programming

	Experimental and Quasi-Experimental Designs for Generalized Causal
	Inference

	Preliminary Guidelines for Empirical Research in Software Engineering},
  timestamp = {2010.06.22}
}

@ARTICLE{I[68],
    inserir = {true},
  author = {L. Madeyski},
  title = {Is external code quality correlated with programming experience or
	feelgood factor?},
  year = {2006},
  abstract = {This paper is inspired by an article by Muller and Padberg who study
	the feelgood factor and programming experience, as candidate drivers
	for the pair programming performance. We not only reveal a possible
	threat to validity of empirical results presented by Muller and Padberg
	but also perform an independent research. Our objective is to provide
	empirical evidence whether external code quality is correlated with
	the feelgood factor, or with programming experience. Our empirical
	study is based on a controlled experiment with MSc students. It appeared
	that the external code quality is correlated with the feelgood factor,
	and programming experience, in the case of pairs using a classic
	(test-last) testing approach. The generalization of the results is
	limited due to the fact that MSc students participated in the study.
	The research revealed that both the feelgood factor and programming
	experience may be the external code quality drivers.},
  owner = {Katia},
  references = {Pair Programming Illuminated

	Extreme Programming Explained: Embrace Change

	The case for collaborative programming

	Is External Code Quality Correlated with Programming Experience

	Strengthening the case for pair programming

	The Collaborative Software Process

	Experimental evaluation of pair programming

	Pair Programming vs. Sideby-Side Programming

	Test-Driven Development as a Defect-Reduction Practice

	Assessing Test-Driven Development at IBM

	An Initial Investigation of Test Driven Development in Industry

	A structured experiment of test-driven development

	Preliminary Analysis of the Effects of Pair Programming and Test-Driven
	Development on the External Code Quality

	Experiment about test-first programming

	Are Reviews an Alternative to Pair Programming?

	A Multiple Case Study on the Impact of Pair Programming on Product
	Quality

	An empirical study about the feelgood factor in pair programming

	Experimentation in Software Engineering: An Introduction

	All I really need to know about pair programming I learned in kindergarten]

	On the Effectiveness of the Test-First Approach to Programming

	Experimental andQuasi-Experimental Designs for Generalized Causal
	Inference

	Preliminary Guidelines for Empirical Research in Software Engineering

	Comparing detection methods for software requirements inspections:
	A replication using professional subjects

	Experimental context classification: incentives and experience of
	subjects},
  timestamp = {2010.06.22}
}

@ARTICLE{I[34],
    inserir = {true},
  author = {L. Madeyski},
  title = {Preliminary analysis of the effects of pair programming and test-driven
	development on the external code quality},
  year = {2005},
  abstract = {Test-driven development (TDD) and pair programming (PP) are the key
	practices of eXtreme Programming methodology that have caught the
	attention of software engineers and researchers worldwide. On of
	the aims of the large experiments performed at Wroclaw University
	of Technology was to investigate the difference between test-driven
	development and the traditional, tets-last development as well as
	pair programming and solo programming with respect to the external
	code quality. It appeared that the external code quality was lower
	when test-driven development was used instead of the classic, test-last
	software development approach in case of solo programmers (p=0.013).
	There was no difference in the external code quality when pair programming
	was used instead of solo programming.},
  owner = {Katia},
  references = {Test Driven Development: By Example

	Extreme Programming Explained: Embrace Change

	An initial investigation of test driven development in industry

	A structured experiment of test-driven development

	Using students as subjects — a comparative study of students and professionals
	in lead-time impact assessment

	Assessing Test-Driven Development at IBM

	Experiment about test-first programming

	Are reviews an alternative to pair programming?

	Experimental evaluation of pair programming

	The case for collaborative programming

	Experimental and Quasi-Experimental Designs for Generalized Causal
	Inference

	Strengthening the case for pair programming

	The Collaborative Software Process

	Pair Programming Illuminated

	Test-driven development as a defectreduction practice},
  timestamp = {2010.06.22}
}

@ARTICLE{E[101],
    inserir = {false},
  author = {Q. H. Mahmoud and W. Dobosiewicz and D. Swayne},
  title = {Redesigning Introductory Computer Programming with HTML, javascript
	and Java},
  year = {2004},
  abstract = {In this paper we describe our experience in the design and teaching
	of a new evolutionary introductory programming course in a new Distributed
	Computing and Communications Systems Technology program at the University
	of Guelph-Humber. This course is evolutionary and innovative because
	it integrates the use of HTML, JavaScript, and Java in a one-semester
	introductory computer programming course. This is a marked departure
	from the use of a single conventional, general purpose, programming
	language such as Java or C++. The course is designed with two goals
	in mind: to improve the students experience in their first computer
	programming; and to achieve retention in the new program.},
  owner = {Katia},
  references = {Programming for Communication: Overcoming Motivational Barriers to
	Computation for All

	Redesigning introductory computer programming using multi-level online
	modules for a mixed audience

	Improving the CS1 experience with pair programming},
  timestamp = {2010.06.22}
}

@ARTICLE{E[86],
    inserir = {false},
  author = {L. K. Man and K. C. C. Chan},
  title = {A cognitive model for solo programming and pair programming},
  year = {2004},
  abstract = {As eXtreme programming (XP) has grown in popularity in both academia
	and industry, pair programming, two programmers collaborating on
	design, coding and testing, has become a controversial focus of interest.
	Many researchers and practitioners remain skeptical of claims for
	the productivity of pair programming. Three controlled experiments,
	by Nosek, William, and Nawrocki, all reported statistical productivity
	measurements, but the results were inconsistent and the differences
	among the results could not be explained because there exists no
	theoretical framework to articulate pair programming. This paper
	proposes a cognitive model that describes the programming mechanism
	and this in turn can be used to explain why and when a pair may outperform
	two individuals. The model helps explain discrepancies in the results
	of the above-mentioned experiments. To show how the proposed model
	can be applied, a psychological experiment was conducted in which
	twenty-two programmers who were informed only of the experiment and
	the results of Nosek, and of the descriptions of Williams and Nawrocki,
	were able to use our model to predict the possible outcomes of the
	experiments of Williams and Nawrocki .},
  owner = {Katia},
  references = {(not available): http://www.computer.org/portal/web/csdl/doi/10.1109/COGINF.2004.1327463

	(not available): A cognitive model for solo programming and pair programming

	(not available): A cognitive model for solo programming and pair programming

	(not available): A cognitive model for solo programming and pair programming

	(not available): A cognitive model for solo programming and pair programming

	(not available): A cognitive model for solo programming and pair programming

	(not available): A cognitive model for solo programming and pair programming

	(not available): A cognitive model for solo programming and pair programming

	(not available): A cognitive model for solo programming and pair programming

	(not available): A cognitive model for solo programming and pair programming

	(not available): A cognitive model for solo programming and pair programming},
  timestamp = {2010.06.22}
}

@ARTICLE{E[102],
    inserir = {false},
  author = {G. Mangalaraj},
  title = {Influence of codified knowledge on software design task performance:
	A comparison of pairs with individuals},
  year = {2006},
  abstract = {The need to improve the success rates of software development projects
	has prompted the software engineering community to come-up with various
	initiatives. These initiatives include: new software development
	processes such as Extreme Programming (XP), leveraging the development
	process by reusing existing knowledge of software artifacts. XP utilizes
	pairs in the performance of various software development tasks. Moreover,
	development of software applications is a knowledge intensive process
	that utilizes both tacit and explicit knowledge. This experimental
	study utilized software development professionals as subjects and
	manipulated the iv mode of participation (individual or pairs) and
	availability of codified knowledge (design patterns). Results of
	the study indicate that the performance of collaborating pairs were
	better than the 2nd best individual in nominal pairs. Collaborating
	pairs also took more time than the average time taken by nominal
	pairs to complete the task and they were more satisfied than the
	individuals. This study also found that the codified knowledge in
	the form of design patterns helped in arriving at a better solution.
	One interesting finding of this study is the effect of design self-efficacy/collective-efficacy
	on task performance.},
  owner = {Katia},
  references = {The role of prior experience and task characteristics in object-oriented
	modeling: An empirical study

	Review: Knowledge management and knowledge management systems: Conceptual
	foundations and research issues

	Evaluation of effects of pair work on quality of designs

	Survey Says: Agile Works in Practice

	Organizational learning: creating, retaining, and transferring knowledge

	Knowledge transfer in organizations: Learning from the experience
	of others

	Managing knowledge in organizations: An integrative framework and
	review of emerging themes

	The development of collective efficacy in small task groups

	Task complexity and effectiveness of pair programming: an experimental
	study

	Social foundations of thought and action: a social cognitive theory

	The Moderator Mediator Variable Distinction in Social Psychological-Research
	- Conceptual, Strategic, and Statistical Considerations

	Conceptual data modeling patterns: Representation and validation

	Extreme programming explained : embrace change

	Industrial experience with design patterns

	Knowledge, knowledge work and organizations: An overview and interpretation

	A taxonomy of software development methods

	Balancing agility and discipline : a guide for the perplexed

	Social Facilitation - a Meta-Analysis of 241 Studies

	Theories of learning

	A Dynamic Model of Group Performance: Considering the Group Members'
	Capacity To Learn

	Communication and performance in software development projects

	Group processes : dynamics within and between groups

	Relations between Work Group Characteristics and Effectiveness - Implications
	for Designing Effective Work Groups

	The pros and cons of adopting and applying design patterns in the
	real world

	Object-Oriented Patterns

	The Costs and Benefits of Pair Programming

	A Power Primer

	A social psychology of group processes for decision making

	Computer Self-Efficacy - Development of a Measure and Initial Test

	Pattern languages of program design

	Group vs. Individual Performance in a Price-Searching Experiment

	Productivity loss in brainstorming groups: Toward the solution of
	riddle

	Coordinating Expertise in Software Development Teams

	Determinants and Structural Relation of Personal Efficacy to Collective
	Efficacy

	How a Cockpit Remembers Its Speeds

	Teams in organizations: From input-process-output models to IMOI models

	The role of similarity in the reuse of object-oriented analysis models

	Socialization Tactics, Self-Efficacy, and Newcomers Adjustments to
	Organizations

	Knowledge transfer between groups via personnel rotation: Effects
	of social identity and knowledge quality

	Contributing knowledge to electronic knowledge repositories: An empirical
	investigation

	When collective- and self-efficacy affect team performance

	Mututal knowledge and communicative effectiveness

	Software Reuse

	Applying UML and patterns : an introduction to object-oriented analysis
	and design and iterative development

	Groups as Problem-Solving Units - toward a New Meaning of Social Cognition

	Groups perform better than the best individuals on Letters-to-Numbers
	problems

	Demonstrability and Social Combination Processes on Mathematical Intellective
	Tasks

	Groups perform better than the best individuals on letters-to-numbers
	problems: effects of group size

	Collective Individual Induction: Recognition of Truth, Rejection of
	Error, and Collective Information Processing

	Self-Efficacy Beliefs - Comparison of 5 Measures

	Eta squared, partial eta squared, and misreporting of effect size
	in communication research

	An Input-Process-Output Analysis of Influence and Performance in Problem-Solving
	Groups

	The nature and causes of job satisfaction," In Handbook of industrial
	and organizational psychology

	Knowledge reuse for innovation

	Toward a theory of knowledge reuse: Types of knowledge reuse situations
	and factors in reuse success

	Group problem solving

	Agile software development : principles, patterns, and practices

	Knowledge management with patterns

	In Handbook of human-computer interaction

	Reusing Software - Issues and Research Directions

	De-escalating information technology projects: lessons from the denver
	international airport

	Success and failure factors in software reuse

	An examination of procedural and objectoriented systems analysis methods:
	Does prior experience help or hinder performance?

	The impact of perceived loafing and collective efficacy on group goal
	processes and group performance

	Applied linear statistical models

	Human problem solving

	The illusion of group productivity: a reduction of failures explanation

	A Dynamic Theory of Organizational Knowledge Creation

	The knowledge-creating company

	The Case for Collaborative Programming

	Effects of four modes of group communication on the outcomes of software
	requirements determination

	Self-construals, communication processes, and group outcomes in homogeneous
	and heterogeneous groups

	A field study of developer pairs: Productivity impacts and implications

	Cognitive heuristics in software engineering: Applying and extending
	anchoring and adjustment to artifact reuse

	Why we still have to be reductionists about group memory

	A comparison of individuals and small groups in the rational solution
	to complex problems

	The structure of ill structured problems

	The transfer of cognitive skill

	The reluctance to report bad news on troubled software projects: a
	theoretical model

	Excellent performance: The role of communication and cooperation processes

	The influence of query interface design on decisionmaking performance

	Self-efficacy and work-related performance: A metaanalysis

	Extreme Chaos

	Discovery of Hidden Profiles by Decision-Making Groups - Solving a
	Problem Versus Making a Judgment

	Pooling of Unshared Information in Group Decision-Making - Biased
	Information Sampling During Discussion

	Using mentoring and storytelling to transfer knowledge in the workplace

	Leader and staff role-efficacy as antecedents of collectiveefficacy
	and team performance

	Who's really sharing? Effects of social and expert status on knowledge
	exchange within groups

	Avoiding missed opportunities in managerial life: Analogical training
	more powerful than individual case training

	An empirical study of the effect of knowledge integration on software
	development performance

	Expertise integration and creativity in Information Systems Development,

	The dynamogenic factors in pacemaking and competition

	Communication Enhances Small-Group Performance If It Conforms to Task
	Requirements - the Concept of Ideal Communication Cycles

	Software projects risks and their effect on outcomes

	Inside a software design team: Knowledge acquisition, sharing, and
	integration

	Assessing group efficacy - Comparing three methods of measurement

	Strengthening the case for pair programming

	All I Really Need to Know About Pair Programming I Learned in Kindergarten

	Social Cognitive Theory of Organizational Management

	High-performing self-managed work teams : a comparison of theory to
	practice

	Developing and Validating an Observational Learning Model of Computer
	Software Training and Skill Acquisition

	Collective Efficacy," In Selfefficacy, adaptation, and adjustment
	: theory, research, and application

	Social facilitation

	Interruptive events and team knowledge acquisition},
  timestamp = {2010.06.22}
}

@ARTICLE{E[103],
    inserir = {false},
  author = {S. Matzko and T. Davis},
  title = {Pair Design in Undergraduate Labs},
  year = {2006},
  abstract = {Pair programming is widely recognized as a successful method of improving
	student competence in computer science while lowering dependence
	on teaching staff. In this paper, we propose an approach based on
	pair programming, termed pair design, that reinforces program design
	and testing skills in addition to collaboration. We describe the
	approach and our results in applying it to freshmen and sophomore
	laboratory environments.},
  owner = {Katia},
  references = {Teaching introductory computer science as the science of algorithms

	The power of problem-based learning

	Teaching design effectively in the introductory programming courses

	Program quality with pair programming in CS1

	Programming versus design (poster): teaching first year students

	The impact of pair programming on student performance, perception
	and persistence

	Designing intentional learning environments

	Investigating pair-programming in a 2nd-year software development
	and design computer science course

	Constructivism in computer science education

	Strengthening the Case for Pair Programming

	In support of student pair-programming},
  timestamp = {2010.06.22}
}

@ARTICLE{E[104],
    inserir = {false},
  author = {F. Maurer},
  title = {Supporting distributed extreme programming},
  year = {2002},
  abstract = {Extreme programming (XP) is arguably improving the productivity of
	small, co-located software development teams. In this paper, we described
	an approach that tries to overcome the XP constraint of co-location
	by introducing a process-support environment (called MILOS for Agile
	Software Engineering-MILOS ASE) that helps software development teams
	to maintain XP practices in a distributed setting. MILOS ASE supports
	project coordination using the planning game, user stories, information
	routing, team communication, and pair programming.},
  owner = {Katia},
  references = {About the Apache HTTP Server Project

	Process Modeling-in-the-large with SLANG

	Extreme Programming Explained: Embrace Change

	Planning Extreme Programming

	EPOS: Object-Oriented and Cooperative Process Modeling

	Process modeling

	Change Impact Analysis Support for Software Development Processes

	Process-centered Software Engineering Environments

	Task-Specific Knowledge Management in a Process-Centred SEE

	Extreme Programming Installed

	Intelligent Assistance for Software Development and Maintenance

	Distributed eXtreme Programming

	Flexible Work Arrangements and 21st Century Worker's Guilds

	The Dawn of the E-Lance Economy

	Merging Project Planning and Web-Enabled Dynamic Workflow Technologies

	Extreme Programming in Practice

	Software Processes are Software Too

	A Knowledge-based Software Development Environment Supporting Cooperative
	Work

	A Practitioner's Approach},
  timestamp = {2010.06.21}
}

@ARTICLE{I[38],
    inserir = {true},
  author = {C. McDowell and B. Hanks and L. Werner},
  title = {Experimenting with pair programming in the classroom},
  year = {2003},
  abstract = {There is now a substantial body of evidence in support of the use
	of pair programming in the classroom. Some of the data is anecdotal
	and some is the result of formal experiments. We are not aware of
	any published data that raises concerns about allowing students to
	complete programming projects using pair programming. In this paper
	we present data from three studies performed at UCSC. All three studies
	support the position that pair programming results in more student
	learning.},
  owner = {Katia},
  references = {Extreme Programming Explained: Embrace Change

	Guidelines for the Use of Pair Programming in a Freshman Programming
	Class

	The Effects of Pair-Programming on Performance in an Introductory
	Programming Course

	The Impact of Pair Programming on Student Performance and Pursuit
	of Computer Science Related Majors

	Improving the CS1 Experience with Pair Programming

	The Case for Collaborative Programming

	Student Perceptions of the Suitability of Extreme and Pair Programming

	Code Warriors and Code-a-Phobes: A Study in Attitude and Pair Programming

	Strengthening the Case for Pair Programming

	In Support of Student Pair-Programming

	In Support of Pair Programming in the Introductory Computer Science
	Course

	All I Really Need to Know About Pair Programming I Learned in Kindergarten

	The Effects of "Pair-Pressure" and "Pair-Learning" on Software Engineering
	Education

	Experiments with Industry's "Pair-Programming" Model in the Computer
	Science Classroom},
  timestamp = {2010.06.22}
}

@ARTICLE{I[37],
    inserir = {true},
  author = {C. McDowell and L. Werner and H. Bullock and J. Fernald},
  title = {The effects of pair-programming on performance in an introductory
	programming course},
  year = {2002},
  abstract = {The purpose of this study was to investigate the effects of pair-programming
	on student performance in an introductory programming class. Data
	was collected from approximately 600 students who either completed
	programming assignments with a partner or programmed independently.
	Students who programmed in pairs produced better programs, completed
	the course at higher rates, and performed about as well on the final
	exam as students who programmed independently. Our findings suggest
	that collaboration is an effective pedagogical tool for teaching
	introductory programming.},
  owner = {Katia},
  references = {Individual Differences in Dyadic Cooperative Learning

	Scripted Cooperation in Student Dyads: A Method for Analyzing and
	Enhancing Academic Learning and Performance

	Research on Cooperative Learning and Achievement: When We Know, What
	We Need to Know

	Cooperative Learning

	The Costs and Benefits of Pair Programming

	Advances in Software Inspections

	The Empirical Investigation of Perspective-Based Reading

	Team-Oriented Software Practicum

	The Effectiveness of Software Development Technical Review: A Behaviorally
	Motivated Program of Research

	The Effects of 'Pair-Pressure' and 'Pair-Learning' on Software Engineering
	Education

	Analyzing Distributed Cognition in Software Teams: A Case Study of
	Team Programming During Perfective Software Maintenance

	Distributed Cognitions: Psychological and Educational Considerations

	Constantine on Peopleware

	A Development Process Generative Pattern Language

	Extreme Programming Explained: Embrace Change

	Strengthening the Case for Pair-Programming

	The Case for Collaborative Programming

	Chrysler Goes to Extremes

	Experimenting with Industry' s 'Pair-Programming' Model in the Computer
	Science Classroom

	Pair Programming Questionnaire},
  timestamp = {2010.06.21}
}

@ARTICLE{E[105],
    inserir = {false},
  author = {C. McDowell and L. Werner and H. E. Bullock and J. Fernald},
  title = {Pair programming improves student retention, confidence, and program
	quality},
  year = {2006},
  abstract = {A study was conducted to investigate the effects of pair programming
	on student performance and subsequent pursuit of computer science-related
	degrees among both female and male college students taking an introductory
	programming course designed for computer science-related majors.
	The study provides some of the most compelling evidence to date of
	the effectiveness of pair programming as a pedagogical tool. Pairing
	was found to bolster course completion and consequently course pass
	rates, and contribute to greater persistence in computer science-related
	majors. Students who paired were more likely to pass the subsequent
	programming course that required them to work alone. This is a strong
	indication that pairing did not result in a significant number of
	students passing the course without learning how to program due to
	a "free ride" from their partner. The pairing students also produce
	higher quality programs, are more confident in their work, and enjoy
	it more.},
  owner = {Katia},
  references = {Extreme programming explained: embrace change

	Program quality with pair programming in CS1

	The effects of pair-programming on performance in an introductory
	programming course

	The impact of pair programming on student performance, perception
	and persistence

	Pair-programming helps female computer science students

	All I really need to know about pair programming I learned in kindergarten

	The Effects of "Pair-Pressure" and "Pair-Learning" on Software Engineering
	Education

	Strengthening the Case for Pair Programming

	Building Pair Programming Knowledge through a Family of Experiments},
  timestamp = {2010.06.22}
}

@ARTICLE{I[39],
    inserir = {true},
  author = {C. McDowell and L. Werner and H. E. Bullock and J. Fernald},
  title = {The Impact of Pair Programming on Student Performance, Perception
	and Persistence},
  year = {2003},
  abstract = {This study examined the effectiveness of pair programming in four
	lecture sections of a large introductory programming course. We were
	particularly interested in assessing how the use of pair programming
	affects student performance and decisions to pursue computer science
	related majors. We found that students who used pair programming
	produced better programs, were more confident in their solutions,
	and enjoyed completing the assignments more than students who programmed
	alone. Moreover, pairing students were significantly more likely
	than non-pairing students to complete the course, and consequently
	to pass it. Among those who completed the course, pairers performed
	as well on the final exam as non-pairers, were significantly more
	likely to be registered as computer science related majors one year
	later, and to have taken subsequent programming courses. Our findings
	suggest that not only does pairing not compromise students' learning,
	but that it may enhance the quality of their programs and encourage
	them to pursue computer science degrees.},
  owner = {Katia},
  references = {Extreme Programming Explained: Embrace Change

	Strengthening the Case for Pair Programming

	The Effects of Pair-Programming on Performance in an Introductory
	Programming Course

	The Case for Collaborative Programming

	All I Really Need to Know About Pair Programming I Learned in Kindergarten

	The Effects of "Pair-Pressure" and "Pair-Learning" on Software Engineering
	Education},
  timestamp = {2010.06.22}
}

@ARTICLE{E[106],
    inserir = {false},
  author = {D. McKinney and L. F. Denton},
  title = {Developing collaborative skills early in the CS curriculum in a laboratory
	environment},
  year = {2006},
  abstract = {The research on teaching and learning over the past 50 years suggests
	that the early use of collaborative learning leads to higher interest,
	higher retention, and higher academic performance in students. Early
	use of these techniques can also increase the sense of belonging
	for students and can lead to the early development of collaborative
	skills to prepare students for team experiences in subsequent courses
	and future careers. During the weekly lab sessions of a second semester
	introduction to programming course students engaged in collaborative
	learning experiences through team-based problem solving, project
	planning, pair programming, and other agile software development
	practices. Course objectives provided specific goals and criteria
	for assessment relative to these skills. The assessment in the authors'
	prior work identified several problem areas which led to specific
	initiatives to address those problems: (a) instructor-chosen teams;
	(b) early instruction and reflection on team skills; (c) feedback
	on team performance; and (d) the use of an IDE that incorporates
	an automated test-driven development tool. This paper describes the
	implementation and assessment of these efforts. A significant increase
	in student team skills from the middle of the semester to the end
	of the semester was observed.},
  owner = {Katia},
  references = {The College Environment

	Defensive climate in the computer science classroom

	Collaborative Learning Techniques: A Handbook for College Faculty

	Planning Extreme Programming

	Seven Principles for Good Practices in Undergraduate Education

	Promoting Student Achievement with Integrated Affective Objectives

	Integrated Use of Bloom and Maslow for Instructional Success in Technical
	and Scientific Fields

	Affective Factors and Student Achievement: A Quantitative and Qualitative
	Study

	A Melding of Educational Strategies to Enhance the Introductory Programming
	Course

	A cognitive-based approach to introductory computer science courses:
	lesson learned

	The ABC's of Engineering Education: ABET, Bloom's Taxonomy

	A Longitudinal Study of Engineering Student Performance and Retention

	The Impact of College on Students

	National Survey of Student Engagement: National Benchmarks of Effective
	Educational Practice

	Affective Objectives in a Programming Languages Course

	Making the Most of College

	Teaching and learning in the college classroom: A review of the research
	literature

	Affective assessment of team skills in agile CS1 labs: the good, the
	bad, and the ugly

	Agile CS1 Labs: eXtreme Programming Practices in an Introductory Programming
	Course

	We have a problem: there's a leak in the CS1 affective oxygen tank

	Turning Student Groups in to Effective Teams

	How College Affects Students

	Re-engineering Female Friendly Science

	Effects of Small-Group Learning on Undergraduates in Science

	Talking About Leaving: Why Undergraduates Leave the Sciences

	Leaving College: Rethinking the Causes and Cures of Student Attrition},
  timestamp = {2010.06.22}
}

@ARTICLE{E[107],
    inserir = {false},
  author = {M. Melis and I. Turnu and A. Cau and G. Concas},
  title = {Evaluating the impact of test-first programming and pair programming
	through software process simulation},
  year = {2006},
  abstract = {In this article, we present a simulation model that we developed for
	exploring the influence of two key extreme programming (XP) practices
	test-first programming and pair programming - on the evolution of
	an XP software project. We present the results obtained simulating
	a typical XP project changing the usage levels of the two practices.
	We focused on output variables related to effort, size, quality and
	released functionalities.},
  owner = {Katia},
  references = {Extreme Programming Explained: Embrace Change

	Test Driven Development: By Example

	Extreme Programming Explained: Embrace Change- Second Edition

	Developing small-scale application software products: Some experiment
	results

	Extreme programming applied: a case in the private banking domain

	Using actual time: learning how to estimate

	Extreme programming faq

	Christopher browne's web pages-computer languages: Smalltalk

	A modeling dynamics of agile software development

	The costs and benefits of pair programming

	Testing Extreme Programming

	Results of delphi for the defect introduction model

	On the effectiveness of the test-first approach to programming

	Software Metrics: A Rigorous and Practical Approach

	An initial investigation of test driven development in industry

	A multiple case study on the impact of pair programming on product
	quality

	Measuring programming quality and productivity

	Pair programming: An alternative to reviews and inspections?

	Software process simulation modeling: Why? What? How?

	Tracking-a working experience

	The smalltalk simulation environment.

	The effects of individual xp practices on software development effort

	A system dynamics simulation model to find the effects of xp on cost
	of change curve

	A model of the software development process using both continuous
	and discrete models

	Extreme dynamics: Towards a system dynamics model of the extreme programming
	software development process

	Experiment about test-first programming

	Experimental evaluation of pair programming

	The case for collaborative programming

	Analyzing the cost and benefit of pair programming

	A refactoring tool for Smalltalk

	Interview to Alistair Cockburn on programming productivity

	Interview to Ron Jeffries on programming productivity

	Supporting decision-making in software engineering with process simulation
	and empirical studies

	The Handbook of Parametric and Nonparametric Statistical Procedures

	Software Reliability

	Simulation modeling in an object-oriented environment using smalltalk-80

	The effects of extreme programming on productivity, cost of change
	and learning efficiency

	Using design of experiments, sensitivity analysis, and hybrid simulation
	to evaluate changes to a software development process: a case study

	Pair programming illuminated, Overcoming Management Resistance to
	Pair Programming

	Test-driven development as a defect-reduction practice

	Integrating unit testing into a software development teams process

	Object Oriented Simulation: Reusability, Adaptability, Maintainability},
  timestamp = {2010.06.22}
}

@ARTICLE{E[108],
    inserir = {false},
  author = {G. Melnik and F. Maurer},
  title = {A Cross-program investigation of students' perception of agile methods},
  year = {2005},
  abstract = {Research was conducted on using agile methods in software engineering
	education. This paper explores the perceptions of students from five
	different academic levels of agile practices. Information has been
	gathered through the collection of quantitative and qualitative data
	over three academic years, and analysis reveals student experiences,
	mainly positive but also some negative. Student opinions indicate
	the preference to continue to use agile practices at the workplace
	if allowed. A way these findings may potentially be extrapolated
	to the industrial settings is discussed. Finally, this report should
	encourage other academics considering adoption of agile methods in
	their computer science or software engineering curricula.},
  owner = {Katia},
  references = {A Tail of Two Projects: How 'Agile' Methods Succeeded after 'Traditional'
	Methods Had Failed in a Critical System-Development Project

	Get Ready for Agile Methods, with Care

	Balancing Agility and Discipline: A Guide for the Perplexed

	Using Academic Courses for Empirical Validation of Software Development
	Processes

	Agile Software Development: The Business of Innovation

	Using Students as Subjects—A Comparative Study ofStudents and Professionals
	in Lead-Time Impact Assessment

	Comments on eXtreme Programming

	Introducing Agile Methods in Learning Environments: Lessons Learnt

	Introducing Agile Methods: Three Years of Experience

	Suitability of FIT User Acceptance Tests for Specifying Functional
	Requirements: Developer Perspective

	Extreme Programming Refactored: The Case Against XP},
  timestamp = {2010.06.22}
}

@ARTICLE{E[109],
    inserir = {false},
  author = {G. Melnik and F. Maurer},
  title = {Introducing agile methods: three years of experience},
  year = {2004},
  abstract = {The paper summarizes three years of experience of introducing agile
	practices in academic environments. The perceptions of students from
	four different academic programs (Diploma, Applied Bachelor's, Bachelor's
	and Master's) from two institutions are analyzed. Specifically, pair
	programming, test-driven development and project planning using the
	planning game were studied in detail. Overwhelmingly, students' experiences
	are positive and their opinions indicate the preference to continue
	to use agile practices if allowed. No major problems with agile techniques
	appeared in the evaluation contexts and benefits in these contexts
	have been seen.},
  owner = {Katia},
  references = {A Tail of Two Projects: How ‘Agile’ Methods Succeeded after ‘Traditional’
	Methods Had Failed in a Critical System-Development Project

	Balancing Agility and Discipline: A Guide for the Perplexed

	Agile Software Development: The Business of Innovation

	Comments on eXtreme Programming

	What is Extreme Programming

	Introducing Agile Methods in Learning Environments: Lessons Learnt

	Learning to Research about learning

	Users Warm Up to Agile Programming

	Extreme Programming Refactored: The Case Against XP},
  timestamp = {2010.06.22}
}

@ARTICLE{I[41],
    inserir = {true},
  author = {E. Mendes and L. B. Al-Fakhri and A. Luxton-Reilly},
  title = {A replicated experiment of pair-programming in a 2nd-year software
	development and design computer science course},
  year = {2006},
  abstract = {This paper presents the results of a replicated pair programming experiment
	conducted at the University of Auckland (NZ) during the first semester
	of 2005. It involved 190 second year Computer Science students attending
	a software design and construction course. We replicated the experiment
	described by Mendes et al. (2005), investigating similar issues to
	those reported Williams et al. (2003) and employing a subset of the
	questionnaires used by Williams et al. Our results confirm the use
	of pair programming as an effective programming/design learning technique.},
  owner = {Katia},
  references = {Balancing depth and breadth in the data structures course

	Cooperative learning techniques in CS1: design and experimental evaluation

	Guidelines for the use of pair programming in a freshman programming
	class

	Lessons learned about distributed pair programming: what are the knowledge
	needs to address?

	Experiences with pair programming at a small college

	Pair programming and pair trading: effects on learning and motivation
	in a CS2 course

	An initial framework for research on pair programming

	A pair-programming experiment in a non-programming course

	Student performance in CS1 with distributed pair programming

	Program quality with pair programming in CS1

	Pair programming on the C3 project

	An overview of cooperative learning

	Towards increasing the compatibility of student pair programmers

	Paired programming/ collaborative learning: On understanding compatibility
	of student pair programmers

	The impact of pair programming on student performance, perception
	and persistence

	Experimenting with pair programming in the classroom

	The effects of pairprogramming on performance in an introductory programming
	course

	Investigating Pair Programming in a 2nd year Software Development
	and Design Computer Science Course

	Improving the CS1 experience with pair programming

	Distributed pair programming on the Web

	Pair programming as a model of collaborative learning: a review of
	the research

	On pair rotation in the computer science course

	Code warriors and code-a-phobes: a study in attitude and pair programming

	Coupling pair programming and writing: learning about students' perceptions
	and processes

	Pair-programming helps female computer science students

	But, isn't that cheating?

	Integrating pair programming into a software development process

	The effects of "pair-pressure" and "pairlearning" on software engineering
	education

	All I really need to know about pair programming I learned in kindergarten

	In support of student pair-programming

	Strengthening the case for pair programming

	Building pair programming knowledge through a family of experiments

	Pair Learning in Undergraduate Computer Science Education},
  timestamp = {2010.06.22}
}

@ARTICLE{I[40],
    inserir = {true},
  author = {E. Mendes and L. B. Al-Fakhri and A. Luxton-Reilly},
  title = {Investigating pair-programming in a 2nd-year software development
	and design computer science course},
  year = {2005},
  abstract = {This paper presents the results of a pair programming experiment conducted
	at the University of Auckland (NZ) during the first semester of 2004.
	It involved 300 second year computer science students attending a
	software design and construction course. We investigated similar
	issues to those reported by L. Williams et al., (2003) and employed
	a subset of the questionnaires used on the experiments presented.
	Our results support the use of pair programming as an effective programming/design
	learning technique.},
  owner = {Katia},
  references = {Guidelines for the use of pair programming in a freshman programming
	class

	Lessons learned about distributed pair programming: what are the knowledge
	needs to address?

	Experiences with pair programming at a small college

	Pair programming and pair trading: effects on learning and motivation
	in a CS2 course

	An initial framework for research on pair programming

	A pair-programming experiment in a nonprogramming course

	Program quality with pair programming in CS1

	Pair programming on the C3 project

	Paired programming/ collaborative learning: On understanding compatibility
	of student pair programmers

	A cognitive model for solo programming and pair programming

	The impact of pair programming on student performance, perception
	and persistence

	Experimenting with pair programming in the classroom

	The effects of pair-programming on performance in an introductory
	programming course

	Improving the CS1 experience with pair programming

	Distributed pair programming on the Web

	Analyzing the cost and benefit of pair programming

	On pair rotation in the computer science course

	Code warriors and code-a-phobes: a study in attitude and pair programming

	Coupling pair programming and writing: learning about students' perceptions
	and processes

	But, isn't that cheating?

	Integrating pair programming into a software development process

	The effects of "pair-pressure" and "pair-learning" on software engineering
	education

	All I really need to know about pair programming I learned in kindergarten

	In support of student pairprogramming

	Strengthening the case for pair programming

	Building pair programming knowledge through a family of experiments},
  timestamp = {2010.06.22}
}

@ARTICLE{E[110],
    inserir = {false},
  author = {E. Mentz and L. Goosen},
  title = {Are groups working in the Information Technology class?},
  year = {2007},
  abstract = {We discuss teachers' perception of the use of group work in the Information
	Technology (IT) classroom. We describe the current situation regarding
	the implementation of group work in IT classrooms in South Africa
	as well as the challenges that IT teachers face when implementing
	group work. This information will be used in further research to
	develop a training model for teachers and student teachers, which
	should enable them to apply group work effectively in the IT classroom.},
  owner = {Katia},
  references = {Collaborative learning in biology: Debating the ethics of recombinant
	DNA Technology

	Groups in Process. A n introduction to small group communication

	Embedding co-operative learning into the design of integrated learning
	systems: Rationale and guidelines

	National Curriculum Statements Grades 10-12 (General) Learning programme
	guidelines

	Co-operative learning: Students working in small groups

	A practical approach to integrating active and collaborative learning
	into the introductory Computer Science curriculum

	Program quality with pair programming in CS1

	Positive interdependence. Key to effective cooperation

	An overview of co-operative learning

	Co-operative Learn ing Method s: A Meta-Analysis

	Are pupils equipped for groupwork without training or 342 Mentz &
	Goosen instruction?

	From co-operation to collaboration: Helping students become collaborative
	learners

	Co-operativ e-Learning : The social and intellectual outcomes of learning
	in groups

	Exploring student responses to collaborating and learning in a web-based
	environment

	A definition of collaborative vs. co-operative learning

	Co-operative vs. collaborative

	Research on co-operative learning and achievement: What we know, what
	we need to know

	Learning to co-operate: A teacher’s perspective

	The effect of functional roles on grou p efficiency: Using multilevel
	modelling and content an alysis to investigate computer-supported
	collaboration in small groups

	Coupling pair programming and writing: Learning about students’ perceptions
	and processes

	Group work in higher education: a mismanaged evil or a potential good?

	Co-operative learning and teacher education

	The handbook for economics lecturers: Groupwork and assessment

	Student culture vs. groupwork in computer science

	Collaborative group versus individual assessm ent in mathematics:
	Processes and outcomes

	Overcoming difficulties in pair and group work

	Collaboration vs. co-operation

	In support o f pair programming in the introductory computer science
	course

	Guidelines for collaborative learning in computer science},
  timestamp = {2010.06.22}
}

@ARTICLE{E[111],
    inserir = {false},
  author = {K. W. Miller and D. K. Larson},
  title = {Agile software development: human values and culture},
  year = {2005},
  abstract = {Software engineers need to know how to evaluate different methods
	of developing software. A group of new development methods have emerged
	under the general label "agile development." These techniques are
	sometimes called "light weight" as opposed to "heavy weight" techniques
	such as those based on the waterfall model. Two classic ethical techniques
	- utilitarian and deontological analyses - can offer insights into
	the arguments surrounding, agile methods. These and other applied
	ethics techniques offer software engineers a more precise language
	for articulating their ideas about software engineering issues that
	involve human values.},
  owner = {Katia},
  references = {The Culture of Technology

	Cross-cultural software production and use: A structural analysis

	Technology Transfer: Strategic Management in Developing Countries

	The Linux Operating System

	Linux and the Developing World

	Linux in India

	Economics of Linux adoption in developing countries

	Riding the Waves of Culture

	Culture’s Consequences

	Culture and technology: Does the traffic move in both directions?

	Software localization: The art of turning Japanese

	Software localization on Windows

	Requisite variety: A concept to analyze the effects of cultural context
	for technology transfer

	Closed society, open source: China’s unexpected enthusiasm for Linux},
  timestamp = {2010.06.22}
}

@ARTICLE{E[112],
    inserir = {false},
  author = {R. W. Miller},
  title = {When Pairs Disagree, 1-2-3},
  year = {2002},
  abstract = {Pair programming requires two programmers to work together to solve
	the same problem. These programmers probably have opinions about
	most design decisions (method names, and anything else that comes
	up during a pairing session). Some of those opinions are stronger
	than others. It is quite likely that those opinions will differ,
	sometimes often. When they do, there needs to be a simple way to
	resolve the conflict. Arguing doesn't work, and helps no one. When
	a disagreement about how to proceed comes up, each pair should score
	his opinion on a scale of 1-3. The highest score dictates what the
	pair does next. In the event of a tie, the pair should discuss the
	various options, agree to disagree, pick one, and move on. This simple
	approach works.},
  owner = {Katia},
  references = {Extreme Programming Installed

	Extreme Programming Applied: Playing to Win},
  timestamp = {2010.06.21}
}

@ARTICLE{E[113],
    inserir = {false},
  author = {V. B. Misic and H. Gevaert and M. Rennie},
  title = {Extreme dynamics: towards a system dynamics model of the extreme
	programming software development process},
  year = {2004},
  abstract = {We present a system dynamics model of two key practices of the extreme
	programming paradigm for software development: pair programming and
	pair switching, and task switching. The performance of the programming
	process obtained through this model is compared with the performance
	of the model that describes a traditional approach to programming
	in which programmers work individually. The effects of various parameters
	are highlighted, and the conditions under which one approach appears
	to give better results than the other are outlined. In particular,
	XP appears to have an advantage over the traditional approach when
	pair switches are not too frequent, and when the personalities of
	the members of the pair are not different.},
  owner = {Katia},
  references = {(not available): "Buy This PDF":

	http://scitation.aip.org/getabs/servlet/GetabsServlet?prog=normal&id=IEESEM002004000911000237000001&idtype=cvips&gifs=yes&ref=no

	(not available): "Buy This PDF": Extreme dynamics: towards a system
	dynamics model of the extreme programming software development process

	(not available): "Buy This PDF": Extreme dynamics: towards a system
	dynamics model of the extreme programming software development process

	(not available): "Buy This PDF": Extreme dynamics: towards a system
	dynamics model of the extreme programming software development process

	(not available): "Buy This PDF": Extreme dynamics: towards a system
	dynamics model of the extreme programming software development process

	(not available): "Buy This PDF": Extreme dynamics: towards a system
	dynamics model of the extreme programming software development process

	(not available): "Buy This PDF": Extreme dynamics: towards a system
	dynamics model of the extreme programming software development process

	(not available): "Buy This PDF": Extreme dynamics: towards a system
	dynamics model of the extreme programming software development process

	(not available): "Buy This PDF": Extreme dynamics: towards a system
	dynamics model of the extreme programming software development process

	(not available): "Buy This PDF": Extreme dynamics: towards a system
	dynamics model of the extreme programming software development process

	(not available): "Buy This PDF": Extreme dynamics: towards a system
	dynamics model of the extreme programming software development process},
  timestamp = {2010.06.22}
}

@ARTICLE{E[115],
    inserir = {false},
  author = {R. J. Moore},
  title = {Evolving to a "lighter" software process: a case study},
  year = {2002},
  abstract = {Many new development processes that characterize themselves as lightweight
	or agile have become fashionable, e.g. Extreme Programming (XP) (Beck,
	2000; Cockburn, 2000; Rising and Janoff, 2000). Each of these processes
	is focused on maximizing the effectiveness of a small team of developers
	while anticipating changes in the development environment. These
	processes are mainly focused on the coding phase of the process and
	require strict adherence to the techniques set forth (Beck, 1999).
	Since most of these processes have at least some aspects that might
	seem radical to a more traditional process, e.g. pair programming
	(Williams et al., 2000), an issue arises of how to integrate a lightweight
	process into an existing development/maintenance effort without stalling
	the effort for retraining in the new techniques? How do we evolve
	a traditional process to a lighter one? This paper describes the
	experiences of a development effort within an organization of the
	United States government as it tried to evolve to a lighter process.
	The project was subjected to both organizational and technical changes
	that required the project to be able to adapt rapidly to new development
	landscapes.},
  owner = {Katia},
  references = {Embracing change with extreme programming

	Extreme Programming Explained, Embrace Change

	Selecting a projects methodology

	Hierarchical gui test case generation using automated planning

	The scrum software development process for small teams

	Strengthening the case for pair programming},
  timestamp = {2010.06.21}
}

@ARTICLE{E[116],
    inserir = {false},
  author = {A. Moreno and N. Myller and E. Sutinen},
  title = {JeCo, a collaborative learning tool for programming},
  year = {2004},
  abstract = {Classroom pair-programming activities have been found to support novice
	student's learning during basic programming courses. However, there
	are very few tools that could support pair or group programming in
	distance education courses. Here, we explain the new concept of collaborative
	program visualization and present a tool to support it, called JeCo,
	that can help students work together on a platform that supports
	both collaborative authoring and program visualization.},
  owner = {Katia},
  references = {(not available): http://www.computer.org/portal/web/csdl/doi/10.1109/VLHCC.2004.33

	(not available): JeCo, a collaborative learning tool for programming

	(not available): JeCo, a collaborative learning tool for programming

	(not available): JeCo, a collaborative learning tool for programming

	(not available): JeCo, a collaborative learning tool for programming

	(not available): JeCo, a collaborative learning tool for programming

	(not available): JeCo, a collaborative learning tool for programming

	(not available): JeCo, a collaborative learning tool for programming

	(not available): JeCo, a collaborative learning tool for programming

	(not available): JeCo, a collaborative learning tool for programming

	(not available): JeCo, a collaborative learning tool for programming},
  timestamp = {2010.06.22}
}

@ARTICLE{I[45],
    inserir = {true},
  author = {M. M. Muller},
  title = {Do programmer pairs make different mistakes than solo programmers?},
  year = {2006},
  abstract = {Objective: Comparison of program defects caused by programmer pairs
	and solo developers. Design: Analysis of programs developed during
	two counter balanced experiments. Setting: Programming lab at University.
	Experimental units: 42 programs developed by computer science students
	participating in an extreme programming lab course. Main outcome
	measures: Programmer pairs make as many algorithmic mistakes but
	fewer expression mistakes than solo programmers. Results: The second
	result is significant on the 5% level. Conclusions: For simple problems,
	pair programming seems to lead to fewer mistakes than solo programming.},
  owner = {Katia},
  references = {Group Dynamics

	Refactoring: Improving the Design of Existing Code

	Pair-programming effect on developers productivity

	Noparametric Statistical Methods

	A multiple case study on the impact of pair programming on product
	quality

	An experimental evaluation of the assumption of independence in multi-version
	programming

	Are reviews an alternative to pair Programming?

	Two controlled experiments concerning the comparison of pair programming
	to peer review

	Do programmer pairs make different mistakes than solo programmiers?

	Extreme programming in curriculum: Experiences from academia and industry

	Experimental evaluation of pair programming

	The case for collaborative programming

	Group Process and Productivity

	Gershgorin circle theorem

	Strengthening the case for pair-programming},
  timestamp = {2010.06.22}
}

@ARTICLE{I[46],
    inserir = {true},
  author = {M. M. Muller},
  title = {A preliminary study on the impact of a pair design phase on pair
	programming and solo programming},
  year = {2006},
  abstract = {The drawback of pair programming is the nearly doubled personnel cost.
	The extra cost of pair programming originates from the strict rule
	of extreme programming where every line of code should be developed
	by a pair of developers. Is this rule not a waste of resources? Is
	it not possible to gain a large portion of the benefits of pair programming
	by only a small fraction of the meeting time of a pair programming
	session? We conducted a preliminary study to answer this question
	by splitting the pair programming process into a pair design and
	a pair implementation phase. The pair implementation phase is compared
	to a solo implementation phase, which in turn was preceeded by a
	pair design phase, as well. The study is preliminary as its major
	goal was to identify an appropriate sample size for subsequent experiments.
	The data from this study suggest that there is no difference in terms
	of development cost between a pair and a solo implementation phase
	if the cost for developing programs of similar level of correctness
	is concerned. (c) 2006 Elsevier B.V. All rights reserved.},
  owner = {Katia},
  references = {International Symposium on Software Metrics (Metrics) (2003)

	IEEE Software (2000)

	Communications of the ACM 41 (1998)

	European Software Control and Metrics (Escom) (2001)

	A Discipline for Software Engineering (1995)

	Computer Science Education 12 (2002)

	Introduction to the Team Software Process (1999)

	XP 2003

	Journal on Empirical Software Engineering 9 (2004)

	Journal of Systems and Software (JSS) 78 (2005)

	International Conference on Software Engineering

	International Conference on Extreme Programming and Agile Processes
	in Software Engineering (XP2004)

	Statistical Power Analysis for the Behavioral Sciences (1988)

	International Symposium on Software Metrics (Metrics) (2004)

	Noparametric Statistical Methods (1999)

	Sequential Tests of Statistical Hypotheses (1970)},
  timestamp = {2010.06.22}
}

@ARTICLE{I[44],
    inserir = {true},
  author = {M. M. Muller},
  title = {Two controlled experiments concerning the comparison of pair programming
	to peer review},
  year = {2005},
  abstract = {This paper reports on two controlled experiments comparing pair programming
	with single developers who are assisted by an additional anonymous
	peer code review phase. The experiments were conducted in the summer
	semester 2002 and 2003 at the University of Karlsruhe with 38 computer
	science students. Instead of comparing pair programming to solo programming
	this study aims at finding a technique by which a single developer
	produces similar program quality as programmer pairs do but with
	moderate cost. The study has one major finding concerning the cost
	of the two development methods. Single developers are as costly as
	programmer pairs, if both programmer pairs and single developers
	with an additional review phase are forced to produce programs of
	similar level of correctness. In conclusion, programmer pairs and
	single developers become interchangeable in terms of development
	cost. As this paper reports on the results of small development tasks
	the comparison could not take into account long time benefits of
	either technique.},
  owner = {Katia},
  references = {Building knowledge through families of experiments

	Extreme Programming Explained

	A two-person inspection method to improve programming productivity

	The costs and benefits of pair programming

	Statistical Power Analysis for the Behavioral Sciences

	Software Inspection

	A Discipline for Software Engineering

	Introduction to the Team Software Process

	A language for data analysis and graphics

	Perspective-based reading of code documents at Robert Bosch GMBH

	An internally replicated quasi-experimental comparison of checklist
	and perspective-based reading of code documents

	The effects of pair-programming on performance in an introductory
	programming course

	Are reviews an alternative to pair Programming?

	Extreme programming in curriculum: Experiences from academia and industry

	Extreme programming from an engineering economics point of view

	An empirical study about the feelgood factor in pair programming

	Experimental evaluation of pair programming

	The case for collaborative programming

	Analyzing the cost and benefit of pair programming

	The effectiveness of software development technical reviews: A behaviorally
	motivated program of research

	Ethical issues in empirical studies of software engineering

	A comparison of pair programming to inspections for software defect
	reduction

	The effects of pair-pressure and pairlearning on software engineering
	education

	Strengthening the case for pair-programming},
  timestamp = {2010.06.22}
}

@ARTICLE{I[43],
    inserir = {true},
  author = {M. M. Muller},
  title = {Are reviews an alternative to pair programming?},
  year = {2004},
  abstract = {From the first presentation of extreme programming on, pair programming
	has attracted a wide range of programmers to work together in front
	of one display. The proposed advantages of pair programming are a
	faster development cycle and code with higher quality. However, the
	nearly doubled personnel cost when compared to single developers
	seems to outweigh these advantages. Instead of showing the superiority
	of pair programming, we seek an alternative. Can a single developer
	be assisted by an already known technique with which he produces
	the quality of pairs with only a fraction of the cost? The answer
	with some restrictions is: yes, he can. Reviews are a reasonable
	candidate with respect to code quality and cost.},
  owner = {Katia},
  references = {The costs and benefits of pair programming

	Statistical Power Analysis for the Behavioral Sciences

	Software Inspection

	A Discipline for Software Engineering

	The effects of pair-programming on performance in an introductory
	programming course

	Extreme programming from an engineering economics point of view

	Experimental evaluation of pair programming

	The case for collaborative programming

	A language for data analysis and graphics

	The effects of pair-pressure and pair-learning on software engineering
	education

	Strengthening the case for pairprogramming},
  timestamp = {2010.06.22}
}

@ARTICLE{I[42],
    inserir = {true},
  author = {M. M. Muller and F. Padberg},
  title = {An empirical study about the feelgood factor in pair programming},
  year = {2004},
  abstract = {Why are programmer pairs more productive than single developers? Using
	empirical data from two controlled experiments, we find that pair
	performance is uncorrelated with programming experience, but shows
	a significant correlation with how comfortably the developers feel
	with pair programming during the session (the 'feelgood" factor).},
  owner = {Katia},
  references = {The costs and benefits of pair programming

	The effects of pair-programming on performance in an introductory
	programming course

	Are reviews an alternative to pair programming?

	Should we use programmer pairs or single developers for the next project?

	On the economic evaluation of xp projects

	Experimental evaluation of pair programming

	The case for collaborative programming

	Analyzing the cost and benefit of pair programming

	Strengthening the case for pair-programming

	Building pair programming knowledge through a family of experiments},
  timestamp = {2010.06.22}
}

@ARTICLE{E[118],
    inserir = {false},
  author = {M. M. Muller and F. Padberg},
  title = {On the economic evaluation of XP projects},
  year = {2003},
  abstract = {From a project economics point of view, the most important practices
	of extreme programming (XP) are pair programming and test-driven
	development. Pair programming leads to a large increase in the personnel
	cost, and test-driven development adds to the development effort.
	On the other hand, pair programming can speed the project up; both
	pair programming and test-driven development can reduce the defect
	density of the code. Can the increased cost of XP be balanced by
	its shorter time to market and higher code quality? To answer this
	question, we construct a new model for the business value of software
	projects. We then analyze the cost and benefit of XP by applying
	our model to a realistic sample project. We systematically vary important
	model parameters to provide a sensitivity analysis. Our analysis
	shows that the economic value of XP strongly depends on how large
	the XP speed and defect advantage really are. We also find that the
	market pressure is an important factor when assessing the business
	value of XP. Our study provides clear guidelines for managers when
	to consider using XP - or better not.},
  owner = {Katia},
  references = {Embracing Change with Extreme Programming

	Extreme programming explained: embrace change

	A Two-Person Inspection Method to Improve Programming Productivity

	The costs and benefits of pair programming

	Recognizing and responding to "bad smells" in extreme programming

	Comparative evaluation of software development strategies based on
	net present value

	Measuring the value from improved predictions of software process
	improvement outcomes usin risk-based discount rates

	Managing the software process

	A Discipline for Software Engineering

	Experiment about test-first programming

	Extreme programming from an engineering economics point of view

	About the return on investment of test-driven development

	The case for collaborative programming

	Should NASA embrace agile processes

	Software Engineering

	On the economic feasibility of pair programming

	Strengthening the Case for Pair Programming},
  timestamp = {2010.06.22}
}

@ARTICLE{E[119],
    inserir = {false},
  author = {M. M. Muller and W. F. Tichy},
  title = {Case study: extreme programming in a university environment},
  year = {2001},
  abstract = {Extreme programming (XP) is a new and controversial software process
	for small teams. A practical training course at the University of
	Karlsruhe led to the following observations about the key practices
	of XP. First, it is unclear how to reap the potential benefits of
	pair programming, although pair programming produces high-quality
	code. Second, designing in small increments appears to be problematic
	but ensures rapid feedback about the code. Third, while automated
	testing is helpful, writing test cases before coding is a challenge.
	Last, it is difficult to implement XP without coaching. This paper
	also provides some guidelines for those starting out with XP.},
  owner = {Katia},
  references = {Embracing change with extreme programming

	Extreme Programming Explained

	A two-person inspection method to improve programming productivity

	The costs and benefits of pair programming

	Coordination in software development

	A survey of studies contrasting the quality of group performance and
	individual permformance

	The case for collaborative programming

	All I really need to know about pair programming I learned in kindergarten

	Strengthening the case for pair-programming},
  timestamp = {2010.06.21}
}

@ARTICLE{E[120],
    inserir = {false},
  author = {N. Nagappan and L. Williams and M. Ferzli and E. Wiebe and K. Yang
	and C. Miller and S. Balik},
  title = {Improving the CS1 experience with pair programming},
  year = {2003},
  abstract = {Pair programming is a practice in which two programmers work collaboratively
	at one computer, on the same design, algorithm, or code. Prior research
	indicates that pair programmers produce higher quality code in essentially
	half the time taken by solo programmers. An experiment was run to
	assess the efficacy of pair programming in an introductory Computer
	Science course. Student pair programmers were more self-sufficient,
	generally perform better on projects and exams, and were more likely
	to complete the class with a grade of C or better than their solo
	counterparts. Results indicate that pair programming creates a laboratory
	environment conducive to more advanced, active learning than traditional
	labs; students and lab instructors report labs to be more productive
	and less frustrating .},
  owner = {Katia},
  references = {Guidelines for the Use of Pair Programming in a Freshman Programming
	Class

	The costs and benefits of pair programming

	Peopleware

	Paired Programming Project: Focus Groups with Teaching Assistants
	and Students

	The effects of pair-programming on performance in an introductory
	programming course

	Using Student Team Learning

	Cooperative Learning: Theory, Research and Practice

	Strengthening the Case for Pair Programming

	In Support of Pair Programming in the Introductory Computer Science
	Course

	Pair Programming in an Introductory Computer Science Course: Initial
	Results and Recommendations

	The collaborative software process},
  timestamp = {2010.06.22}
}

@ARTICLE{E[121],
    inserir = {false},
  author = {N. Nagappan and L. Williams and E. Wiebe and C. Miller and S. Balik
	and M. Ferzli and J. Petlick},
  title = {Pair learning: With an eye toward future success},
  year = {2003},
  abstract = {Pair programming is a practice in which two programmers work collaboratively
	at one computer on the same design, algorithm, or code. Prior research
	indicates that pair programmers produce higher quality code in essentially
	half the time taken by solo programmers. Pair programming is becoming
	increasingly popular in industry and in university curricula. An
	experiment was run at North Carolina State University over a period
	of one and a half years to assess the efficacy of pair programming
	as an alternative educational technique in an introductory programming
	course. We found that the retention rate of the students in the introductory
	programming courses is equal to or better than that of the students
	in the solo programming courses. Most students show a positive attitude
	towards collaborative programming, and students in paired classes
	continue to be successful in subsequent programming classes that
	require solo programming. Pair programming also leads to a reduced
	workload for the course staff in terms of grading, questions answered
	and teaching effort.},
  owner = {Katia},
  references = {Statistical Methods for the Social Sciences

	Exploring Pair Programming in Distributed Object-Oriented Team Projects

	Extreme Programming Explained: Embrace Change

	Guidelines for the User of Pair Programming in a Freshman Programming
	Class

	The Costs and Benefits of Pair Programming

	Peopleware

	Paired Programming Project: Focus Groups with Teaching Assistants
	and Students

	The Effect of Pair Programming on Performance in an Introductory Programming
	Course

	The Impact of Pair Programming on Student Performance of Computer
	Science Related Majors

	Improving the CS1 Experience with Pair Programming

	Using Student Team Learning

	Cooperative Learning: Theory, Research and Practice

	Code Warriors and Code-a-Phobes: A study in attitude and pair programming

	Pair Programming in Introductory Programming Labs

	Computer Science Attitude Survey

	Pair Programming Illuminated

	Strengthening the Case for Pair-Programming

	In Support of Pair Programming in the Introductory Computer Science
	Course

	Pair Programming in an Introductory Computer Science Course: Initial
	Results and Recommendations

	The Collaborative Software Process PhD Dissertation

	Masters Thesis: Pair learning in undergraduate computer science education},
  timestamp = {2010.06.22}
}

@ARTICLE{E[122],
    inserir = {false},
  author = {H. Natsu and J. Favela and A. L. Mor and D. Decouchant and A. M.
	Martinez-Enriquez},
  title = {Distributed Pair Programming on the Web},
  year = {2003},
  abstract = {Pair programming is an extreme programming practice, where two programmers
	working sided by side on a single computer produce a software artifact.
	This technique has demonstrated to produce higher quality code in
	less time it would take an individual programmer. We present the
	COPPER system, a synchronous source code editor that allows two distributed
	software engineers to write a program using pair programming. COPPER
	implements characteristics of groupware systems such as communication
	mechanism, collaboration awareness, concurrency control, and a radar
	view of the documents, among others. It also incorporates a document
	presence module, which extends the functionality of instant messaging
	systems to allow users to register documents from a Web server and
	interact with them in a similar fashion as they do with a colleague.
	We report results from a preliminary evaluation of COPPER which provide
	evidence that the system could successfully support distributed pair
	programming.},
  owner = {Katia},
  references = {(not available): http://www.computer.org/portal/web/csdl/doi/10.1109/ENC.2003.1232878

	(not available): Distributed Pair Programming on the Web

	(not available): Distributed Pair Programming on the Web

	(not available): Distributed Pair Programming on the Web

	(not available): Distributed Pair Programming on the Web

	(not available): Distributed Pair Programming on the Web

	(not available): Distributed Pair Programming on the Web

	(not available): Distributed Pair Programming on the Web

	(not available): Distributed Pair Programming on the Web

	(not available): Distributed Pair Programming on the Web

	(not available): Distributed Pair Programming on the Web},
  timestamp = {2010.06.22}
}

@ARTICLE{I[47],
    inserir = {true},
  author = {J. Nawrocki and A. Wojciechowski},
  title = {Experimental Evaluation of Pair Programming},
  year = {2001},
  abstract = {Pair programming is a kind of collaborative programming where two
	people are working simultaneously on the same programming task. It
	is one of the key practices of eXtreme Programming. In the paper
	we

	compare it with two variants of individual programming: one of them
	is based on Personal Software Process that has been proposed by W.
	Humphrey, and the other is a variant of eXtreme Programming tailored

	to individuals. Four experiments are described that has been performed
	at the Poznan University of Technology. During those experiments
	21 students wrote 4 C/C++ programs ranging from 150 to

	400 LOC. The obtained results are compared with the results of similar
	experiments described by J.T. Nosek and L. Williams et al.},
  owner = {Katia},
  references = {Extreme Programming Explained: Embrace Change

	Software Engineering Economics

	A Discipline for Software Engineering

	The cast for collaborative programming

	Strengthening the case for pair programming},
  timestamp = {2010.06.21}
}

@ARTICLE{I[65],
    inserir = {true},
  author = {J. R. Nawrocki and M. Jasinski and L. Olek and B. Lange},
  title = {Pair programming vs. side-by-side programming},
  year = {2005},
  abstract = {In agile methodologies communication between programmers is very important.
	Some of them (e.g. XP or Crystal Clear) recommend pair programming.
	There are two styles of pair programming: XP-like and side-by-side
	(the latter comes from Crystal Clear). In the paper an experiment
	is described that aimed at comparison of those two styles. The subjects
	were 25 students of Computer Science of 4th and 5th year of study.
	They worked for 6 days at the university (in a controlled environment)
	programming Web-based applications with Java, Eclipse, MySQL, and
	Tomcat. The results obtained indicate that side-by-side programming
	is a very interesting alternative to XP-like pair programming mainly
	due to less effort overhead (in the experiment the effort overhead
	for side-by-side programming was as small as 20%, while for XP it
	was about 50%).},
  owner = {Katia},
  references = {Building Knowledge through Families of Experiments

	Extreme Programming Explained: Embrace Change

	Studying programmer behavior experimentally: the problems of proper
	methodology

	Metodologia badan psychologicznych

	Writing Effective Use Cases

	Agile Software Development

	Crystal Clear

	Programmer variability

	A Discipline for Software Engineering

	When Does a Pair Outperform Two Individuals?

	Introduction to Statistical Quality Control

	Experimental Evaluation of Pair Programming

	The Case for Collaborative Programming

	An Empirical study about the Feelgood Factor in Pair Programming

	Software Engineering: A Practitioner’s Approach

	Exploratory Experimental Studies Comparing Online and Offline Programming
	Performance

	An analysis of variance test for normality (complete samples)

	The Psychological Study of Programming

	hould Computer Scientists Experiment More?

	The Collaborative Software Process

	Strengthening the Case for Pair Programming},
  timestamp = {2010.06.22}
}

@ARTICLE{E[123],
    inserir = {false},
  author = {J. T. Nosek},
  title = {The Case for Collaborative Programming},
  year = {1998},
  abstract = {Team programming usually means coordinating efforts of individual
	programmers who divide up the programming tasks for a large, complex
	system. Collaborative programming is used here to mean 2 programmers
	jointly working on the same algorithm and code. Previous research
	indicates that student programmers working collaboratively outperformed
	individual programmers. A follow-up field experiment was conducted
	using experienced programmers who worked on a challenging problem
	important to their organization, in their own environment. To the
	surprise of the managers and participants, all the teams outperformed
	the individual programmers, enjoyed the problem-solving process more,
	and had greater confidence in their solutions.},
  owner = {Katia},
  references = {Investigating the Cost/Schedule Trade-Off in Software Development

	Basics of Applied Statistics

	A dreamer finds the Expertise to Develop an Idea},
  timestamp = {2010.06.21}
}

@ARTICLE{E[124],
    inserir = {false},
  author = {G. Oliphant},
  title = {Convincing the inconvincable},
  year = {2003},
  abstract = {Despite the increasing knowledge base within the IT industry worldwide
	about the tremendous benefits of XP and agile processes, there is
	still a long way to go to convince a lot of developers. A side effect
	of this popularity is that XP practices may have a negative connotation
	for some. This may result in a reluctance to try or adopt any of
	these practices. This paper describes some strategies that may be
	employed by project team members to help those that seem "inconvincible"
	to recognise some of the benefits of XP. Introducing XP should be
	an evolution not a revolution.},
  owner = {Katia},
  references = {Extreme Programming Explained: Embrace Change

	Extreme Programming Applied},
  timestamp = {2010.06.22}
}

@ARTICLE{E[125],
    inserir = {false},
  author = {F. Padberg and M. Muller},
  title = {On the impact of warmup phases on the economics of pair programming},
  year = {2004},
  abstract = {Pair programmers need a "warmup phase" before the pair can work at
	full speed. We study how large the impact of the lower productivity
	during warmup is on the business value of a pair programming project.
	To this end, we extend our net present value model for pair programming
	to explicitly include a learning interval for pairs. We then carry
	out a simulation study where we vary the shape of the learning curve,
	the length of the learning interval, the final productivity level
	of the pairs, the market pressure, and the size of the workforce.
	Our simulations show that the cost of the warmup phase is small compared
	to the project value. This result suggests that the learning overhead
	is not an obstacle to introducing and using pair programming.},
  owner = {Katia},
  references = {A fresh look at cost estimation, process models and risk analysis

	Linking software design with business requirements – quantitatively

	Tracking the impact of design changes during software development

	Extreme programming from an engineering economics viewpoint

	About the return on investment of test-driven development

	A Discrete Simulation Model for Assessing Software Project Scheduling
	Policies

	Using Process Simulation to Compare Scheduling Strategies for Software
	Projects

	Scheduling Software Projects to Minimize the Development Time and
	Cost with a Given Staff

	A Probabilistic Model for Software Projects

	On the Economic Evaluation of XP Projects

	Analyzing the Cost and Benefit of Pair Programming

	The Costs and Benefits of Pair Programming

	Experiment about test-first programming

	Are reviews an alternative to pair programming?

	Extreme Programming in Curriculum: Experiences from Academia and Industry

	Case Study: Extreme Programming in a University Environment

	Experimental Evaluation of Pair Programming

	The Case for Collaborative Programming

	Building Pair Programming Knowledge through a Family of Experiments

	Strengthening the Case for Pair-Programming},
  timestamp = {2010.06.22}
}

@ARTICLE{E[126],
    inserir = {false},
  author = {F. Padberg and M. M. Muller},
  title = {Modelling the Impact of a Learning Phase on the Business Value of
	a Pair Programming Project},
  year = {2004},
  abstract = {Pair programmers need a "warmup phase" before the pair can work at
	full speed. The length of the learning interval varies, depending
	on how experienced the developers are with pair programming and how
	familiar they are with each other. We study how large the impact
	of the lower pair productivity during warmup is on the business value
	of the pair programming project. To this end, we extend our net present
	value model for pair programming to explicitly include a learning
	interval for pairs. We then carry out a simulation study where we
	vary the shape of the learning curve, the length of the learning
	interval, the final productivity level of the pairs, the market pressure,
	and the size of the workforce. Our simulations show that the cost
	of the warmup phase is reasonably small compared to the project value,
	but nonetheless must be taken into account when estimating the project.
	Our results also suggest that the learning overhead is not an obstacle
	to introducing and using pair programming in a real environment.},
  owner = {Katia},
  references = {Computational survey of univariate and multivariate learning curve
	models

	A two-person inspection method to improve programming productivity

	The costs and benefits of pair programming

	Applying various learning curves to hyper-geometric distribution software
	reliability growoth model

	Extreme programming in curriculum: Experiences from academia and industry

	Extreme programming from an engineering economics point of view

	On the economic evaluation of xp projects

	Case study: Extreme programming in a university environment

	Experimental evaluation of pair programming

	The case for collaborative programming

	Analyzing the cost and benefit of pair programming

	A learning curve primer for software engineers

	Strengthening the case for pair-programming

	Building pair programming knowledge through a family of experiments},
  timestamp = {2010.06.22}
}

@ARTICLE{E[127],
    inserir = {false},
  author = {F. Padberg and M. M. Muller},
  title = {Analyzing the cost and benefit of pair programming},
  year = {2003},
  abstract = {We use a combination of metrics to understand, model, and evaluate
	the impact of pair programming on software development. Pair programming
	is a core technique in the hot process paradigm of extreme programming.
	At the expense of increased personnel cost, pair programming aims
	at increasing both the team productivity and the code quality as
	compared to conventional development. In order to evaluate pair programming,
	we use metrics from three different categories: process metrics such
	as the pair speed advantage of pair programming; product metrics
	such as the module breakdown structure of the software; and project
	context metrics such as the market pressure. The pair speed advantage
	is a metric tailored to pair programming and measures how much faster
	a pair of programmers completes programming tasks as compared to
	a single developer. We integrate the various metrics using an economic
	model for the business value of a development project. The model
	is based on the standard concept of net present value. If the market
	pressure is strong, the faster time to market of pair programming
	can balance the increased personnel cost. For a realistic sample
	project, we analyze the complex interplay between the various metrics
	integrated in our model. We study for which combinations of the market
	pressure and pair speed advantage the value of the pair programming
	project exceeds the value of the corresponding conventional project.
	When time to market is the decisive factor and programmer pairs are
	much faster than single developers, pair programming can increase
	the value of a project, but there also are realistic scenarios where
	the opposite is true. Such results clearly show that we must consider
	metrics from different categories in combination to assess the cost-benefit
	relation of pair programming.},
  owner = {Katia},
  references = {(not available): http://www.computer.org/portal/web/csdl/doi/10.1109/METRIC.2003.1232465

	(not available): Analyzing the cost and benefit of pair programming

	(not available): Analyzing the cost and benefit of pair programming

	(not available): Analyzing the cost and benefit of pair programming

	(not available): Analyzing the cost and benefit of pair programming

	(not available): Analyzing the cost and benefit of pair programming

	(not available): Analyzing the cost and benefit of pair programming

	(not available): Analyzing the cost and benefit of pair programming

	(not available): Analyzing the cost and benefit of pair programming

	(not available): Analyzing the cost and benefit of pair programming

	(not available): Analyzing the cost and benefit of pair programming},
  timestamp = {2010.06.22}
}

@ARTICLE{E[128],
    inserir = {false},
  author = {A. Parrish and R. Smith and D. Hale and J. Hale},
  title = {A field study of developer pairs: productivity impacts and implications},
  year = {2004},
  abstract = {Pair programming purportedly delivers quality code with little productivity
	loss. The authors' field study, outside the pair programming environment,
	shows that two-person teams working independently are more productive
	than those working concurrently; agile methods may overcome inherent
	productivity losses of concurrent development. This research contrasts
	starkly with our field study findings. We decided to reexamine our
	earlier productivity data from teams of two and ask: Would our previous
	findings of concurrent-work productivity loss be reversed if we look
	only at programming pairs rather than teams of all sizes? If so,
	we could conclude that pairs are naturally more productive than larger
	teams, regardless of the collaborative process. If not, we could
	conclude that the collaboration mechanisms prescribed in pair programming
	might overcome a natural loss of productivity from concurrent work.
	We offer these findings and their implications as a benchmark against
	which we might measure the potential of pair programming practices.},
  owner = {Katia},
  references = {An Empirical Study Using Task Assignment Patterns to Improve the Accuracy
	of Software Effort Estimation

	Enhancing the Cocomo Estimation Models

	Embracing Change with Extreme Programming

	Extreme programming explained: embrace change

	Pair Programming Illuminated

	Constantine on Peopleware

	The case for collaborative programming

	Building Pair Programming Knowledge through a Family of Experiments

	Software Development Worldwide: The State of the Practice

	All I really need to know about pair programming I learned in kindergarten

	Extreme Programming: The Good, the Bad, and the Bottom Line},
  timestamp = {2010.06.22}
}

@ARTICLE{E[129],
    inserir = {false},
  author = {M. C. Paulk},
  title = {Extreme Programming from a CMM perspective},
  year = {2001},
  abstract = {Extreme Programming (XP) has been advocated recently as an appropriate
	programming method for the high-speed, volatile world of Internet
	and Web software development. This popular methodology is

	reviewed from the perspective of the Capability Maturity Model (CMM)
	for Software, a five-level model that prescribes process improvement
	priorities for software organizations. Overviews of both XP and CMM

	are provided, and XP is critiqued from a Software CMM perspective.
	The conclusion is that lightweight methodologies such as XP advocate
	many good engineering practices, although some practices may be

	controversial and counter-productive outside a narrow domain. For
	those interested in process improvement, the ideas in XP should be
	carefully considered for adoption where appropriate in an

	organization's business environment since XP can be used to address
	many of the CMM Level 2 and 3 practices. In turn, organizations using
	XP should carefully consider the management and infrastructure issues

	described in the CMM.},
  owner = {Katia},
  references = {The Capability Maturity Model: Guidelines for Improving the Software
	Process

	Using the Software CMM with Good Judgment

	Applying CMM Project Planning Practices to Diverse Environments

	Extreme Programming Explained: Embrace Change

	eXtreme Programming Pros and Cons: What Questions Remain?

	Strengthening the Case for Pair Programming

	Product-Development Practices that Work: How Internet Companies Build
	Software},
  timestamp = {2010.06.21}
}

@ARTICLE{E[130],
    inserir = {false},
  author = {V. Peeters and P. Schrier},
  title = {The drawing carousel: A Pair Programming experience},
  year = {2005},
  abstract = {The participants will experience how a pair programming team works.
	Working in a single pair is different from working on your own: You
	have to articulate what you want to do, the other person (probably)
	has some different insights, and the result will be different from
	what you would have done on your own. But.. this is only half of
	the story: working in a Pair Programming Team has many more advantages:
	knowledge is spread, the team creates an own style, parallel development
	becomes easy, truck factor (http://c2.con/cgi/wiki?TruckNumber) is
	reduced. The team creates the product (instead of individual programmers
	creating the parts), the product is a whole, not a mixture of individual
	results. You will learn about the necessity of agile tools like daily
	standup meetings, pair rotation, coding standards and collective
	code ownership, how they work, and what their effects are. You will
	experience improvements for the quality of you product, and for the
	productivity of the team.},
  owner = {Katia},
  references = {no references: The drawing carousel: A Pair Programming experience},
  timestamp = {2010.06.22}
}

@ARTICLE{E[131],
    inserir = {false},
  author = {M. Peleg and L. A. Gutnik and V. Snow and V. L. Patel},
  title = {Interpreting procedures from descriptive guidelines},
  year = {2006},
  abstract = {Errors in clinical practice guidelines may translate into errors in
	real-world clinical practice. The best way to eliminate these errors
	is to understand how they are generated, thus enabling the future
	development of methods to catch errors made in creating the guideline
	before publication. We examined the process by which a medical expert
	from the American College of Physicians (ACP) created clinical algorithms
	from narrative guidelines, as a case study. We studied this process
	by looking at intermediate versions produced during the algorithm
	creation. We identified and analyzed errors that were generated at
	each stage, categorized them using Knuth's classification scheme,
	and studied patterns of errors that were made over the set of algorithm
	versions that were created. We then assessed possible explanations
	for the sources of these errors and provided recommendations for
	reducing the number of errors, based on cognitive theory and on experience
	drawn from software engineering methodologies.},
  owner = {Katia},
  references = {Guidelines for clinical practice: directions for a new program

	Learning graph-reading skills for solving problems

	Learning and use of representations for physics expertise

	Decision-making strategies for telephone triage in emergency medical
	services

	Cognitive psychological studies of representation and use of clinical
	practice guidelines

	Software Inspection

	Design and code inspections to reduce errors in program development

	Seven truths about peer reviews

	Strengthening the Case for Pair Programming

	XP Versus MTP: The Limits of Extreme Programming

	Active design reviews: principles and practices

	Capability Maturity Model for Software, Version 1.1

	A study of collaboration among medical informatics research laboratories

	Representing a clinical guideline in GLIF: individual and collaborative
	expertise

	Support for guideline development through error classification and
	constraint checking

	GLIF3: a representation format for sharable computer-interpretable
	clinical practice guidelines

	Pharmacologic management of acute attacks of migraine and prevention
	of migraine headache

	The errors of TEX, Software—Practice & Experience

	Reproducibility of interpreting "and" and or in terminology systems

	Representation of clinical practice guidelines in conventional and
	augmented decision tables

	Cognitive models of directional inference in expert medical reasoning

	Thinking and reasoning in medicine

	Guidelines for clinical practice: from development to use

	Sharable computer-based clinical practice guidelines: rationale, obstacles,
	approaches, and prospects

	Evaluation of guideline quality using GEM-Q

	Computerizing guidelines to improve care and patient outcomes: the
	example of heart failure},
  timestamp = {2010.06.22}
}

@ARTICLE{I[49],
    inserir = {true},
  author = {M. Phongpaibul and B. Boehm},
  title = {An Empirical Comparison Between Pair Development and Software Inspection
	in Thailand},
  year = {2006},
  abstract = {Although pair programming and software inspection have the common
	aim of minimizing the defects of the software product, each practice
	has its strengths and weaknesses. We need to understand their costs
	and benefits under given conditions to be able to select a practice
	to execute in a development project. The objective of this study
	is to compare the commonalities and differences between pair development
	and software inspection as verification techniques in Thailand. One
	classroom experiment and one industry experiment were conducted.
	The development effort and effect of quality were investigated with
	some additional

	calendar time comparisons. The classroom results showed that average
	development effort of the pair development group was 24% less than
	inspection group with the improved product quality. The industry
	experiment showed pair development to have about 4% more effort but
	about 40% fewer major defects. In addition, the impacts of cultural
	differences to the adoption of pair programming or software inspection
	in Thailand are discussed.},
  owner = {Katia},
  references = {Software Inspection: An Effective Verification Process

	State-of-the-Art: Software Inspections after 25 Years

	Balancing Agility and Discipline

	The Costs and Benefits of Pair Programming. eXtreme Programming and
	Flexible Processes in Software Engineering XP2000

	Process Improvement and the Corporate Balance Sheet

	Advances in Software Inspections

	Design and Code Inspections to Reduce Errors in Program Development

	Software Inspection

	An Analysis of Defect Densities Found During Software Inspections

	Culture’s Consequences -- Comparing Values, Behaviors, Institutions
	and Organizations Across Nations

	Culture and Organizations – Software of the Mind

	The Impact of Thai Culture on Executive Information Systems Development

	Empirical Results from an Experiment on Value-Based Review (VBR) Processes

	Shuttle Code Achieves Very Low Error Rate

	Improving Quality Through Software Process Improvement in Thailand:
	Initial Analysis

	Experience with Inspection in Ultralarge-Scale Development

	Pair Learning: With an Eye Toward Future Success

	What we have Learned about Fighting Defects

	Statistic and Data Analysis

	Evaluating the Cost of Software Quality

	Preliminary Analysis of the Effects of Pair Programming on Job Satisfaction

	Towards Understanding Managing Requirements Engineering – A Case Study
	of a Thai Software House

	Cultural Context and its Impact on Requirements Elicitation in Thailand

	Lessons from Three Years of Inspection Data

	The Impact of Using Pair Programming on System Evolution: a Simulation-Based
	Study

	Peer Review Processes Similar to Inspection

	Software Inspection: An Industry Best Practice

	Peer Reviews in Software: A Practice Guide

	The Collaborative Software Process

	Pair Programming Illuminated

	In Support of Pair Programming in the Introductory Computer Science
	Course},
  timestamp = {2010.06.22}
}

@ARTICLE{E[132],
    inserir = {false},
  author = {D. Preston},
  title = {Using collaborative learning research to enhance pair programming
	pedagogy},
  year = {2006},
  abstract = {Programming is a pillar of IT education; teaching programming is a
	major challenge of IT education. A significant amount of recent research
	has demonstrated the success of pair programming pedagogy in meeting
	this challenge. Pair programming is a key component of the Extreme
	Programming software development methodology. When used as pedagogy,
	pair programming is an instance of collaborative learning, a well-established
	technique for teaching complex, conceptual tasks. Research has documented
	the success of collaborative learning and has identified the critical
	attributes of successful collaborative learning approaches. This
	article uses a review of the research as a basis for recommended
	enhancements to ensure that pair programming pedagogy possesses the
	critical attributes of successful collaborative learning approaches.},
  owner = {Katia},
  references = {What the Best College Teachers Do

	Extreme programming explained: embrace change

	Voices of women in a software engineering course: reflections on collaboration

	Collaborative Learning: Higher Education, Interdependence, and the
	Authority of Knowledge

	Experiences with pair programming at a small college

	Cooperative and collaborative learning: an integrative perspective

	Pair programming and pair trading: effects on learning and motivation
	in a CS2 course

	Program quality with pair programming in CS1

	An overview of cooperative learning

	On understanding compatibility of student pair programmers

	Experimenting with pair programming in the classroom

	The effects of pair-programming on performance in an introductory
	programming course

	The impact of pair programming on student performance, perception
	and persistence

	Teaching Tips: Strategies, Research, and Theory for College and University
	Teachers

	Investigating pair-programming in a 2nd-year software development
	and design computer science course

	Why understanding the theoretical basis of cooperative learning enhances
	teaching success

	Improving the CS1 experience with pair programming

	Cooperative group learning and higher education

	Software engineering

	PAIR programming as a model of collaborative learning: a review of
	the research

	Code warriors and code-a-phobes: a study in attitude and pair programming

	A decision-making model for curricular adaptations in cooperative
	groups

	Coupling pair programming and writing: learning about students' perceptions
	and processes

	Pair-programming helps female computer science students

	All I really need to know about pair programming I learned in kindergarten

	Strengthening the Case for Pair Programming

	In support of student pair-programming},
  timestamp = {2010.06.22}
}

@ARTICLE{E[133],
    inserir = {false},
  author = {D. Preston},
  title = {Adapting Pair Programming Pedagogy for use in Computer Literacy Courses},
  year = {2006},
  abstract = {Pair programming is a key component of the Extreme Programming (XP)
	software development methodology and involves two programmers working
	at the same workstation to create code. Pair programming pedagogy,
	based on this approach of sharing a workstation, has proven to be
	successful in teaching programming to undergraduate students. The
	tasks assigned to students in computer literacy courses differ significantly
	from the task of developing a program: the former have students develop
	predefined products using commercial applications by following step-by-step
	instructions whereas the latter have students apply problem solving
	skills to design and develop a unique solution. Because the types
	of tasks differ, pair programming pedagogy must be adapted prior
	to use in computer literacy courses. Pair programming

	pedagogy is a recent and specific application of the older and more
	general collaborative learning. Therefore, the critical attributes
	of successful collaborative learning approaches are used to structure
	this adaptation of pair programming pedagogy.},
  owner = {Katia},
  references = {What the Best College Teachers Do

	Extreme programming explained: embrace change

	Voices of women in a software engineering course: reflections on collaboration

	Collaborative Learning: Higher Education, Interdependence, and the
	Authority of Knowledge

	Experiences with pair programming at a small college

	Cooperative and collaborative learning: an integrative perspective

	Pair programming and pair trading: effects on learning and motivation
	in a CS2 course

	Program quality with pair programming in CS1

	An overview of cooperative learning

	On understanding compatibility of student pair programmers

	Experimenting with pair programming in the classroom

	The effects of pair-programming on performance in an introductory
	programming course

	The impact of pair programming on student performance, perception
	and persistence

	Teaching Tips: Strategies, Research, and Theory for College and University
	Teachers

	Investigating pair-programming in a 2nd-year software development
	and design computer science course

	Why understanding the theoretical basis of cooperative learning enhances
	teaching success

	Improving the CS1 experience with pair programming

	PAIR programming as a model of collaborative learning: a review of
	the research

	Software Engineering: A Practitioner's Approach

	A decision-making model for curricular adaptations in cooperative
	groups

	Coupling pair programming and writing: learning about students' perceptions
	and processes

	Pair-programming helps female computer science students

	Strengthening the Case for Pair Programming

	In support of student pair-programming},
  timestamp = {2010.06.22}
}

@ARTICLE{E[134],
    inserir = {false},
  author = {D. Preston},
  title = {Pair Programming as a Model of Collaborative Learning: A Review of
	the Research},
  year = {2005},
  abstract = {Pair programming is a form of collaborative learning; the pair works
	together to achieve a common goal. Recent research has clearly documented
	the benefits of pair programming on student performance. Collaborative
	learning research has established two things: (1) the effectiveness
	of having students work together and, (2) the critical attributes
	common to successful collaborative learning approaches. This paper
	uses the critical attributes of collaborative learning as a framework
	to review research on pair programming. The conclusion is that pair
	programming, as reported in the literature, is a model of collaborative
	learning, i.e., pair programming is generally consistent with the
	identified critical attributes. One way that those of us who use
	the pair programming pedagogy can enhance this consistency is to
	increase the emphasis on the pair programming process.},
  owner = {Katia},
  references = {Experiences with pair programming at a small college,

	Cooperative and collaborative learning: an integrative perspective

	Pair programming and pair trading: effects on learning and motivation
	in a CS2 course

	A practical approach to integrating active and collaborative learning
	into the introductory computer science curriculum

	An overview of cooperative learning

	On understanding compatibility of student pair programmers

	Experimenting with pair programming in the classroom

	The effects of pair-programming on performance in an introductory
	programming course

	The impact of pair programming on student performance, perception
	and persistence

	Active and cooperative learning techniques for the computer science
	classroom

	Improving the CS1 experience with pair programming

	Cooperative group learning and higher education

	Code warriors and code-a-phobes: a study in attitude and pair programming

	Coupling pair programming and writing: learning about students' perceptions
	and processes

	Student culture vs group work in computer science

	All I really need to know about pair programming I learned in kindergarten

	In support of student pair-programming},
  timestamp = {2010.06.22}
}

@ARTICLE{E[135],
    inserir = {false},
  author = {A. Pretschner and H. Lotzbeyer and J. Philipps},
  title = {Model based testing in incremental system development},
  year = {2004},
  abstract = {The spiraling nature of evolutionary software development processes
	produces executable parts of the system at the end of each loop.
	It is argued that these parts should consist not only of programming
	language code, but of executable graphical system models. As a main
	benefit of the use of more abstract, yet formal, modeling languages,
	a method for model based test sequence generation for reactive systems
	on the grounds of Constraint Logic Programming as well as its implementation
	in the CASE tool AF is presented.},
  owner = {Katia},
  references = {Using Model Checking to Generate Tests from Specifications

	Extreme programming explained: embrace change

	Model based development of hybrid systems: specification, simulation,
	test case generation

	Testing object-oriented systems: models, patterns, and tools

	A Spiral Model of Software Development and Enhancement

	Extreme modeling, Extreme programming examined

	Automatic test generation for EFSM-based systems

	Automatic generation of tests from Statechart specifications

	Using constraint logic programming for software validation

	QuickCheck: a lightweight tool for random testing of Haskell programs

	A system to generate test data and symbolically execute programs

	Logic Programming and Model Checking

	Model Checking in CLP

	Test-Case Generation from Prolog-Based Specifications

	An evaluation of random testing

	Directed explicit model checking with HSF-SPIN

	Using On-The-Fly Verification Techniques for the Generation of test
	Suites

	Program verification: the very idea

	Refactoring: improving the design of existing code

	An Applicable Family of Data Flow Testing Criteria

	Constraint Logic Programming Applied to Model Checking

	Theory and practice of constraint handling rules

	Toward a theory of test data selection

	Model checking Java programs using structural heuristics

	Partition Testing Does Not Inspire Confidence (Program Testing)

	The Model Checker SPIN

	Methodology for the generation of program test data

	Symbolic testing and the DISSECT symbolic evaluation system

	An evaluation of the effectiveness of symbolic testing

	AutoFocus: A Tool for Distributed Systems Specification

	Software requirements & specifications: a lexicon of practice, principles
	and prejudices

	Symbolic execution and program testing

	Autolink: A Tool for Automatic Test Generation from SDL Specifications

	Génération de séquences de tests à partir d'une spécification B en
	PLC ensembliste

	Designing specification languages for process control systems: lessons
	learned and steps to the future

	AutoFocus on Constraint Logic Programming. In: Proceedings of the
	(Constraint) Logic Programming and Software Engineering

	Testing Concurrent Reactive Systems with Constraint Logic Programming

	Test Sequences Generation from LUSTRE Descriptions: GATEL

	ATGen: automatic test data generation using constraint logic programming
	and symbolic execution

	A Comparison of Some Structural Testing Strategies

	Roots of refactoring

	Traffic flow by data flow

	The Quest for Correct Systems: Model Checking of Diagrams and Datatypes

	Classical search strategies for test case generation with Constraint
	Logic Programming

	Model Based Testing in Evolutionary Software Development

	Model based testing for real: The inhouse card case study

	Szenarien modellbasierten Testens

	Cleanroom software engineering: technology and process

	On the automated generation of program test data

	Automatic Testing of Reactive Systems

	An Approach to Symbolic Test Generation

	Testing cyclic software components of reactive systems on the basis
	of formal specifications

	Model-based development

	The Haskell: The Craft of Functional Programming

	A search-based automated test-data generation framework for safety-critical
	software

	Test generation with inputs, outputs and repetitive quiescence

	Formalization of control-flow criteria of software testing

	Java PathFinder-- Second Generation of a Java Model Checker

	A Comparison of Statecharts Variants

	Côte de Resyste in Progress

	Memoing for logic programs

	Axiomatizing software test data adequacy

	Specification based test sequence generation with propositional logic

	Software unit test coverage and adequacy},
  timestamp = {2010.06.22}
}

@ARTICLE{E[136],
    inserir = {false},
  author = {M. Purvis and M. Purvis and B. T. Roy and S. M. George and S. Cranefield},
  title = {Experiences with pair and tri programming in a second level course},
  year = {2005},
  abstract = {In this paper we describe our experiences with multi-programming (pair
	and tri programming) in a second level course. The course, "Application
	Software Development" is a second year course, which has a heavy
	emphasis on Java programming in the labs as well as the development
	of a full-fledged project. The objective of the course is to build
	an entire project that comprises of various software engineering
	activities that span across the semester. In general, we observe
	that multi-programming improves the students' ability in analytical
	thinking and communicating the conceptual ideas. It also raises certain
	issues when this approach is adopted in the educational context.
	In this paper we discuss some of these issues. Overall, multi-programming
	experience has been a rewarding experience for the students in spite
	of certain problems that were encountered .},
  owner = {Katia},
  references = {Strengthening the Case for Pair Programming

	In Support of Pair Programming in the Introductory Computer Science
	Course Computer Science Education

	Cooperative Learning: Prevalence, Conceptualizations, and the Relationship
	between Research and Practice

	The Effectiveness of Cooperative Learning Strategies in Multicultural
	University Classrooms

	Collaborative learning enhances critical thinking

	Less Extreme Programming

	Strengthening the Case for Pair-Programming

	All I Really Need to Know about Pair Programming I Learned In Kindergarten

	The Effects of Pair-Pressure and Pair-Learning on Software Engineering
	Education

	The Impact of Pair Programming on Student Performance, Perception,
	and Persistance

	Experimenting with Pair Programming in the Classroom

	Code Warriors and Code-a-Phobes: A Study in Attitude and Pair Programming

	Planning Extreme Programming},
  timestamp = {2010.06.22}
}

@ARTICLE{E[137],
    inserir = {false},
  author = {U. Puus and A. Seeba and P. Salumaa and S. Heiberg},
  title = {Analyzing pair-programmer's satisfaction with the method, the result,
	and the partner},
  year = {2004},
  abstract = {We give an overview of a programmer satisfaction survey in pair-programming
	experiment. The experiment took place at Institute of Computer Science,
	University of Tartu (UT), Estonia. We include the problem statement,
	description of the questionnaire, and the survey results.},
  owner = {Katia},
  references = {The Costs and Benefits of Pair Programming

	Factor Analysis

	Program Quality with Pair Programming in CS1

	Pair-Programming Effect on Developers Productivity

	The Impact of Pair Programming on Student Perfomance, Perception and
	Persistence

	Team Development and Pair Programming - tasks and challenges of the
	XP coach

	Preliminary Analysis of the Effects of Pair Programming on Job Satisfaction

	All I Really Need to Know about Pair Programming I Learned in Kindergarten

	Strengthening the Case for Pair Programming

	The Collaborative Software Process},
  timestamp = {2010.06.22}
}

@ARTICLE{E[138],
    inserir = {false},
  author = {A. Qumer and B. Henderson-Sellers},
  title = {An evaluation of the degree of agility in six agile methods and its
	applicability for method engineering},
  year = {2007},
  abstract = {While agile methods are in use in industry, little research has been
	undertaken into what is meant by agility and how a supposed agile
	method can be evaluated with regard to its veracity to belong to
	this category of software development methodological approaches.
	Here, an analytical framework, called 4-DAT, is developed and applied
	to six well-known agile methods and, for comparison, two traditional
	methods. The results indicate the degree of agility to be found in
	each method, from which a judgement can be made as to whether the
	appellation of "agile" to that method is appropriate. This information
	is shown to be useful, for example, when constructing a methodology
	from method fragments (method engineering) and when comparing agile
	and traditional methods.},
  owner = {Katia},
  references = {Knowledge Sharing: Agile Methods vs. Tayloristic Methods

	AgileManifesto

	Measuring agility and adoptability of agile methods: a 4-dimensional
	analytical tool

	Crystallization of agility: back to basics

	Comparative evaluation of XP and Scrum using the 4D Analytical Tool
	(4-DAT)

	Agile software development

	The Meaning of Life and the Meaning of Agility

	Evaluating software engineering methods and tool part 5: the influence
	of human factors

	Toward a Framework for Evaluating Extreme Programming

	Balancing Agility and Discipline: A Guide for the Perplexed

	A Framework for Evaluation of Agent Oriented Methodologies

	A Preliminary Comparative Feature Analysis of Multi-agent Systems
	Development Methodologies

	An Integrated Approach to Software Engineering

	Agile Software Development: Evaluating the Methods for Your Organization

	Extreme programming explained: embrace change

	System Development: Research Paper 1, SDLC on a Diet

	Agile Software Development with Scrum

	A Practical Guide to Feature-Driven Development

	Adaptive software development: a collaborative approach to managing
	complex systems

	Dsdm: The Method in Practice

	Agile Software Development

	Agile software development methods

	New directions on agile methods: a comparative analysis

	Dynamic Systems Development Method Ltd

	A Methodology Per Project

	Surviving object-oriented projects: a manager's guide

	The New Methodology

	Managing the development of large software systems: concepts and techniques

	A Spiral Model of Software Development and Enhancement

	BOOKTWO of object-oriented knowledge: the working object: object-oriented
	software engineering: methods and management

	Methodology EngineeringR: a proposal for situation-specific methodology
	construction

	Method engineering: engineering of information systems development
	methods and tools

	Meta-modelling based assembly techniques for situational method engineering

	Method engineering for OO systems development

	On the feasibility of situational method engineering

	Reusing Scenario Based Approaches in Requirement Engineering Methods:
	CREWS Method Base

	CAME: the first step to automated software engineering

	Method engineering: current research directions and implications for
	future research

	Towards automated support for method engineering with the OPEN approach

	Incremental Method Engineering with Modeling Tools: Theoretical Principles
	and Empirical Evidence

	An Assembly Process Model for Method Engineering

	The scenario for constructing flexible, people-focused systems development
	methodologies},
  timestamp = {2010.06.22}
}

@ARTICLE{I[67],
    inserir = {true},
  author = {M. Mujeeb-u-Rehman and X. Yang and J. Dong and M. A. Ghafoor},
  title = {Heterogeneous and homogenous pairs in pair programming: an empirical
	analysis},
  year = {2006},
  abstract = {Extreme programming (XP) is causing a lot of hype currently. Pair
	programming is one of its practices, where two programmers work collaboratively
	at one computer on the same design, algorithm, code, or test. The
	purpose of this technique is to produce higher quality code in less
	time. The collaborative working of two brains is better than one
	as long as both are actively trying to accomplish the same goal.
	It depends on many things, such as creativity, productivity and brainstorming
	which are the essential factors of the programming activity. The
	existence of these factors can vary in homogenous and heterogeneous
	pairs, so the functional brainstorming capability of different pairs
	during programming may vary in terms of quality, accuracy and speed.
	This paper presents the empirical analysis between the homogenous
	and heterogeneous pairs in terms of efficiency, accuracy, quality,
	quantity of bugs, brainstorming performance and creativity potential
	during programming activity.},
  owner = {Katia},
  references = {Software Support for Creative Problem Solving

	Toward an Understanding of Creative Solution Generation

	The Cognitive Network Model of Creativity: a New Causal Model of Creativity
	and a New Brainstorming Technique

	Multimodal Interaction in a Collaborative Virtual Brainstorming Environment

	Analyzing the Cost and Benefit of Pair Programming

	Modeling the Impact of a Learning Phase on the Business Value of a
	Pair Programming Project

	An Initial Framework for Research on Pair Programming

	Distributed Pair Programming on the Web

	Guidelines for the Use of Pair Programming in a Freshman Programming
	Class

	Improving Group Creativity: Brainstorming Versus Nonbrainstorming
	Techniques in a GSS Environment

	Extreme Programming Explained, Embrace Change

	A Cognitive Model for Solo Programming and Pair Programming

	Building Pair Programming Knowledge through a Family of Experiments

	Integrating Pair Programming into a Software Development Process

	Developing Complex Projects Using XP with Extensions

	Extreme Programming and its Development Practices

	Quality as a function of quantity in electronic brainstorming},
  timestamp = {2010.06.22}
}

@ARTICLE{E[139],
    inserir = {false},
  author = {D. J. Reifer},
  title = {How to get the most out of extreme programming/agile methods},
  year = {2002},
  abstract = {This paper reports the results of an analysis of thirty-one extreme
	programming (XP)/agile methods early adopter projects completed by
	fourteen firms who have embraced the techniques in the form of lessons
	learned. The survey results show that early adopters have cut costs,
	improved productivity and reduced time to market through the use
	of these methods. To get the most from these methods, fifteen lessons
	learned have been developed that build on the experiences of others.
	Several of these lessons run counter to the teachings of the methodology
	developers. The paper next provides a scorecard that rates XP's performance
	in eight application domains. The paper concludes by summarizing
	four critical success factors for early adopters.},
  owner = {Katia},
  references = {Refactoring: Improving the Design of Existing Code

	How Good Are Agile Methods?

	Extreme Programming Explained

	Extreme Programming Applied

	Extreme Programming Explored

	The Capability Maturity Model: Guidelines for Improving the Software
	Process

	Making the Software Business Case: Improvement by the Numbers

	The Rational Unified Process: An Introduction

	Software Cost Estimation with COCOMO II

	Adaptive Software Development: A Collaborative Approach to Managing
	Complex Systems

	Extreme Programming (and Pair Programming)

	The Peopleware Papers

	Manifesto Elicits Cynicism

	Extreme Programming from a CMM Perspective

	Project Retrospectives: A Handbook for Team Reviews

	Private Communications

	Agile Software Development},
  timestamp = {2010.06.21}
}

@ARTICLE{E[140],
    inserir = {false},
  author = {D. J. Reifer},
  title = {How good are agile methods?},
  year = {2002},
  abstract = {The software industry seems to be embracing yet another change to
	the way it does business. Because of their emphasis on agility and
	time-to-market, many programming shops are moving to agile methods.
	Unlike more traditional approaches, these methods focus on generating
	early releases of working products using mostly collaborative techniques
	such as pair programming, refactoring, and having customers work
	on site as team members. Programmers use these releases-which are
	working products, not prototypes-to demonstrate features and functions
	to stakeholders involved in their use, marketing, and support. This
	article surveys the experience software engineers in a wide, range
	of industries have had in deploying agile methods.},
  owner = {Katia},
  references = {Making the software business case: improvement by the numbers

	Let the Numbers Do the Talking},
  timestamp = {2010.06.21}
}

@ARTICLE{E[141],
    inserir = {false},
  author = {H. Robinson and J. Segal and H. Sharp},
  title = {Ethnographically-informed empirical studies of software practice},
  year = {2007},
  abstract = {Over the past decade we have performed a sustained series of qualitative
	studies of software development practice, focusing on social factors.
	Using an ethnographically-informed approach, we have addressed four
	areas of software practice: software quality management systems,
	the emergence of object technology, professional end user development
	and agile development. Several issues have arisen from this experience,
	including the nature of research questions that such studies can
	address, the advantages and challenges associated with being a member
	of the community under study, and how to maintain rigour in data
	collection. In this paper, we will draw on our studies to illustrate
	our approach and to discuss these and other issues.},
  owner = {Katia},
  references = {Applying ethnography in the analysis and support of expertise in engineering
	design

	Extreme programming explained: embrace change

	Information systems prototyping in practice

	Balancing Agility and Discipline: A Guide for the Perplexed

	Realising evidence-based software engineering

	Project work: the organisation of collaborative design and development
	in software engineering

	Social Behaviors on XP and non-XP teams: A Comparative Study

	Agile software development

	Using Textual Demographics to Understand Computer Use: 1950-1990

	SIMULA: an ALGOL-based simulation language

	The social management of computing artefacts in nursing work: an ethnographic
	account

	Discovery of Grounded Theory

	Research in software engineering: an analysis of the literature. Information
	and Software Technology

	The relevance of qualitative research

	Ethnography, Principles in Practice

	Beyond computer science

	Rapid Contextual Design

	Building quality into scientific software

	How to Lie With Statistics

	Preliminary guidelines for empirical research in software engineering

	Experimenter induced distortions in empirical software engineering

	A set of principles for conducting and evaluating interpretive field
	studies in information systems

	Empirical Evaluation of Software Maintenance Technologies

	Studying Software Engineers: Data Collection Techniques for Software
	Field Studies

	Qualitative Researching

	Researching Information Systems and Computing

	Discourse and Social Psychology

	The characteristics of XP teams

	Organisational culture and XP: three case studies

	The social side of technical practices

	The case for empirical studies of the practice of software development

	Real World Research

	The Reflective Practitioner

	Qualitative Methods in Empirical Studies of Software Engineering

	Organisational Learning and Software Process Improvement: A Case Study

	When Software Engineers Met Research Scientists: A Case Study

	Two principles of end-user software engineering research

	The type of evidence produced by empirical software engineers

	Object technology: community and culture

	An Ethnographic Study of XP Practice

	Software Engineering: Community and Culture

	Tensions around the adoption and evolution of software quality management
	systems: a discourse analytic approach

	Using Metaphor to Analyse Qualitative Data: Vulcans and Humans in
	Software Development

	The Role of Story Cards and the Wall in XP teams: A Distributed Cognition
	Perspective

	Ethical Issues in Empirical Studies of Software Engineering

	An examination of software engineering work practices

	Should Computer Scientists Experiment More?

	Coherence: an approach to representing ethnographic analyses in systems
	design},
  timestamp = {2010.06.22}
}

@ARTICLE{E[142],
    inserir = {false},
  author = {N. Roodyn},
  title = {Dear diary: the making of an XP team},
  year = {2003},
  abstract = {The author discusses his experience working with a software technology
	company during the introduction of XP. While there had been some
	success at employing practices such as the planning game, stand-up
	meetings, and pair programming, the company was struggling. He realized
	the biggest thing they were lacking was the concept that XP is about
	the team delivering great software, not the individual or a group
	of individuals. His first challenge, then, was to help them become
	a team. A a journal of events that occurred while I was working with
	this team of 10 developers is presented.},
  owner = {Katia},
  references = {(not available): http://www.cutter.com/content/itjournal/fulltext/2003/02/itj0302d.html

	(not available): Dear diary: the making of an XP team

	(not available): Dear diary: the making of an XP team

	(not available): Dear diary: the making of an XP team

	(not available): Dear diary: the making of an XP team

	(not available): Dear diary: the making of an XP team

	(not available): Dear diary: the making of an XP team

	(not available): Dear diary: the making of an XP team

	(not available): Dear diary: the making of an XP team

	(not available): Dear diary: the making of an XP team

	(not available): Dear diary: the making of an XP team},
  timestamp = {2010.06.22}
}

@ARTICLE{E[143],
    inserir = {false},
  author = {M. Rostaher and M. Hericko},
  title = {Tracking Test First Pair Programming - An Experiment},
  year = {2002},
  abstract = {The authors ran an experiment where a group of professional programmers
	working in pairs and a control group programming alone implemented
	a small system from predefined requirements. Most programmers spent
	between 50% and 60% of time on testing; only the most inexperienced
	spent less. Programmers reported more problems with refactoring than
	testing. The rhythm of switching the driver and navigator role is
	essential for test-first pair programming. The experiment showed
	that partners switched roles 21 times per day on average. The comparison
	of the control group of individuals and the group programming in
	pairs showed that both groups spent almost the same amount of time
	to complete the tasks. The result of this comparison is by applying
	a t-test not statistically significant. We believe that more detailed
	research apart of evaluating test-first programming is needed to
	compare solo vs. pair programming in the investigated group.},
  owner = {Katia},
  references = {Extreme Programming Explained: Embrace Change

	Extreme Programming Installed

	The cast for collaborative programming

	Strengthening the case for pair programming},
  timestamp = {2010.06.21}
}

@ARTICLE{E[144],
    inserir = {false},
  author = {J. Rothman},
  title = {Future fixes [software development management]},
  year = {2003},
  abstract = {With a little common sense and dependable metrics, software developers
	can banish the bug-bucket and keep dreaded rework under control by
	creating a reasonable prediction of a project completion. These measures
	include: historical information, estimation quality factor and fault
	feedback ratio. In addition, critical-chain buffer management can
	help to schedule the project to allow for rework during each task
	or in the planning stage. Agile techniques also offer immediate feedback,
	helping to create fewer defects and less rework. Incorporating such
	techniques as test-first development, automated unit testing and
	pair programming - or at least have another pair of eyes review the
	code. In handling a large project with several agile teams and it
	is unsure if there is enough time to catch all the defects in each
	iteration, plan on a defect search-fix mission on one iteration before
	releasing it to the client.},
  owner = {Katia},
  references = {(not founded): Future fixes [software development management]

	(not founded): Future fixes [software development management]

	(not founded): Future fixes [software development management]

	(not founded): Future fixes [software development management]

	(not founded): Future fixes [software development management]

	(not founded): Future fixes [software development management]

	(not founded): Future fixes [software development management]

	(not founded): Future fixes [software development management]

	(not founded): Future fixes [software development management]

	(not founded): Future fixes [software development management]},
  timestamp = {2010.06.22}
}

@ARTICLE{E[145],
    inserir = {false},
  author = {L. Russell},
  title = {Exclusion, assumptions, and misinterpretation: foes of collaboration},
  year = {2001},
  abstract = {It all started when I was reviewing the comments on an e-question
	posed by M. Heller, executive Web editor of CIO magazine: "Would
	agile software development work in your shop?" As someone who is
	very interested in the practices and, more importantly, the philosophies
	of the agile approaches, I wanted to see what the consensus was.
	I personally have witnessed some surprisingly emotional responses
	from ClOs about the agile approaches: it would never work, it was
	just RAD, prototyping was a bad idea, pair programming was too expensive,
	and so on. I expected to see more of that. There are still men who
	believe that women will always be less technically talented. Society
	may not allow them to say it anymore, but the choices they make confirm
	the belief. Most, I am sure, are not conscious of this belief. Some
	of the articles written by IT professionals, including some in the
	Cutter journals, sound pompous, judgmental, and egotistical, not
	just toward women, but toward anyone who does not share their particular
	view. Dialog is replaced with a good, tough competition, with someone's
	winning requiring that others lose. It strikes me how important it
	is for all of us, regardless of sex, race, or nationality (to say
	nothing of methodology preference!) to set aside the petty focus
	on differences that keep us from connecting. We must all work hard
	to reach out to others, to respect their opinions and skills, even
	when they are different from our own. We must invest time in all
	relationships around us, as we have learned how truly fragile they
	all are. We must be the glue to heal our world. IT has an amazing
	amount of power to do just that, a power as yet untapped .},
  owner = {Katia},
  references = {(not available): http://www.cutter.com/content/itjournal/fulltext/2001/12/itj0112g.html

	(not available): Exclusion, assumptions, and misinterpretation: foes
	of collaboration

	(not available): Exclusion, assumptions, and misinterpretation: foes
	of collaboration

	(not available): Exclusion, assumptions, and misinterpretation: foes
	of collaboration

	(not available): Exclusion, assumptions, and misinterpretation: foes
	of collaboration

	(not available): Exclusion, assumptions, and misinterpretation: foes
	of collaboration

	(not available): Exclusion, assumptions, and misinterpretation: foes
	of collaboration

	(not available): Exclusion, assumptions, and misinterpretation: foes
	of collaboration

	(not available): Exclusion, assumptions, and misinterpretation: foes
	of collaboration

	(not available): Exclusion, assumptions, and misinterpretation: foes
	of collaboration

	(not available): Exclusion, assumptions, and misinterpretation: foes
	of collaboration},
  timestamp = {2010.06.21}
}

@ARTICLE{E[146],
    inserir = {false},
  author = {H. Saiedian and B. W. Weide},
  title = {The new context for software engineering education and training},
  year = {2005},
  abstract = {(no abstract)},
  owner = {Katia},
  references = {Software engineering body of knowledge

	Software’s chronic crisis

	Software engineering programs: dispelling myths and misconceptions},
  timestamp = {2010.06.22}
}

@ARTICLE{E[147],
    inserir = {false},
  author = {D. Sanders},
  title = {Student Perceptions of the suitability of Extreme and Pair Programming},
  year = {2001},
  abstract = {Senior students in a software engineering class were asked to write
	opinion papers regarding the use of Extreme Programming (XP) in a
	software engineering class, and the use of pair programming in an
	introductory programming course. The majority of the students were
	opposed to using XP in the software engineering class, but favored
	the use of pair programming in an introductory programming course.
	Early indications from a pilot study in pair programming are consistent
	with these opinions. The students’ comments are insightful, and should
	be considered before introducing either of these practices into the
	curriculum.},
  owner = {Katia},
  references = {Embracing Change with Extreme Programming

	Pair Programming: Development Times Two

	Extreme Programming Web Site

	Taking Programming to the Exterme Edge

	Extreme Programming: A gentle introduction

	The case for Collaborative Programming

	An Expositionof XP But No Position on XP

	All I Really Need to Know About Pair Programming I Learned in Kindergarten

	Experimenting with Industry’s “Pair-Programming” Model in the Computer
	Science Classroom

	Strengthening the Case for Paired Programming},
  timestamp = {2010.06.21}
}

@ARTICLE{E[148],
    inserir = {false},
  author = {S. Sawicki and L. Brisolara and L. S. lndrusiak and R. Reis},
  title = {Collaborative design using a shared object spaces infrastructure},
  year = {2002},
  abstract = {A collaborative design system strongly depends on the chosen collaboration
	methodology, as well as on its technological infrastructure. This
	article describes the implementation of collaborative service based
	on shared object spaces as technological infrastructure and its methodology
	is based on pair programming. This service is to be incorporated
	in a distributed collaborative environment called Cave. The collaboration
	service implementation presented in this work allows collaboration
	among designers through a data depository. This service is validated
	with a diagram editor that is used as case study.},
  owner = {Katia},
  references = {Projeto Cooperativo no Ambiente Cave

	Ambiente de Apoio 80 projeto de Circuitos Integrados baseado na World
	Wide Web

	Distributed Collaborative design over Cave2 Framework

	Comparative Analysis and Application of Data Repository Infrastructure
	for Collaboration-enabled Distributed Design Environment

	All I Really Need to Know about Pair Program ming I Learned In Kindergarte

	JavaSpaces: principles, patterns, and pratice

	Upper Saddler River

	Modelagem Orientada a Objetos de primitivas de projeto de sistemas
	eletr6nicos voltada para colaboração

	Padrões de Projeto

	Alternatives on Data Repository Infrastructure for Collaborationenabled
	Distrlooted Design Frameworks

	Homero - Urn Editor VHDL Cooperativo via Web

	Ambientes de Projeto de Sistemas Eletrônico},
  timestamp = {2010.06.21}
}

@ARTICLE{E[149],
    inserir = {false},
  author = {J. -G. Schneider and L. Johnston},
  title = {eXtreme Programming - helpful or harmful in educating undergraduates?},
  year = {2005},
  abstract = {Criticism is sometimes leveled at the academic Software Engineering
	community on the basis that current educational practices are too
	document-centric. Both students and practitioners have suggested
	that one of the popular, lighter-weight, agile methods would be a
	better choice. This paper examines the educational goals for undergraduate
	Software Engineering education and considers how they might be met
	by the practices of eXtreme Programming. Our judgment is that education
	about some agile practices could be beneficial for small-scale development.
	However, as it stands now, eXtreme Programming as a package does
	not lend itself for use in educating about large-scale system development
	in tertiary education.},
  owner = {Katia},
  references = {Extreme programming explained: embrace change

	Planning Extreme Programming

	Manifesto for Agile Software Development

	Pattern-oriented software architecture: a system of patterns

	The task-artifact cycle

	Agile software development

	The costs and benefits of pair programming

	Object Oriented Reengineering Patterns

	Refactoring: improving the design of existing code

	Software engineering code of ethics

	Introducing software engineering by means of Extreme Programming

	Teaching XP for real: some initial observations and plans

	Extreme Programming Installed

	Distributed eXtreme Programming

	The Rational Unified Process: An Introduction

	The impact of pair programming on student performance, perception
	and persistence

	Case study: extreme programming in a university environment

	Undergraduate software engineering education

	Improving software inspections by using reading techniques

	Real World Laboratory

	Colleges as communities: taking research on student persistence seriously

	Limitations of Agile Software Processes

	The Effects of "Pair-Pressure" and "Pair-Learning" on Software Engineering
	Education

	In support of student pair-programming

	Extreme programming in software engineering education},
  timestamp = {2010.06.22}
}

@ARTICLE{E[168],
    inserir = {false},
  author = {N. van Schooenderwoert and R. Morsicato},
  title = {Freeing the slave with two masters: an embedded programming team's
	transition to XP},
  year = {2002},
  abstract = {The article looks at one team's experience with extreme programming
	(XP) which began halfway through a three-year development effort.
	The authors then convinced the other team members and management
	to try using XP's planning game and pair programming practices.},
  owner = {Katia},
  references = {(not available): http://www.agilerules.com/publications.phtml: Freeing
	the slave with two masters: an embedded programming team's transition
	to XP

	(not available): Freeing the slave with two masters: an embedded programming
	team's transition to XP

	(not available): Freeing the slave with two masters: an embedded programming
	team's transition to XP

	(not available): Freeing the slave with two masters: an embedded programming
	team's transition to XP

	(not available): Freeing the slave with two masters: an embedded programming
	team's transition to XP

	(not available): Freeing the slave with two masters: an embedded programming
	team's transition to XP

	(not available): Freeing the slave with two masters: an embedded programming
	team's transition to XP

	(not available): Freeing the slave with two masters: an embedded programming
	team's transition to XP

	(not available): Freeing the slave with two masters: an embedded programming
	team's transition to XP

	(not available): Freeing the slave with two masters: an embedded programming
	team's transition to XP

	(not available): Freeing the slave with two masters: an embedded programming
	team's transition to XP},
  timestamp = {2010.06.21}
}

@ARTICLE{E[150],
    inserir = {false},
  author = {M. Scotto and A. Sillitti and G. Succi and T. Vernazza},
  title = {A non-invasive approach to product metrics collection},
  year = {2006},
  abstract = {Software metrics are useful means in helping software engineers to
	develop large and complex software systems. In the past years, many
	software metrics have been proposed in order to represent several
	different concepts such as complexity, coupling, inheritance, reuse,
	etc. However, this requires the collection of large volumes of metrics
	and, without flexible and transparent tools, is nearly impossible
	to collect data accurately. This paper presents the design and the
	implementation of a tool for collecting and analyzing product metrics
	in a non-invasive way.},
  owner = {Katia},
  references = {Principles of Compiler Design

	CCCC (C and C++ Code Counter)

	A Metrics Suite for Object Oriented Design

	CodePro Studio

	A Practical View of Software Measurement and Implementation Experiences
	Within Motorola

	Eclipse Metrics Plugin

	Software Metrics: A Rigorous and Practical Approach,

	Design patterns: elements of reusable object-oriented software

	Implementing Effective Software Metrics Programs

	Elements of Software Science (Operating and programming systems series)

	Object-oriented metrics: measures of complexity

	Software structure metric based on information flow

	A Discipline for Software Engineering

	IBM Clear Case

	JavaCC (Java Compiler Compiler)

	On the translation of languages from left to right

	Semantics of context-free languages

	A Coaching Pattern for XP through Agile Metrics

	Another metric suite for object-oriented programming

	Object-oriented software metrics: a practical guide

	Agile Software Development: Principles, Patterns, and Practices

	A complexity measure

	Extreme programming and Agile processes in software engineering

	Establishing Software Measurement Programs

	Toyota Production System: Beyond Large-Scale Production

	Lessons Learned in Building a Corporate Metrics Program

	A relational approach to software metrics

	Measures for mobile users: an architecture

	Package-Oriented Software Engineering: A Generic Architecture

	What can we do about the unnecessary diversity of notation for syntactic
	definitions?

	Compiler construction

	Predicting Software Reliability

	XML Protocol working group},
  timestamp = {2010.06.22}
}

@ARTICLE{E[151],
    inserir = {false},
  author = {D. Settas and S. Bibi and P. Sfetsos and I. Stamelos},
  title = {Using Bayesian belief networks to model software project management
	antipatterns},
  year = {2006},
  abstract = {In spite of numerous traditional and agile software project management
	models proposed, process and project modeling still remains an open
	issue. This paper proposes a Bayesian network (BN) approach for modeling
	software project management antipatterns. This approach provides
	a framework for project managers, who would like to model the cause-effect
	relationships that underlie an antipattern, taking into account the
	inherent uncertainty of a software project. The approach is exemplified
	through a specific BN model of an antipattern. The antipattern is
	modeled using the empirical results of a controlled experiment on
	extreme programming (XP) that investigated the impact of developer
	personalities and temperaments on communication, collaboration-pair
	viability and effectiveness in pair programming. The resulting BN
	model provides the precise mathematical model of a project management
	antipattern and can be used to measure and handle uncertainty in
	mathematical terms.},
  owner = {Katia},
  references = {The Effect of Decision Style on the Use of a Project Management Tool:
	An Empirical Laboratory Study

	Software Project Management

	”Skip” McCormick III

	BBN-based software project risk management

	”Skip” McCormick III

	Antipatterns: Identification, Refactoring, and Management, Taylor
	and Francis

	A project management support tool using communication for agile software
	development

	Software Process Modeling with Bayesian Belief Networks

	Making Resource Decisions for Software Projects

	Project Planning: Improved approach incorporating uncertainty

	On the use of Bayesian belief networks for the prediction of software
	productivity

	Agile and Iterative Development. A Manager’s Guide

	Investigating the Impact of Personality Types on Communication and
	Collaboration-Viability in Pair Programming - An Empirical Study

	Extreme Programming Refactored: The Case Against XP

	Antipractices: AntiPatterns for XP Practices

	Management Teams: Why They Succeed or Fail

	Who should work with whom? Building effective software project teams

	Software Project Secrets. Why Software Projects Fail

	Pair Programming Illuminated

	The uncertainty principle in Software Engineering

	Bayesian Networks and Decision Graphs

	PowerConstructor System

	PreProcessor System

	Manual: The Myers-Briggs Type Indicator},
  timestamp = {2010.06.22}
}

@ARTICLE{E[152],
    inserir = {false},
  author = {P. Sfetsos and L. Angelis and I. Stamelos},
  title = {Investigating the extreme programming system - an empirical study},
  year = {2006},
  abstract = {In this paper we discuss our empirical study about the advantages
	and difficulties 15 Greek software companies experienced applying
	extreme programming (XP) as a holistic system in software development.
	Based on a generic XP system including feedback influences and using
	a cause-effect model including social-technical affecting factors,
	as our research tool, the study statistically evaluates the application
	of XP practices in the software companies being studied. Data were
	collected from 30 managers and developers, using the sample survey
	technique with questionnaires and interviews, in a time period of
	six months. Practices were analysed individually, using descriptive
	statistics (DS), and as a whole by building up different models using
	stepwise discriminant analysis (DA). The results have shown that
	companies, facing various problems with common code ownership, on-site
	customer, 40-hour week and metaphor, prefer to develop their own
	tailored XP method and way of working-practices that met their requirements.
	Pair programming and test-driven development were found to be the
	most significant success factors. Interactions and hidden dependencies
	for the majority of the practices as well as communication and synergy
	between skilled personnel were found to be other significant success
	factors. The contribution of this preliminary research work is to
	provide some evidence that may assist companies in evaluating whether
	the XP system as a holistic framework would suit their current situation.},
  owner = {Katia},
  references = {XP Lite considered harmful?

	Experimentation in software engineering

	Embracing Change with Extreme Programming

	Extreme programming explained: embrace change

	No Silver Bullet Essence and Accidents of Software Engineering

	How distance between subject and interviewer affects the application
	of qualitative research to extreme programming

	The costs and benefits of pair programming, extreme programming and
	flexible processes in software engineering

	Agile software development

	Success factors and barriers for software process improvement

	Finding success in small software projects

	On the Effectiveness of the Test-First Approach to Programming

	The role of process measurement in test-driven development

	The economics of software development by pair programmers

	An initial investigation of test driven development in industry

	A Prototype Empirical Evaluation of Test Driven Development

	Qualitative studies of XP in a medium sized business

	The Discovery of grounded theory: strategies for qualitative research

	Information systems development and data modeling: conceptual and
	philosophical foundations

	A multiple case study on the impact of pair programming on product
	quality

	Extreme programming installed

	An introduction to systems thinking

	Principles of multivariate analysis: a user's perspective

	Motivations and measurements in an agile case study

	Exploring Extreme Programming in Context: An Industrial Case Study

	Feedback in the software evolution process

	Naturalistic inquiry

	Agile Software Development in Large Organizations

	A cross-program investigation of students' perceptions of agile methods

	Extreme Programming: Rapid Development for Web-Based Application

	Extreme programming from an engineering economics viewpoint

	On the economic evaluation of XP projects

	Experiment about test-first programming

	The case for collaborative programming

	Analyzing the Cost and Benefit of Pair Programming

	Qualitative evaluation and research methods

	Extreme Programming from a CMM Perspective

	How to Get the Most out of Extreme Programming/Agile Methods

	Quantitative survey on extreme programming projects

	Qualitative Methods in Empirical Studies of Software Engineering

	Fifth discipline-the art and practice of the learning organization

	Requirements Engineering: A Good Practice Guide

	Basics of qualitative research: grounded theory procedures and techniques

	Introduction to qualitative research methods

	A belief system model for software development: a framework by analogy

	On the economic feasibility of pair programming

	Strengthening the Case for Pair Programming

	Building Pair Programming Knowledge through a Family of Experiments

	Test-Driven Development as a Defect-Reduction Practice

	Toward a framework for evaluating extreme programming

	Experimentation in software engineering: an introduction},
  timestamp = {2010.06.22}
}

@ARTICLE{I[50],
    inserir = {true},
  author = {P. Sfetsos and I. Stamelos and L. Angelis and I. Deligiannis},
  title = {Investigating the impact of personality types on communication and
	collaboration-viability in pair programming - an empirical study},
  year = {2006},
  abstract = {This paper presents two controlled experiments (a pilot and the main
	one) investigating the impact of developer personalities and temperaments
	on communication, collaboration-pair viability and ultimately effectiveness
	in pair programming. The objective of the experiments was to compare
	pairs of mixed/heterogeneous developer personalities and temperaments
	with pairs of the same personalities and temperaments, in terms of
	pair effectiveness. Pair effectiveness is expressed in terms of pair
	performance, measured by communication, velocity, productivity and
	customer satisfaction, and pair collaboration-viability measured
	by developers' satisfaction, knowledge acquisition and participation
	(collaboration satisfaction ratio, nuisance ratio, voluntary or mandatory
	preference, and driver or navigator preference). The results have
	shown that there is significant difference between the two groups,
	indicating better communication and collaboration-viability for the
	pairs with mixed personalities/temperaments.},
  owner = {Katia},
  references = {A Methodology for Collecting Valid Software Engineering Data

	The TAME Project: Towards Improvement- Oriented Software Environments

	Extreme Programming Explained: Embrace Change

	Practical Guidelines For Measurement-Based Process Improvement

	Empirical Studies of Object-Oriented Artifacts, Methods, and Processes:
	State of the Ar and Future Directions

	The Coffee Machine Design Problem: Part 1 & 2. C/C++ User’s Journal

	Agile Software Development

	Communication Metrics for Software Development

	Agile Software Development Ecosystems

	On Under-standing Compatibility of Student Pair Programmers

	Please Understand Me II

	Communication, Collaboration, and Cooperation in Software Development
	— How Should We Support Group Work in Software Development?

	An Empirical Study of Communication in Code Inspections

	Investigating The Extreme Programming System - An Empirical Study

	Experimentation in Software Engineering: An Introduction},
  timestamp = {2010.06.22}
}

@ARTICLE{I[53],
    inserir = {true},
  author = {X. Shaochun and V. Rajlich},
  title = {Empirical validation of test-driven pair programming in game development},
  year = {2006},
  abstract = {This paper investigates the effects of some extreme programming practices
	in game development by conducting a case study with 12 students who
	were assigned to implement a simple game application either as pairs
	or as individuals. The pairs used some XP practices, such as pair
	programming, test-driven and refactoring, while the individuals applied
	the traditional waterfall-like approach. The results of the case
	study showed that paired students completed their tasks faster and
	with higher quality than individuals. The programs written by pairs
	pass more test cases than those developed by individuals. Paired
	programmers also wrote cleaner code with higher cohesion by creating
	more reasonable number of methods. Therefore, some XP practices,
	such as pair programming, test-driven and refactoring could be used
	in game development.},
  owner = {Katia},
  references = {Extreme Programming Explained

	Test-Driving development: by Example

	Working in pairs as a means for design knowledge building: an empirical
	study

	Feature-driven development

	The costs and benefits of pair programming

	Collaborating in Game Design

	Refactoring: Improving the Design of Existing Code

	An initial investigation of test driven development in industry

	Unit Test Frameworks

	By the Books: Solid Software Engineering for Games

	Games from within: GDC 2004: Software Engineering Roundtable Summary

	Stepping Through the Looking Glass: Test-Driven Game Development

	Microsoft Producer for Microsoft Office Powerpoint 2003

	Experiment about test-first programming

	Experimental evaluation of pair programming

	The case for collaborative programming

	Software Engineering A Practitioner's Approach

	Agile Software Development with SCRUM

	On pair rotation in the computer science course

	In support of student pair-programming

	Strengthening the case for pair-programming

	Dialog-based protocol: an empirical research method for cognitive
	activity in software engineering},
  timestamp = {2010.06.22}
}

@ARTICLE{E[153],
    inserir = {false},
  author = {X. Shaochun and V. Rajlich},
  title = {Dialog-based protocol: an empirical research method for cognitive
	activities in software engineering},
  year = {2005},
  abstract = {This paper proposes dialog-based protocol for the study of the cognitive
	activities during software development and evolution. The dialog-based
	protocol, derived from the idea of pair programming, is a significant
	alternative to the common think-aloud protocol, because it lessens
	the Hawthorne and placebo effects. Using screen-capturing and voice
	recording instead of videotaping further reduces the Hawthorne effect.
	The self-directed learning theory provides an encoding scheme and
	can be used in analyzing the data. A case study illustrates this
	new approach.},
  owner = {Katia},
  references = {The hawthorne effect: a reconsideration of the methodological artifact

	The role of experimentation in software engineering: past, present,
	future

	Extreme Programming Explained

	Using protocol analysis to evaluate the usability of a commercial
	web site

	The role of instruction and verbalization in improving performance
	on complex search tasks

	Program understanding and the concept assignment problem

	Taxonomy of Educational Objectives: The Classification of Educational
	Goals: Handbook, I, Cognitive Domain

	Dowsing: A tool framework for domain-oriented browsing of software
	artifacts

	Voice and perspective: Hearing epistemological innovation in students’
	words

	Extending Children's Special Abilities: Strategies for Primary Classrooms

	Protocol Analysis: Verbal Reports as Data

	Discourse analysis as a research method in library and information
	science

	ACT-PRO: action protocol tracer -- a tool for analyzing discrete action
	protocols

	An approach to the analysis of design protocols

	Change episodes in coding: When and how do programmers change their
	code?

	Bloom et al.’s taxonomy of the cognitive domain: educational psychology
	interactive

	Preliminary guidelines for empirical research in software engineering

	Can concurrent verbalization reveal design cognition?

	Analysis of solving problems

	Microsoft Producer for Microsoft Office Powerpoint 2003

	Human Problem Solving

	Small group design meetings: an analysis of collaboration

	Demand characteristics and the concept of quasi-controls

	The limits of empirical studies of software engineering

	Comprehension strategies in programming

	The Construction of Reality in the Child

	Analogy of incremental program development and constructivist learning

	Measuring cognitive activities in software engineering

	The effects of early data returns on data subsequently obtained by
	outcome biased experimenter

	Experimenter Effects in Behavioral Research

	The relevance of application domain knowledge: the case of computer
	program comprehension

	Hierarchical task analysis and training decisions

	A coding scheme to support analysis of software comprehension

	Identification of dynamic comprehension processes during large scale
	maintenance

	Is thinking merely the action of language mechanism?

	Cognitive process during program debugging

	An empirical study of programmer learning during incremental software
	development},
  timestamp = {2010.06.22}
}

@ARTICLE{I[52],
    inserir = {true},
  author = {X. Shaochun and V. Rajlich},
  title = {Pair Programming in Graduate Software Engineering Course Projects},
  year = {2005},
  abstract = {Pair programming has been used in undergraduate classes in order to
	develop student skills and to enhance student learning. Experiments
	with such an approach have demonstrated positive effects. This paper
	investigates the effects of pair programming in the graduate software
	engineering class by conducting a case study with six students who
	were assigned to work on incremental changes on an open source application
	either as pairs or as individuals. The results of the case study
	showed that paired students completed their change request tasks
	faster and with higher quality than individuals. They also wrote
	less lines of code and used more meaningful variable names. Pair
	programming could be an effective and useful approach for graduate
	software engineering classes.},
  owner = {Katia},
  references = {Extreme programming explained

	Distributed group working in Session F1G0-7803-9077-6/05/$20.00

	Working in pairs as a means for design knowledge building: an empirical
	study

	The costs and benefits of pair programming

	A transition from partner programming to pair programming - an industrial
	case study

	A practical approach of teaching software engineering

	Introducing software engineering by means of extreme programming

	Software Engineering Education Knowledge (SEEK): Second Draft

	The effects of pair-programming on performance in an introductory
	programming course

	Case study: extreme programming in a university environment

	Experimental evaluation of pair programming

	The case for collaborative programming

	Teaching software engineering through collaborative methods

	eXtreme programming at universities - an educational perspective

	Software Engineering

	On pair rotation in the computer science course

	Virtual teaming: experiments and experiences with distributed pair
	programming

	Limitations of agile software processes

	In support of student pairprogramming

	Strengthening the case for pair-programming

	Building pair programming knowledge through a family of experiments},
  timestamp = {2010.06.22}
}

@ARTICLE{E[154],
    inserir = {false},
  author = {X. Shaochun and C. Xuhui},
  title = {Pair programming in software evolution},
  year = {2006},
  abstract = {This paper presents an experiment on pair programming in software
	evolution. Six graduate students are involved in the experiment,
	in which four of them form two pairs and the rest two are required
	to work individually. The experiment enables a study that compares
	pair programming with traditional individual programming. The result
	of experiment on six incremental change tasks shows that programmer
	pairs not only work more efficiently than individual programmers,
	they also write higher quality and clearer code. The result also
	shows the discrepancy in change propagation, when programming pairs
	miss only one and the individual programmers miss four out of eighteen.
	Meanwhile, there is a significant decrease in the programming pairs'
	use of time for last two change requests. Based on the experiment,
	it may be concluded that programming pairs are a better solution
	for urgent maintenance tasks than individual programmers.},
  owner = {Katia},
  references = {The Hawthorne effect: A reconsideration of the methodological artifact

	Extreme programming explained

	Case Study of Feature Location Using Dependece Graph

	Experimental Methodology

	The costs and benefits of pair programming

	Analyzing distributed cognition in software teams: A case study of
	team programming during perfective software maintenance

	An initial framework for research on pair programming

	Implications of evolution metrics on software maintenance

	Experimental evaluation of pair programming

	The Case for Collaborative Programming

	A staged model for the software lifecycle

	Incremental change in Object-Oriented Programming

	The staged model of the software lifecycle

	Strengthening the Case for Pair-Programming

	Building pair programming knowledge through a family of experiments},
  timestamp = {2010.06.22}
}

@ARTICLE{E[155],
    inserir = {false},
  author = {L. B. Sherrell and J. J. Robertson},
  title = {Pair Programming and Agile Software Development: Experiences in a
	College Setting},
  year = {2006},
  abstract = {While agile software development methodologies are now becoming more
	commonplace in industry, they have yet to be fully embraced by academic
	institutions. To better prepare university students for the marketplace,
	it is important that students are familiar with these alternative
	software development methods. For those unacquainted with agile methodologies,
	this paper first provides a summary of agile practices and a review
	of reports on teaching these practices in college classrooms. Next
	it discusses a study that the authors conducted in a graduate course
	entitled Software Development Process Models, in which the students
	were required to use eXtreme Programming practices. The discussion
	describes course assignments and the results from a survey that was
	administered to assess students’ perceptions of their experiences
	using pair programming and agile methods.},
  owner = {Katia},
  references = {Extreme programming explained: embrace change

	Manifesto for agile software development

	Balancing Agility and Discipline: A Guide for the Perplexed

	Journey of enlightenment: the evolution of development at Microsoft

	Experiences with pair programming at a small college

	Being extreme in the classroom: Experiences teaching XP

	Program quality with pair programming in CS1

	Empirical Findings in Agile Methods

	Extreme programming in a university project

	Overview of agile management project perfect

	Extreme Software Engineering A Hands-On Approach

	Experimenting with industry's "Pair-Programming" model in the computer
	science classroom},
  timestamp = {2010.06.22}
}

@ARTICLE{E[156],
    inserir = {false},
  author = {A. Shukla},
  title = {Pair programming and the factors affecting Brooks' law},
  year = {2002},
  abstract = {Frederick Brooks states in his book The Mythical Man-Month , "Adding
	manpower to a late software project makes it later." Brooks explains
	that often software development managers react to schedule problems
	by adding more manpower to the project. However, the new team members
	take some time initially to be trained and assimilated into the project.
	Assimilation time is the time the new team member takes to understand
	project specific details. Also, if the subprojects assigned to each
	engineer are interrelated, intercommunication requirements rise since
	each part of the task must be separately coordinated with each other
	part. Thus, Brooks contends that when manpower is added to a late
	project the overall productivity goes down, delaying the project
	even further. This research investigates the effects of pair programming
	on the training, assimilation and intercommunication, as mentioned
	in Brooks' Law. Pair programming is a practice in which two programmers
	work together at one computer, continuously collaborating on the
	same design, algorithm, code, or test. Most software development
	teams that practice pair programming also practice pair rotation.
	With pair rotation, engineers periodically change their pairing partner.
	Pair programming and pair rotation have previously been shown to
	aid teams in improving code and design quality and to improve teamwork.
	In this research, we investigated additional benefits of the pair
	programming and pair rotation practices. Through surveys and mathematically
	modeling, we found the following: (1) Pair programming reduces intercommunication
	time within a team. (2) Pair programming reduces mentoring time when
	new members are added to a team. (3) Pair programming reduces assimilation
	time when new members are added to a team. (4) Manpower can be added
	to a late software project provided the additional useful effort
	delivered to the project is adequate to achieve the desired schedule.
	Pair programming can make this more achievable.},
  owner = {Katia},
  references = {(not available): http://portal.acm.org/citation.cfm?id=890429: Pair
	programming and the factors affecting Brooks' law

	(not available): Pair programming and the factors affecting Brooks'
	law

	(not available): Pair programming and the factors affecting Brooks'
	law

	(not available): Pair programming and the factors affecting Brooks'
	law

	(not available): Pair programming and the factors affecting Brooks'
	law

	(not available): Pair programming and the factors affecting Brooks'
	law

	(not available): Pair programming and the factors affecting Brooks'
	law

	(not available): Pair programming and the factors affecting Brooks'
	law

	(not available): Pair programming and the factors affecting Brooks'
	law

	(not available): Pair programming and the factors affecting Brooks'
	law

	(not available): Pair programming and the factors affecting Brooks'
	law},
  timestamp = {2010.06.21}
}

@ARTICLE{E[157],
    inserir = {false},
  author = {A. Shukla and L. Williams},
  title = {Adapting Extreme Programming for a core Software Engineering Course},
  year = {2002},
  abstract = {Over a decade ago, the manufacturing industry determined it needed
	to be more agile to

	thrive and prosper in a changing, nonlinear, uncertain and unpredictable
	business environment. Recently, the software engineering community
	has come to the same realization. A group of software methodologists
	has created a set of software development processes, termed agile
	methodologies that have been specifically designed to respond to
	the demands of the turbulent software industry. Each of the processes
	in the set of agile processes is comprised of a set of practices.
	As educators, we must assess the emerging agile practices, integrate
	them into our courses (carefully), and share our experiences and
	results from doing so. This paper discusses the use of Extreme Programming,
	a popular agile methodology, in a senior Software Engineering course
	at North Carolina State University. It then provides recommendations
	for integrating

	agile principles into a core Software Engineering course.},
  owner = {Katia},
  references = {A Discipline for Software Engineering

	The Unified Software Development Process

	How Internet Companies Build Software

	Developing Products on "Internet Time": The Anatomy of a Flexible
	Development Process

	Using the WinWin Spiral Model: A Case Study

	Extreme Programming Explained: Embrace Change

	Agile Software Development

	Adaptive Software Development

	DSDM: The Method in Practice

	Crystal "Clear": A human-powered software development methodology
	for small teams

	Java Modeling in Color with UML

	The Scrum Software Development Process for Small Teams

	Agile Competition is Spreading to the World

	The Collaborative Software Process PhD Dissertation

	Writing Effective Use Cases

	Object-Oriented Software Engineering: A Use Case Driven Approach

	The CRC Card Book

	UML Distilled

	Introduction to the Team Software Process

	In Support of Student Pair Programming

	The Effects of "Pair-Pressure" and "Pair-Learning" on Software Engineering
	Education

	All I Ever Needed to Know About Pair Programming I Learned in Kindergarten

	Extreme Programming Installed

	Refactoring: Improving the Design of Existing Code},
  timestamp = {2010.06.21}
}

@ARTICLE{I[69],
    inserir = {true},
  author = {B. Simon and B. Hanks},
  title = {First year students' impressions of pair programming in CS1},
  year = {2007},
  abstract = {Pair programming, as part of the Agile Development process, has noted
	benefits in professional software development scenarios. These successes
	have led to a rise in use of pair programming in educational settings,
	particularly in Computer Science 1 (CS1). Specifically, McDowell
	et al. [2006] has shown that students using pair programming in CS1
	do better in a CS2 class (with solo programming) than students who
	don't pair in CS1. This paper seeks to address a similar question,
	but from a qualitative, student-focused approach. How do students
	define, experience, and value the pair programming experience? How
	do they experience and value it compared to solo programming? Does
	pairing in CS1 impact their confidence in their abilities? We report
	on semi-structured interviews with 11 subjects from two institutions
	where pair programming was used in CS1, and solo programming was
	used in the CS2. Many of the responses met our expectations; students
	get stuck less and explore more ideas while pairing, and believe
	that pair programming helped them in CS1. Other responses were more
	surprising. Students reported that when solo programming they were
	more confident and understood their programs better. Many students
	also said that they started work on their assignments earlier when
	soloing. Students also continue to use other students as resources
	even when working solo.},
  owner = {Katia},
  references = {Empirical studies of distributed pair programming

	Program quality with pair programming in CS1

	On understanding compatibility of student pair programmers

	Unlocking the Clubhouse: Women in Computing

	The impact of pair programming on student performance, perception
	and persistence

	Pair programming improves student retention, confidence, and program
	quality

	Perceptions of Agile Practices: A Student Survey

	Code warriors and code-a-phobes: a study in attitude and pair programming

	Coupling pair programming and writing: learning about students' perceptions
	and processes

	Pair-programming helps female computer science students},
  timestamp = {2010.06.23}
}

@ARTICLE{I[51],
    inserir = {true},
  author = {K. M. Slaten and S. B. Berenson and L. Williams and L. Layman and
	M. Droujkova},
  title = {Undergraduate student perceptions of pair programming and agile software
	methodologies: verifying a model of social interaction},
  year = {2005},
  abstract = {One of the reasons that undergraduate students, particularly women
	and minorities, can become disenchanted with computer science education
	is because software development is wrongly characterized as a solitary
	activity. We conducted a collective case study in a software engineering
	course at North Carolina State University to ascertain the effects
	of a collaborative pedagogy intervention on student perceptions.
	The pedagogy intervention was based upon the practices of agile software
	development with a focus on pair programming. Six representative
	students in the course participated in the study. Their perspectives
	helped validate a social interaction model of student views. The
	findings suggest that pair programming and agile software methodologies
	contribute to more effective learning opportunities for computer
	science students and that students understand and appreciate these
	benefits.},
  owner = {Katia},
  references = {Educating Girls in the New Computer Age

	Iterative Enhancement: A Practical Technique for Software Development

	Extreme Programming Explained: Embrace Change

	Voices of Women in a Software Engineering Course: Reflections on Collaboration

	Using Pair Programming and Agile Development Methods in a University
	Software Engineering Course to Develop a Model of Social Interactions

	A Spiral Model for Software Development and Enhancement

	The Costs and Benefits of Pair Programming

	Qualitative inquiry and research design: Choosing among five traditions

	Three Problems Overcome with Behavioral Models of the Software Development
	Process (Panel)

	Agile and Iterative Development: A Manager's Guide

	A History of Iterative and Incremental Development

	Situated Learning: Legitimate peripheral participation

	Geek Mythology and Attracting Undergraduate Women to Computer Science

	Unlocking the Clubhouse: Women in Computing

	Qualitative Methods in Empirical Studies of Software Engineering

	Discourse and learning in the classroom: A sociocultural approach

	In Support of Pair Programming in the Introductory Computer Science
	Course

	The Collaborative Software Process PhD Dissertation},
  timestamp = {2010.06.22}
}

@ARTICLE{E[158],
    inserir = {false},
  author = {M. B. Smrtic and G. Grinstein},
  title = {A case study in the use of extreme programming in an academic environment},
  year = {2004},
  abstract = {A group of graduate students working in a lab in a university have
	more distractions than a typical software development group in industry.
	With more distractions and fewer hours on site does it still make
	sense to use extreme programming (XP) in the development of software?
	Here we discuss our experience using XP in an academic environment
	in which the members of the development group have different schedules
	and other projects. We found that pair programming was an efficient
	and effective way to learn and share knowledge, and that unit testing
	and just-in-time design helped us get to an early, though scaled
	down release. Our interpretation of pair programming felt limited
	and awkward at first until we realized that we could and should spend
	time independently learning and researching the tasks in addition
	to the work we do in pairs.},
  owner = {Katia},
  references = {The Visual Display of Quantitative Information

	Extreme Programming Explained

	In support of student pair-programming

	Extreme Programming Installed},
  timestamp = {2010.06.22}
}

@ARTICLE{I[10],
    inserir = {true},
  author = {H. Srikanth and L. Williams and E. Wiebe and C. Miller and S. Balik},
  title = {On Pair Rotation in the Computer Science Course},
  year = {2004},
  abstract = {In a course environment, pairing a student with one partner for the
	entire semester is beneficial, but may not be optimal. The authors
	conducted a study in two undergraduate levelcourses to observe the
	advantages and disadvantages of pair rotation whereby a student pairs
	with several different students throughout the semester. This paper
	summarizes teaching staff and student perceptions on the viability
	of pair rotation. Teachers find pair rotation valuable because the
	teaching staff can obtain multiple peer evaluations on each student
	and because dysfunctional pairs are regularly disbanded. However,
	pair rotation adds to the burden of assigning pairs multiple times
	per semester. The majority of students in the study perceived pair
	rotation to be a desirable approach. Additionally, most students
	considered peer evaluation to be an effective means of providing
	feedback to teaching staff. However, they did not significantly believe
	that peer evaluation was an effective means for motivating students.},
  owner = {Katia},
  references = {Extreme Programming Explained: Embrace Change

	Extreme Programming and the Software Design Course

	The Impact of Pair Programming on Student Performance of Computer
	Science Related Majors

	Perceptions of Agile Practices: A Student Survey

	Student Perceptions of the Suitability of Extreme and Pair Programming

	Code Warriors and Code-a-Phobes: A study in attitude and pair programming

	Pair Programming Illuminated

	Strengthening the Case for Pair-Programming

	Building Pair Programming Knowledge Through a Family of Experiments

	In Support of Pair Programming in the Introductory Computer Science
	Course

	The Collaborative Software Process PhD Dissertation},
  timestamp = {2010.06.22}
}

@ARTICLE{E[159],
    inserir = {false},
  author = {G. Srinivasa and P. Ganesan},
  title = {Pair programming: addressing key process areas of the People-CMM},
  year = {2002},
  abstract = {It has been long recognized that the quality of the people employed
	by a software organization is a major determinant of the quality
	of its products. Acknowledging the pivotal role played by people
	in software development, the Software Engineering Institute (SEI)
	devised the People - Capability Maturity Model. Like its software
	counterpart, the People CMM (P-CMM) defines five levels of maturity.
	An organization can achieve a level by institutionalizing the "best
	practices" for that level. The best practices are grouped together
	as Key Process Areas (KPAs). Pair programming is a practice in which
	two programmers work together at one computer on a single module
	of code designing, coding and testing it together. Evidence indicates
	that pair programming improves teamwork, communication and knowledge
	levels - all KPAs of the P-CMM. This paper establishes a link between
	pair programming and the KPAs defined in the P-CMM. Specifically,
	the paper provides an outline on the advantages and effects of adopting
	pair programming if an organization wants to achieve a higher P-CMM
	level.},
  owner = {Katia},
  references = {People Capability Maturity Model

	Managing technical people: innovation, teamwork and the software process

	The Cost and benefits of Pair Programming

	The Effects of “Pair-Pressure” and “Pair-Learning” on Software Engineering
	Education

	The Case for Collaborative Programming

	The Collaborative Software Process

	Strengthening the Case for Pair-Programming

	Experimenting with Industry’s “Pair Programming” Model in the Computer
	Science Classroom

	Pair Programming Illuminated

	Extreme Programming from a CMM Perspective},
  timestamp = {2010.06.21}
}

@ARTICLE{E[160],
    inserir = {false},
  author = {D. Stotts and J. McC. Smith and K. Gyllstrom},
  title = {Support for distributed pair programming in the transparent video
	facetop},
  year = {2004},
  abstract = {The transparent video facetop is a user interface concept that supports
	not only single-user interactions with a PC, but also close pair
	collaborations, such as that found in collaborative Web browsing,
	remote medicine, and in distributed pair programming. In this paper
	we discuss the use of a video-based UI called the facetop (Stotts
	et al., 2004) for solving several problems reported to us by teams
	doing distributed pair programming. Specifically, the facetop allows
	a distributed pair to recapture some the facial expressions and face-to-face
	communications contact lost in earlier distributed sessions. It also
	allows members of a distributed pair to point conveniently, quickly,
	and naturally to their shared work, in the same manner (manually)
	that they do when seated side-by-side. Our results enhance the ability
	of organizations to do effective XP-style agile development with
	distributed teams.},
  owner = {Katia},
  references = {Extreme Programming Explained

	Extreme Programming: A Gentle Introduction

	The Costs and Benefits of Pair Programming

	Integration of inter-personal space and shared workspace: ClearBoard
	design and experiments

	The VideoWindow System in Informal Communications

	Exploring the Efficacy of Distributed Pair Programming

	Exploring Pair Programming in Distributed Object-Oriented Team Projects

	A Taxonomy of See-Through Tools: The Video, Xerox PARC

	SnapLink: Interactive Object Registration and Recognition for Augmented
	Desk Interface

	User Embodiment in Collaborative Virtual Environments

	Transparent Layered User Interfaces: An Evaluation of a Display Design
	to Enhance Focused and Divided Attention

	Tracking of multi-state hand models using particle filtering and a
	hierarchy of multi-scale image features

	Virtual Teaming: Experiments and Experiences with Distributed Pair
	Programming,

	The Vis-a-Vid Transparent Video FaceTop

	The Case for Collaborative Programming

	Distance Matters

	The Collaborative Software Process

	Windows screen reader

	Distributed Pair Programming: An Empirical Study},
  timestamp = {2010.06.22}
}

@ARTICLE{E[161],
    inserir = {false},
  author = {D. Stotts and L. Williams and P. Baheti and D. Jen and A. Jackson},
  title = {Virtual teaming: Experiments and experiences with distributed pair
	programming},
  year = {2003},
  abstract = {Pair programming is a practice in which two programmers work together
	at one computer, collaborating on the same design, algorithm, code
	or test. Previous studies have shown that pair programmers produce
	higher quality code in essentially the same amount of time as solo
	programmers. Additional benefits include increased job satisfaction,
	improved team communication, and efficient tacit knowledge sharing.
	However, it may not always be possible for all team members to be
	collocated due to the rise in teleworking and geographically distributed
	teams. This paper analyzes the results of two distributed pair programming
	case studies done at UNC Chapel Hill and at NC State University.
	Participants used readily available off-the-shelf applications for
	collaborative software development. The results indicate that software
	development collaboratively "over the wire" is feasible, effective,
	and pleasant for the participants; distributed development is better
	done as synchronous pairs than as individuals who integrate; and
	distributed pairs maintain many of the advantages of collocated pairs.},
  owner = {Katia},
  references = {Exploring the Efficacy of Distributed Pair Programming

	Exploring Pair Programming in Distributed Object-Oriented Team Projects

	Extreme Programming Explained: Embrace Change

	Test Driven Development -- by Example

	Communication Metrics for Software Development

	The Boundless Team: Virtual Teaming

	A Multidisciplinary Virtual Team

	An Initial Investigation of Test-Driven Development in Industry

	Leading Virtual Teams

	A Discipline for Software Engineering

	Distributed Development: Insights, Challenges, and Solutions

	Virtual Project Management: Software Solutions for Today and the Future

	The Case for Collaborative Programming

	Distance Matters

	A Video-Enhanced Environment for Distributed Extreme Programming

	This Campus is Being Simulated

	Pair Programming Illuminated

	Strengthening the Case for Pair-Programming,

	The Collaborative Software Process PhD Dissertation},
  timestamp = {2010.06.22}
}

@ARTICLE{E[163],
    inserir = {false},
  author = {G. Succi and W. Pedrycz and M. Marchesi and L. Williams},
  title = {Preliminary Analysis of the effects of pair programming on job satisfaction},
  year = {2002},
  abstract = {Pair programming is one of the most controversial parts of XP. Claims
	are mostly based on anecdotal evidence and limited experimentation
	performed in classroom settings. This paper reports the preliminary
	results of an analysis of the effects of pair programming on job
	satisfaction. A questionnaire on pair programming techniques has
	been compiled and posted on the web. 108 responses have been collected
	from around the world. The preliminary results evidence a very positive
	effect of pair programming on job satisfaction.},
  owner = {Katia},
  references = {Applying the Goal/Question/Metric Paradigm in the Experience factory

	Extreme Programming Explained – Embracing the Change

	Experimental and Quasi-Experimental Designs for Research

	Applied multivariate statistics for the social sciences},
  timestamp = {2010.06.21}
}

@ARTICLE{E[162],
    inserir = {false},
  author = {G. Succi and M. Stefanovic and W. Pedrycz},
  title = {Quantitative assessment of extreme programming practices},
  year = {2001},
  abstract = {Some anecdotal evidence demonstrates success of the extreme programming
	practice in a portion of the software industry. It has also been
	argued that pair programming, as as a part of the extreme programming
	process, yields higher quality software products in less time. On
	the other hand, these principles are sometimes questioned with respect
	to resource allocation and management issues. Although precise information
	about benefits and costs of the extreme programming practice represents
	a critical guideline for improvement of software quality, there has
	been little work on the subject beyond subjective reports and a study
	in an academic environment. We propose an experimental framework
	to quantify benefits and costs of the pair programming practice and
	compare design aspects of the resulting software products and their
	defect behavior. For this purpose, we use a set of object-oriented
	metrics and software reliability growth models based on service requests.},
  owner = {Katia},
  references = {A Validation of Object-Oriented Design Metrics as Quality Indicators

	Experimentation in Software Engineering

	A method for collecting valid software engineering data

	Extreme Programming Explained: Embrace Change

	On the Application of Measurement Theory in Software Engineering

	The impact of Design on Development Cost in Object-Oriented Systems

	Managerial Use of Object-Oriented Software: An Explanatory Analysis

	A Metrics Suite for Object Oriented Design

	The Costs and Benefits of Pair Programming

	A Critique of Software Defect Prediction Models

	Software Metrics: A Rigorous and Practical Approach

	Predicting Fault Incidence Using Software Change History

	A comparison of techniques for developing predictive models of software
	metrics

	Validation of an Approach for Improving Existing Measurement Frameworks

	Zero-inflated poisson regression with an application to defects in
	manufacturing

	Stochastic Reliability Growth: A Model for Fault Removal in Computer
	Programs and 6 Hardware Design

	Statistical Analysis of Categorical Data

	Regression Models for Categorical and Limited Dependent Variables,
	Advanced Quantitative Techniques in the Social Sciences

	Handbook of Software Reliability Engineering

	Advanced Software Engineering Models for Quality Improvement

	Empirical Analysis of Pre-Release Service Requests for Real Time Software
	Systems

	Predicting Software Service Requests

	Strengthening the Case for Pair Programming

	The Collaborative Software Process

	Predicting Software Reliability},
  timestamp = {2010.06.21}
}

@ARTICLE{E[164],
    inserir = {false},
  author = {J. Sun and X. Liu},
  title = {Rate-based software reliability process simulation},
  year = {2004},
  abstract = {Rate-based software reliability process simulation treats software
	development processes as stochastic processes controlled by rate
	functions. It's the natural expansion of the traditional analytical
	software reliability models. This simulation technique can be used
	to predict the software reliability in the early stages of development
	process and simulate many development processes with different characteristics
	by constructing corresponding rate functions. This paper explains
	the mathematic founding of the rate-based software reliability process
	simulation and presents realization approaches of single event process
	simulation and multi-event process simulation. This paper also presents
	an application which has simulated the influence of two development
	methods, competitive design and pair programming, to the software
	reliability by using Softrel.},
  owner = {Katia},
  references = {(not founded): Rate-based software reliability process simulation

	(not founded): Rate-based software reliability process simulation

	(not founded): Rate-based software reliability process simulation

	(not founded): Rate-based software reliability process simulation

	(not founded): Rate-based software reliability process simulation

	(not founded): Rate-based software reliability process simulation

	(not founded): Rate-based software reliability process simulation

	(not founded): Rate-based software reliability process simulation

	(not founded): Rate-based software reliability process simulation

	(not founded): Rate-based software reliability process simulation},
  timestamp = {2010.06.22}
}

@ARTICLE{E[165],
    inserir = {false},
  author = {A. Taweel and P. Brereton},
  title = {Modelling software development across time zones},
  year = {2006},
  abstract = {Economic factors and the World Wide Web are turning software usage
	and its development into global activities. Many benefits accrue
	from global development not least from the opportunity to reduce
	time-to-market through `around the clock' working. This paper identified
	some of the factors and constraints that influence time-to-market
	when software is developed across time zones. It describes a model
	of the relationships between development time and the factors and
	overheads associated with such a pattern of work. The paper also
	reports on a small-scale empirical study of software development
	across time zones and presents some lessons learned and conclusions
	drawn from the theoretical and empirical work carried out.},
  owner = {Katia},
  references = {Computer support in project coordination

	Issues in co-operative software engineering using globally distributed
	teams

	Global Software Teams: Collaborating Across Borders and Time Zones

	An empirical study of global software development: distance and speed

	The Mythical Man-Month: Essays on Software Engineering

	Teamwork is the Key to Remote Development

	Computerworld

	Information richness: a new approach to managerial behavior and organization
	design

	Face-to-face: making network organizations work

	Supporting globally distributed engineering design teams with communication
	technologies

	A study of communication and cooperation in distributed software project
	teams

	CAIRO: A System for Facilitating Communication in a Distributed Collaborative
	Engineering Environment

	Communication and organization in software development: an empirical
	study

	Enhancing virtual teams: relations vs. communication technology

	Software Engineering

	Developing software across time zone: an exploratory empirical study

	Virtual Teams: Reaching Across Space, Time and Organizations with
	Technology

	On managing virtual team

	A case study of successful geographically separated teamwork

	Distributed group working in software engineering education

	The role of trust in virtual teams

	Strengthening the case for pair-programming},
  timestamp = {2010.06.22}
}

@ARTICLE{I[54],
    inserir = {true},
  author = {L. Thomas and M. Ratcliffe and A. Robertson},
  title = {Code warriors and code-a-phobes: a study in attitude and pair programming},
  year = {2003},
  abstract = {This paper reports on how first-year students who have programmed
	before see their programming interest and ability and how this self-perception
	relates to their performance in the introductory programming course.
	In particular we examine how this self-perception is reflected in
	their reactions to the pairprogramming

	technique for developing software. Students who had programming experience
	before University were given a survey that placed them on a scale
	that we have

	called Code Warrior to Code-a-phobe. We then placed them in opposite
	and similar pairs for a pair programming exercise and surveyed their
	reactions. There was evidence that students who have considerable
	self-confidence do not enjoy the experience of pair programming as
	much as other students and that students produce their best work
	when placed in pairs with students of similar self-confidence levels.},
  owner = {Katia},
  references = {Extreme Programming Explained

	Managing Diversity: Experiences Teaching Programming Principles

	A Multi-National, Multi-Institutional Study of Assessment of Programming
	Skills of First-year CS Students

	The Effects of Pair Programming on Performance in an Introductory
	Programming Course

	A Pedagogically Driven, Directed Learning Environment

	Learning Styles and Performance in the Introductory Programming Sequence

	Combating the Code Warrior: A Different Sort of Programming Instruction

	The Psychology of Computer Programming

	Strengthening the Case for Pair- Programming

	Pair-Programming" Model in the Computer Science Classroom},
  timestamp = {2010.06.23}
}

@ARTICLE{E[166],
    inserir = {false},
  author = {M. Timpe},
  title = {Pair programming and testing in a medical web project},
  year = {2001},
  abstract = {(no abstract)},
  owner = {Katia},
  references = {(not founded): Pair programming and testing in a medical web project

	(not founded): Pair programming and testing in a medical web project

	(not founded): Pair programming and testing in a medical web project

	(not founded): Pair programming and testing in a medical web project

	(not founded): Pair programming and testing in a medical web project

	(not founded): Pair programming and testing in a medical web project

	(not founded): Pair programming and testing in a medical web project

	(not founded): Pair programming and testing in a medical web project

	(not founded): Pair programming and testing in a medical web project

	(not founded): Pair programming and testing in a medical web project},
  timestamp = {2010.06.21}
}

@ARTICLE{I[55],
    inserir = {true},
  author = {J. E. Tomayko},
  title = {A Comparison of Pair Programming to Inspections for Software Defect
	Reduction},
  year = {2002},
  abstract = {Even though convinced of their efficacy, software development managers
	are looking for ways to reduce the cost of inspections. Recent work
	shows that inspections by two engineers have as good results as by
	using a larger team of five. This indicates that pair programming
	might be effective as an inspection technique, as other research
	shows that a meeting is not necessarily better than not meeting.
	An experiment was conducted to see if pair programming reduces defects
	more than formal inspections. Results indicate that pair programming
	is more effective. A defect rate of 9.6 per thousand lines of code,
	much lower than that of a heavier method, were achieved. The implications
	for teaching are explored.},
  owner = {Katia},
  references = {Extreme programming explained

	Design and code inspections to reduce errors in program development

	A discipline of software engineering

	Introduction to the Team Software Process

	Software craftsmanship

	Assessing software review meetings: Results of a Comparative analysis
	of two experimental studies

	An experiment to asses the costs of code inspections in large scale
	software development

	Adapting problem frames to eXtreme Programming

	All I really know about pair programming I learned in kindergarten},
  timestamp = {2010.06.21}
}

@ARTICLE{E[167],
    inserir = {false},
  author = {S. Ur and E. Yom-Tov and P. Wernick},
  title = {An open source simulation model of software development and testing},
  year = {2006},
  abstract = {This paper describes a new discrete event simulation model built using
	a mathematical tool (Matlab) to investigate the simulation of the
	programming and the testing phases of a software development project.
	In order to show how the model can be used and to provide some preliminary
	concrete results, we give three examples of how this model can be
	utilized to examine the effect of adopting different strategies for
	coding and testing a new software system. Specifically, we provide
	results of simulation runs intended to simulate the effects on the
	coding and testing phases of different testing strategies, the adoption
	of pair programming in an otherwise-unchanged process, and the automation
	of testing.},
  owner = {Katia},
  references = {Extreme programming explained: embrace change

	Estimating software costs

	Applied software measurement: assuring productivity and quality

	An initial investigation of test driven development in industry

	Locating causes of program failures

	IBM Rational Unified Process: Best practices for software development
	teams

	An Encompassing Life-Cycle Centric Survey of Software Inspection

	System dynamics modeling of an inspection-based process

	When should a test be automated?

	Assessing test-driven development at IBM

	Regression testing in an industrial environment

	Guest Editors' Introduction: Special Issue on Software Process Simulation
	Modelling

	Analyzing Regression Test Selection Techniques

	The Impact of Using Pair Programming on System Evolution: A Simulation-Based
	Study

	Guest Editors' Introduction: Special Issue on ProSim 2003

	Strengthening the Case for Pair Programming},
  timestamp = {2010.06.22}
}

@ARTICLE{I[56],
    inserir = {true},
  author = {T. VanDeGrift},
  title = {Coupling pair programming and writing: learning about students' perceptions
	and processes},
  year = {2004},
  abstract = {Pair programming has been successful in many introductory computer
	science courses. Its success has manifested in increased retention
	rates, better performance on programming tasks, increased confidence,
	and decreased frustration. This paper highlights experiences using
	pair programming coupled with individual written reports in a large,
	introductory computer science course. Through analysis of survey
	data and written reports, our study shows that students perceive
	benefits in pair programming, such as those documented earlier (social
	structure, peer help, less frustration, reduced workload). Regarding
	the written reports, students cited benefits such as a chance to
	summarize their project, to reflect on the code, and to use new vocabulary.
	We discuss what we learn about students' processes, their challenges,
	and the resources they use for supporting their learning.},
  owner = {Katia},
  references = {Computing Curricula 2001: Final Draft

	Content Analysis for the Social Sciences and Humanities

	A Technical Writing Class for Computer Science Majors: Measuring Student
	Perceptions of Learning

	The Impact of Pair Programming on Student Performance, Perception,
	and Persistence

	Improving the CS1 Experience with Pair Programming

	Learning Essays and the Reflective Learner: Supporting Reflection
	in Engineering Design Education

	Pair Programming in an Introductory Computer Science Course: Initial
	Results and Recommendations

	All I Really Need to Know About Pair Programming I Learned in Kindergarten},
  timestamp = {2010.06.22}
}

@ARTICLE{E[170],
    inserir = {false},
  author = {J. Vanhanen and J. Itkonen and P. Sulonen},
  title = {Improving the interface between business and product development
	using agile practices and the cycles of control framework},
  year = {2003},
  abstract = {We describe how we created and adopted an agile product development
	process in a small software company based on the cycles of control
	framework by combining selected agile practices and principles from
	the scrum and XP methodologies. Describing the development process
	using the framework helped in identifying the crucial control points
	between business and development and enabled defining practical and
	well-functioning connections between them. The control points enable
	visibility and flexible management of product development status
	and direction. Currently business understands development status
	better, which has led to fewer interruptions between the control
	points, and thus improved working conditions for development. Positive
	experiences are reported of newly adopted practices such as scrum
	meetings, pair programming, and unit testing. However, finding and
	adopting technical tools to facilitate the process proved to be challenging.},
  owner = {Katia},
  references = {Extreme Programming Explained

	Agile Software Development

	4CC: A Framework for Managing Software Product Development

	Agile Software Development with Scrum

	An Approach to Product Roadmapping in Small Software Product Businesses

	Key Decisions in Strategic New Product Development for Small Software
	Product Businesses

	Pair Programming Illuminated},
  timestamp = {2010.06.22}
}

@ARTICLE{E[169],
    inserir = {false},
  author = {J. Vanhanen and H. Korpi},
  title = {Experiences of using pair programming in an agile project},
  year = {2007},
  abstract = {The interest in pair programming (PP) has increased recently, e.g.
	by the popularization of agile software development. However, many
	practicalities of PP are poorly understood. We present experiences
	of using PP extensively in an industrial project. The fact that the
	team had a limited number of high-end workstations forced it in a
	positive way to quick deployment and rigorous use of PP. The developers
	liked PP and learned it easily. Initially, the pairs were not rotated
	frequently but adopting daily, random rotation improved the situation.
	Frequent rotation seemed to improve knowledge transfer. The driver/navigator
	roles were switched seldom, but still the partners communicated actively.
	The navigator rarely spotted defects during coding, but the released
	code contained almost no defects. Test-driven development and design
	in pairs possibly decreased defects. The developers considered that
	PP improved quality and knowledge transfer, and was better suited
	for complex tasks than for easy tasks.},
  owner = {Katia},
  references = {Pair Programming Illuminated

	The Collaborative Software Process

	The Case for Collaborative Programming

	Effects of Pair Programming at the Development Team Level: An Experiment

	The Costs and Benefits of Pair Programming

	Experimental Evaluation of Pair Programming

	Tracking Test First Pair Programming – An Experiment, Extreme Programming
	and Agile Methods

	The Benefits of Collaboration for Student Programmers

	Extreme Programming Explained

	Software Development Worldwide: The State of the Practice

	An Initial Framework for Research on Pair Programming

	Subclassing XP: Breaking its rules the right way

	Agile Methods Applied to Embedded Firmware Development

	Application of Tightly Coupled Engineering Team for Development of
	Test Automation Software – A Real World Experience

	Extreme Programming Practices: What’s on Top?

	Qualitative Studies of XP in a Medium Sized Business

	Technical and Human Perspectives on Pair Programming

	Social Behaviors on XP and non-XP teams: A Comparative Study

	Paired Programming & Personality Traits

	An Ethnographic Study of XP Practice

	Promiscuous Pairing and Beginner’s Mind: Embrace Inexperience

	Double trouble: Mixing qualitative and quantitative methods in the
	study of eXtreme Programmers

	A Framework for Understanding the Factors Influencing Pair Programming
	success

	A Pair Programming Experience

	Pair programming and the re-appropriation of individual tools for
	collaborative programming

	Experiences in Learning XP Practices: A qualitative Study

	Case Study Research: Design and Methods},
  timestamp = {2010.06.22}
}

@ARTICLE{I[57],
    inserir = {true},
  author = {J. Vanhanen and C. Lassenius},
  title = {Effects of pair programming at the development team level: an experiment},
  year = {2005},
  abstract = {We studied the effects of pair programming in a team context on productivity,
	defects, design quality, knowledge transfer and enjoyment of work.
	Randomly formed three pair programming and two solo programming teams
	performed the same 400-hour fixed-effort project. Pair programming
	increased the development effort of the first tasks considerably
	compared to solo programming, but later the differences were small.
	Due to this learning time the pair programming teams had worse overall
	project productivity. Task complexity did not affect the effort differences
	between solo and pair programming. The pair programming teams wrote
	code with fewer defects, but were less careful in system testing,
	and therefore delivered systems with more defects. They may have
	relied too much on the peer review taking place during programming.
	Knowledge transfer seemed to be higher within the pair programming
	teams. Finally, we also found weak support for higher enjoyment of
	work in the pair programming teams.},
  owner = {Katia},
  references = {Pair Programming Illuminated

	The Collaborative Software Process

	The Case for Collaborative Programming

	The Costs and Benefits of Pair Programming

	On the Economic Feasibility of Pair Programming

	Analyzing the Cost and Benefit of Pair Programming

	Modeling the Impact of a Learning Phase on the Business Value of a
	Pair Programming Project

	An Initial Framework for Research on Pair Programming

	Design of a controlled experiment on pair programming

	Experimental Evaluation of Pair Programming

	Tracking Test First Pair Programming – An Experiment

	The Benefits of Collaboration for Student Programmers

	Experiences with a Case Study on Pair Programming

	Exploring the Efficacy of Distributed Pair Programming

	Are Reviews an Alternative to Pair Programming?

	The Effects of Pair-Programming on Performance in an Introductory
	Programming Course

	Experimenting with Pair Programming in the Classroom

	The Impact of Pair Programming on Student Performance, Perception,
	and Persistence

	Improving the CS1 Experience with Pair Programming

	Program quality with pair programming in CS1

	Preliminary guidelines for empirical research in software engineering

	Basics of Software Engineering Experimentation

	A Software Complexity Measure

	Social Facilitation from Triplett to Electronic Performance Monitoring

	Nonparametric statistics for the behavioral sciences

	Paired Programming & Personality Traits},
  timestamp = {2010.06.22}
}

@ARTICLE{E[171],
    inserir = {false},
  author = {V. A. Visaggio},
  title = {Empirical validation of pair programming},
  year = {2005},
  abstract = {This paper discusses an empirical assessment of pair programming.
	Several agile processes arose and have been adopted in industry with
	the promise of producing working software in the early phases of
	production process and to make the organization flexible and adaptable
	with respect to the changing environment. The outcomes of the experiments
	can be summarized as follows: (i) pair programming improves the productivity
	of developers with respect to solo programming; (ii) it also fosters
	knowledge transfer between the developers of the pair: the experiment
	suggests that this effect is emphasized when both the components
	own the same educational background; and, finally, (iii) distributing
	the components of a pair could seriously deteriorate expected benefits,
	if an appropriate support for communication and collaboration is
	not set up.},
  owner = {Katia},
  references = {Software modeling and measurement: the Goal/Question/Metric paradigm

	Building Knowledge through Families of Experiments

	The effects of pair-programming on performance in an introductory
	programming course},
  timestamp = {2010.06.22}
}

@ARTICLE{E[172],
    inserir = {false},
  author = {K. Visram},
  title = {Extreme programming: Pair-programmers, team players or future leaders?},
  year = {2004},
  abstract = {This paper will establish that a productive working relationship can
	be enhanced in an Extreme Programming (XP) Pair-Programming Team
	if Team members here were to develop and improve their own individual
	Emotional Intelligence (EI) persona. A conceptual model (ARMES) was
	developed for personal traits identified for Pair-Programmers. The
	validity of this ARMES model for Pair-Programming was tested against
	two (previously published) XP Case Studies. Finally, implications
	of the conclusions were discussed along with suggested areas of future
	research.},
  owner = {Katia},
  references = {(not available): http://www.actapress.com/Abstract.aspx?paperId=17598:
	Extreme programming: Pair-programmers, team players or future leaders?

	(not available): Extreme programming: Pair-programmers, team players
	or future leaders?

	(not available): Extreme programming: Pair-programmers, team players
	or future leaders?

	(not available): Extreme programming: Pair-programmers, team players
	or future leaders?

	(not available): Extreme programming: Pair-programmers, team players
	or future leaders?

	(not available): Extreme programming: Pair-programmers, team players
	or future leaders?

	(not available): Extreme programming: Pair-programmers, team players
	or future leaders?

	(not available): Extreme programming: Pair-programmers, team players
	or future leaders?

	(not available): Extreme programming: Pair-programmers, team players
	or future leaders?

	(not available): Extreme programming: Pair-programmers, team players
	or future leaders?

	(not available): Extreme programming: Pair-programmers, team players
	or future leaders?},
  timestamp = {2010.06.22}
}

@ARTICLE{E[173],
    inserir = {false},
  author = {C. A. Wellington},
  title = {Managing a project course using Extreme Programming},
  year = {2005},
  abstract = {Shippensburg University offers an upper division project course in
	which the students use a variant of Extreme Programming (XP) including:
	the Planning Game, the Iteration Planning Game, test driven development,
	stand-up meetings and pair programming. We start the course with
	two weeks of controlled lab exercises designed to teach the students
	about test driven development in JUnit/Eclipse and designing for
	testability (with the humble dialog box design pattern) while practicing
	pair programming. The rest of our semester is spent in three four-week
	iterations developing a product for a customer. Our teams are generally
	large (14-16 students) so that the projects can be large enough to
	motivate the use of configuration management and defect tracking
	tools. The requirement of pair programming limits the amount of project
	work the students can do outside of class, so class time is spent
	on the projects and teaching is on-demand individual mentoring with
	lectures/labs inserted as necessary. One significant challenge in
	managing this course is tracking individual responsibilities and
	activities to ensure that all of the students are fully engaged in
	the project. To accomplish this, we have modified the story and task
	cards from XP to provide feedback to the students and track individual
	performance against goals as part of the students' grades. The resulting
	course has been well received by the students. This paper will describe
	this course in more detail and assess its effect on students' software
	engineering background through students' feedback and code metrics.},
  owner = {Katia},
  references = {Extreme Programming Explained

	Planning Extreme Programming

	The Humble Dialog Box

	Refactoring: Improving the Design of Existing Code

	Ann Anderson and Chet Hendrickson

	Craig Agile & Iterative Development – A Manager’s Guide

	Preparing Computer Science Students to Question and Improve a Software
	Development Process

	Strengthening the Case for Pair-Programming

	Extreme Programming Explored},
  timestamp = {2010.06.22}
}

@ARTICLE{E[176],
    inserir = {false},
  author = {L. L. Werner and J. Denner and S. Bean},
  title = {Pair Programming Strategies for Middle School Girls},
  year = {2005},
  abstract = {A large gender gap exists with who designs and produces new computer
	technology; men overwhelmingly dominate the field. Studies have shown
	that women are more likely to pursue and persist in computer science
	when they have the confidence to problem-solve and explore without
	fear of breaking the computer, see social aspects of computing, and
	see a value to computing consistent with their self identity. Pair
	programming, developed for use in software design as part of the
	extreme programming methodology, puts two people working together
	at all phases of software development. Pair programming is also a
	collaborative, instructional approach, shown to increase learning,
	investment, and interest in computer science among both male and
	female university students, in particular females. We are studying
	pair programming with middle school girls for the purpose of devising
	a controlled study of the benefits. This paper will describe how
	we have implemented pair programming in the middle school environment
	and what we have learned so far about how this approach may benefit
	girls. We describe our current strategies so that others may use
	this collaborative approach both for experimentation and for practical
	application.},
  owner = {Katia},
  references = {Preschool children’s computer interest and competence: effects of
	sex and gender role

	Computers in American schools

	Sex related differences in attitudes toward computers: implications
	for counselors

	Sex differences on the California statewide assessment of computer
	literacy

	Investigating the impact of elements of educational mathematics software
	on girls’ attitudes

	Workforce study

	Unfinished Business: Women in Silicon Valley Economy

	The effects of age, gender, and computer experience upon computer
	attitudes

	Tech-savvy: educating girls in the new computer age

	A fulfilling career? Factors which influence women’s choice of profession

	Unlocking the clubhouse: women in computing

	Getting started with computers: experience, anxiety, and relational
	style

	Being Fluent with Information Technology

	Taking stock: where we’ve been, where we are, where we’re going

	Upping the numbers: using research-based decision making to increase
	diversity in the quantitative disciplines

	Growing smart: what’s working for girls in school

	Storytelling as a nexus of change in the relationship between gender
	and technology: a feminist approach to software design

	Extreme programming explained: embrace change

	In support of pair programming

	The impact of pair programming on student performance, perception,
	and persistence

	Peer interactive minds: developmental, theoretical, and methodological
	issues

	Mediated activity in the primary classroom: girls, boys and computers

	Girls teach themselves, and boys too: peer learning in a computer-based
	design and construction activity

	Give and take: children collaborating on one computer

	Playing together beats playing apart, especially for girls

	All I really need to know about pair programming I learned in kindergarten},
  timestamp = {2010.06.22}
}

@ARTICLE{E[174],
    inserir = {false},
  author = {L. L. Werner and B. Hanks and C. McDowell},
  title = {Pair-Programming Helps Female Computer Science Students},
  year = {2004},
  abstract = {Pair-programming has been found to be very beneficial in educational
	settings. Students who pair in their introductory programming course
	are more confident, have greater course completion and pass rates,
	and are more likely to persist in computer-related majors. Although
	pairing helps all students, we believe that it is particularly beneficial
	for women because it addresses several significant factors that limit
	women's participation in computer science. We provide reasons for
	our belief that pair-programming helps women persist in these majors.
	We also repeat, with special emphasis on the impact on women, some
	details published elsewhere regarding our experiments on pair-programming
	with college and university students. Additionally, we provide new
	data that supports our original findings.},
  owner = {Katia},
  references = {Extreme Programming Explained: Embrace Change

	Voices of women in a software engineering course: Reflections on collaboration

	Guidelines for the use of pair programming in a freshman programming
	class

	The incredible shrinking pipeline

	Women in computer science: Reversing the trend

	Java 1.5 Program Design

	The impact of pair programming on student performance, perception,
	and persistence

	A fulfilling career? Factors which influence women’s choice of profession

	The American freshman: National norms for fall 2000

	The effects of "pair-pressure" and "pair-learning" on software engineering
	education

	All I really need to know about pair programming I learned in kindergarten},
  timestamp = {2010.06.22}
}

@ARTICLE{E[175],
    inserir = {false},
  author = {P. Wernick and T. Hall},
  title = {The impact of using pair programming on system evolution a simulation-based
	study},
  year = {2004},
  abstract = {In this paper we investigate the impact of pair programming on the
	long term evolution of software systems. We use system dynamics to
	build simulation models which predict the trend in system growth
	with and without pair programming. Initial results suggest that the
	extra effort needed for two people to code together may generate
	sufficient benefit to justify pair programming.},
  owner = {Katia},
  references = {Software Project Dynamics – An Integrated Approach

	Using risk to balance agile and plandriven methods

	Modelling A Software Evolution Process

	Introducing an agile process to an organization

	A Framework for System Dynamic Models of Software Acquisition Projects

	Extreme Programming from a CMM Perspective

	Evaluating the Effectiveness of Process Improvements on Software Development
	Life Cycle Time via System Dynamic Modelling

	The Reference Model for Smooth Growth of Software Systems Revisited

	Simulating Global Software Evolution Processes by Combining Simple
	Models: An Initial Study

	Software Process Dynamic Modelling for FEAST/1

	Agile software development: It’s about feedback and change

	Strengthening the Case for Pair Programming},
  timestamp = {2010.06.22}
}

@ARTICLE{E[177],
    inserir = {false},
  author = {E. N. Wiebe and L. Williams and J. Petlick and S. Balik and C. Miller
	and M. Ferzli},
  title = {Pair Programming in Introductory Programming Labs},
  year = {2003},
  abstract = {This project looks at the practice of pair programming as a vehicle
	for improving the learning environment in introductory computer science
	labs, a nearly universal course for all engineering students. Pair
	programming is a practice in which two programmers work collaboratively
	at one computer, on the same design, algorithm, or code. Prior research
	indicates that pair programmers produce higher quality code in essentially
	half the time taken by solo programmers. A multiyear project is currently
	underway at North Carolina State University, looking at the efficacy
	of pair programming in an introductory Computer Science (CS1) course.
	Results indicate that student pair programmers are more self-sufficient
	in lab and are more likely to complete the class with a grade of
	C or better. The effect of pair programming on specific graded exams
	and projects are less clear. Demographic data, prior achievement
	scores, and current course scores were brought together with interview
	data, attitude surveys, and in-lab observations to guide the evaluation.
	As part of the in-lab data collection, novel techniques are being
	developed to better understand pair dynamics and student/instructor
	interactions. Collectively, these evaluative methods have guided
	the iterative implementation of paired programming instructional
	methods. Current challenges being addressed include lab instructor
	training, student/instructor concerns over equity in effort on assignments,
	pair dynamics in lab, and collaborative logistics of pair programming
	outside of lab.},
  owner = {Katia},
  references = {Extreme programming explained: Embrace change

	The costs and benefits of pair programming

	Strengthening the case for pair programming

	The Collaborative Software Process

	Experimenting with industry's "pair-programming" model in the computer
	science classroom

	Guidelines for the Use of Pair Programming in a Freshman Programming
	Class

	The Effects of Pair Programming on Performance in an Introductory
	Programming Course

	In support of paired programming in the introductory computer science
	course

	Fennema-Sherman mathematics attitudes scales

	Computer Science Attitude Survey

	Paired Programming Project: Focus Groups with Teaching Assistants
	and Students

	Equity issues in collaborative group assessment: Group composition
	and performance

	The Myers-Briggs personality type and its relationship to computer
	programming

	Equity issues in computer-based collaboration: Looking beyond surface
	indicators},
  timestamp = {2010.06.22}
}

@ARTICLE{E[178],
    inserir = {false},
  author = {L. A. William and R. R. Kessler},
  title = {Experiments with industry's "pair-programming" model in the computer
	science classroom},
  year = {2001},
  abstract = {Anecdotal evidence from several sources, primarily in industry, indicates
	that two programmers working collaboratively on the same design,
	algorithm, code, or test perform substantially better than the two
	working alone. Two courses taught at the University of Utah studied
	the use of this technique, often called pair-programming or collaborative
	programming, in the undergraduate computer science classroom. The
	students applied a positive form of "pair-pressure" on each other,
	which proved beneficial to the quality of their work products. The
	students also benefit from "pair-learning" which allowed them to
	learn new languages faster and better than with solitary learning.
	The workload of the teaching staff is reduced because the students
	more often look to each other for technical support and advice.},
  owner = {Katia},
  references = {Extreme programming explained: embrace change

	Guidelines for the Use of Pair Programming in a Freshman Programming
	Class

	The effects of pair-programming on performance in an introductory
	programming course

	The impact of pair programming on student performance, perception
	and persistence

	Improving the CS1 experience with pair programming

	The case for collaborative programming

	Student Perceptions of the Suitability of Extreme and Pair Programming

	Code warriors and code-a-phobes: a study in attitude and pair programming

	Strengthening the Case for Pair Programming

	In support of student pair-programming

	In Support of Pair Programming in the Introductory Computer Science
	Course

	All I really need to know about pair programming I learned in kindergarten

	The Effects of "Pair-Pressure" and "Pair-Learning" on Software Engineering
	Education

	Experiments with Industry's "Pair--Programming" Model in the Computer
	Science Classroom},
  timestamp = {2010.06.21}
}

@ARTICLE{I[72],
    inserir = {true},
  author = {A. T. Williams},
  title = {Pair formation in CS1: Self-selection vs random pairing},
  year = {2007},
  abstract = {Attrition in Computer Science education is at its highest level in
	the last 20 years. Many researchers are searching for practices to
	decrease the attrition rate nationwide. Pair programming has been
	borrowed from industry and placed in today's computer science academic
	environment. Many studies have shown that pair programming increases
	students' confidence levels and aids in the retention of those students
	that have selected computer science as their academic major. This
	research builds on this premise and investigates the effects of self-selection
	and random methods of pair formation. These methods of pair formation
	were used in beginning computer science courses at a historically
	black college and university (HBCU) to statistically demonstrate
	that students prefer to self-select their partner. Honoring this
	preference aids in the students overall satisfaction with beginning
	CS courses therefore decreasing the students possibility of changing
	their academic major. Data will show that in a CS1 course, the election
	to implement random or self-selection pair formation is trivial and
	students will perform equally whether the pairs are assigned or self-selected,
	however self-selection aids in the satisfaction of a student and
	therefore impacts their decision to retain computer science as their
	major.},
  owner = {Katia},
  references = {The Carnegie Classification of Institutions of Higher Education

	Exploring the Efficacy of Distributed Pair Programming

	Exploring Pair Programming in Distrubuted Object-Oriented Team Projects

	Extreme Programming Explained: Embrace Change

	Cooperative learning techniques in CS1: design and experimental evaluation

	Voices of women in a software engineering course: reflections on collaboration

	Teaching software development methods: the case of extreme programming

	Guidelines for the Use of Pair Programming in a Freshman Programming
	Class

	Gender differences in computer science students

	Experiences with pair programming at a small college

	The Costs and Benefits of Pair Programming

	Must there be so few?: including women in CS

	Toward improving female retention in the computer science major

	Pair programming and pair trading: effects on learning and motivation
	in a CS2 course

	Our Profile: School of Science and Technology

	Conflict in collaborative software development

	Pair Programming: More Learning and Less Anxiety in a First Programming
	Course

	Student performance in CS1 with distributed pair programming

	Program Quality with Pair Programming in CS1

	An Initial Framework for Research on Pair Programming

	Enhancing CS programming lab courses using collaborative editors

	Examining the Impact of Pair Programming on Female Students

	What is XP

	Priming the pipeline

	Towards Increasing the Compatibility of Student Pair Programmers

	On Understanding Compatibility of Student Pair Programmers

	Project Management and Mythical Manmonths

	Extreme programming promotes extreme learning?

	Geek Mythology and Attracting Undergraduate Women to Computer Science

	Unlocking the Clubhouse: Womed in Computing

	An Empirical Study about the Feelgood Factor in Pair Programming

	Experimenting with Pair Programming in the Classroom

	The Effects of Pair Programming on Performance in an Introductory
	Programming Course

	Pair Programming Improves Student Retention

	The Impact of Pair Programming on Student Performance, Perception
	and Persistence

	Affective assessment of team skills in agile CS1 labs: the good, the
	bad, and the ugly

	Developing collaborative skills early in the CS curriculum in a laboratory
	environment

	Perceptions of Agile Practices: A Student Survey

	Case study: extreme programming in a university environment

	Improving the CS1 Experience with Pair Programming

	Experimental Evaluation of Pair Programming

	The case for collaborative programming

	Knowledge management through pair programming

	Pair Programming as a Model of Collaborative Learning: A Review of
	the Research

	Using collaborative learning research to enhance pair programming
	pedagogy

	Student Perceptions of the Suitability of Extreme and Pair Programmng

	Pair programming and the factors affecting Brooks' Law"

	Undergraduate Student Perceptions of Pair Programming and Agile Software
	Methodologies: Verifying a Model of Social Interaction

	On Pair Rotation in the Computer Science Course

	Virtual Teaming: Experiments and Experiences with Distributed Pair
	Programming

	Extreme Programming Examined

	Reciprocal peer reviews

	Code warriors and code-a-phobes: a study in attitude and pair programming

	Coupling pair programming and writing: learning about students' perceptions
	and processes

	Pair-programming helps female computer science students

	Pair Programming in Introductory Programming Labs

	But, isn't that cheating?

	The Collaborative Software Process

	Debunking the Nerd Stereotype with Pair Programming

	All I Really Need to Know about Pair Programming I Learned In Kindergarten

	The effects of "pair pressure" and "pair-learning" on software engineering
	education

	Experimenting with Industry's "Pair-Programming" Model in the Computer
	Science Classroom"

	Pair Programming Illuminated

	Strengthening the Case for Pair-Programming

	Building Pair Programming Knowledge through a Family of Experiments

	In Support of Student Pair Programming

	In Support of Pair Programming in the Introductory Computer Science
	Course

	Pair Programming in an Introductory Computer Science Course: Initial
	Results and Recommendations

	An empirical study of the tacit knowledge management potential of
	pair programming

	The benefits of collaboration for student programmers},
  timestamp = {2010.06.23}
}

@ARTICLE{E[179],
    inserir = {false},
  author = {L. Williams},
  title = {Debunking the nerd stereotype with pair programming},
  year = {2006},
  abstract = {Our studies show that using pair programming as a structure for incorporating
	collaboration in the classroom helps increase and broaden participation
	in computing fields and helps debunk the myth that programmers work
	alone all the time. It's also a way for students to get a better
	view of and feel more confident in their preparation for working
	in the real world. The face of the IT workforce is changing. As the
	millennial generation makes its way into the working world, the archetype
	of the nerd as the introverted, obsessed computer programmer must
	share equal space with the chatty, social software engineer.},
  owner = {Katia},
  references = {Boomers, Gen-Xers, and Millennials: Understanding the New Students

	Educating the Net Generation

	Managing Millennials

	Unlocking the Clubhouse: Women in Computing

	Studying Students Studying Calculus: A Look at the Lives of Minority
	Mathematics Students in College

	Personality Types, Learning Styles, and an Agile Approach to Software
	Engineering Education

	Student Diversity Requires Different Approaches to College Teaching,
	Even in Math and Science

	Educating Girls in the New Computer Age

	The Supply of Information Technology Workers in the United States

	The Collaborative Software Process

	Pair Programming Illuminated

	Building Pair Programming Knowledge through a Family of Experiments

	Understanding Student Perceptions of Pair Programming and Agile Software
	Development Methodologies: Verifying a Model of Social Interaction},
  timestamp = {2010.06.22}
}

@ARTICLE{E[180],
    inserir = {false},
  author = {L. Williams},
  title = {Integrating pair programming into a software development process},
  year = {2001},
  abstract = {Anecdotal and statistical evidence indicates that pair programmers
	- two programmers working side-by-side at one computer collaborating
	on the same design, algorithm, code or test - outperform individual
	programmers. One of the programmers (the driver) has control of the
	keyboard/mouse and actively implements the program. The other programmer
	(the observer) continuously observes the work of the driver to identify
	tactical (syntactic, spelling, etc.) defects, and also thinks strategically
	about the direction of the work. On demand, the two programmers can
	brainstorm any challenging problem. Because the two programmers periodically
	switch roles, they work together as equals to develop software. This
	practice of pair programming can be integrated into any software
	development process. As an example, this paper describes the changes
	that were made to the Personal Software Process (PSP) to leverage
	the power of two programmers working together, thereby formulating
	the Collaborative Software Process (CSP). The paper also discusses
	the expected results of incorporating pair programming into a software
	development process in which traditional, individual programming
	is currently used.},
  owner = {Katia},
  references = {The Case for Collaborative Programming

	Programming In Pairs

	Strengthening the Case for Pair-Programming

	Constantine on Peopleware

	A Development Process Generative Pattern Language

	A Discipline for Software Engineering

	The Collaborative Software Process PhD Dissertation

	Extreme Programming Explained: Embrace Change

	The Unified Software Development Process

	All I Ever Needed to Know About Pair Programming I Learned in Kindergarten

	Investigating Data Quality Problems in the PSP (Experience Paper)

	Advances in software inspections to reduce errors in program development

	Reengineering Inspection: The Future of Formal Technical Review

	The Psychological Cost of Learning to Kill in War and Society

	The Costs and Benefits of Pair Programming

	Software Quality: Analysis and Guidelines for Success

	Introduction to the Team Software Process},
  timestamp = {2010.06.21}
}

@ARTICLE{E[181],
    inserir = {false},
  author = {L. Williams},
  title = {But, isn't that cheating? [collaborative programming]},
  year = {1999},
  abstract = {Can university computer science students benefit from collaborative
	programming? The author discusses his experiences with a class he
	taught at the University of Utah which set out to study pair programming
	in an educational setting. The class, an Active Server Pages (ASP)
	web programming class, consisted of 20 juniors and seniors. The students
	were very familiar with programming, but not with the web programming
	languages learned and used in the class. Each student was paired
	with another student to work with for the entire semester. Tests
	were, however, taken individually. They understood that the idea
	was not to break the class project into two pieces and integrate
	later. The idea was to work together (almost) all the time on one
	product. These requirements were stated in the course announcement
	and were re-stated at the start of the class. Most skeptically, but
	enthusiastically, embarked on making the transition from solo to
	collaborative programming. The consensus of the class was very, very
	positive about the technique. Making the transition to pair programming
	involves breaking down some personal barriers beginning with the
	understanding that talking is not cheating. Pair programming has
	the potential of changing how programming classes are taught in order
	to benefit the students' learning experience.},
  owner = {Katia},
  references = {(not available): http://www.computer.org/portal/web/csdl/doi/10.1109/FIE.1999.841619

	(not available): But, isn't that cheating? [collaborative programming]

	(not available): But, isn't that cheating? [collaborative programming]

	(not available): But, isn't that cheating? [collaborative programming]

	(not available): But, isn't that cheating? [collaborative programming]

	(not available): But, isn't that cheating? [collaborative programming]

	(not available): But, isn't that cheating? [collaborative programming]

	(not available): But, isn't that cheating? [collaborative programming]

	(not available): But, isn't that cheating? [collaborative programming]

	(not available): But, isn't that cheating? [collaborative programming]

	(not available): But, isn't that cheating? [collaborative programming]},
  timestamp = {2010.06.21}
}

@ARTICLE{E[183],
    inserir = {false},
  author = {L. Williams and R. Kessler},
  title = {Pair Programming: Experience the Difference},
  year = {2002},
  abstract = {Pair programming is emerging as an important technique for developing
	higher quality code, faster. With pair programming, two software
	developers work on one computer, collaborating on the same design,
	algorithm, code, or test. This tutorial examines pair programming
	research results and anecdotal experiences of programmers who have
	transitioned to pair programming. It will discuss what works and
	what doesn’t and will also explain techniques for fostering support
	in making a transition to pair programming – support from management
	and support from peers. Hands-on activities will be used to demonstrate
	pair programming benefits.},
  owner = {Katia},
  references = {no references: Pair Programming: Experience the Difference},
  timestamp = {2010.06.21}
}

@ARTICLE{E[184],
    inserir = {false},
  author = {L. Williams and R. Kessler},
  title = {Experimenting with industry's "Pair-Programming" model in the Computer
	Science classroom},
  year = {2001},
  abstract = {Anecdotal evidence from several sources, primarily in industry, indicates
	that two programmers working collaboratively on the same design,
	algorithm, code, or test perform substantially better than the two
	would working alone. Two courses taught at the University of Utah
	studied the use of this technique, often called pair-programming
	or collaborative programming,

	in the undergraduate computer science classroom. The students applied
	a positive form of “pair-pressure” on each other, which proved beneficial
	to the quality of their work products. The students also benefit
	from “pair-learning,” which allowed them to learn new languages faster
	and better than with solitary learning. The workload of the teaching
	staff is reduced because the students more often look to each other
	for technical support and advice.},
  owner = {Katia},
  references = {Chrysler Goes to Extremes

	Constantine on Peopleware

	Investigating Data Quality Problems in the PSP (Experience Paper)

	Analyzing Distributed Cognition in Software Teams: A Case Study of
	Team Programming During Perfective Software Maintenance

	A Discipline for Software Engineering. Reading

	Introduction to the Personal Software Process

	Reengineering Inspection: The Future of Formal Technical Review

	Software Quality: Analysis and Guidelines for Success

	Programming In Pairs

	Strengthening the Case for Pair-Programming

	All I Ever Needed to Know About Pair Programming I Learned in Kindergarten},
  timestamp = {2010.06.21}
}

@ARTICLE{E[182],
    inserir = {false},
  author = {L. Williams and R. Kessler},
  title = {All I really need to know about pair programming I learned in kindergarten},
  year = {2000},
  abstract = {Pair programming is a practice in which two programmers work side-by-side
	at one computer, continuously collaborating on the same design, algorithm,
	code or test. This method has been demonstrated to improve productivity
	and the quality of software products. When it comes to programming
	practices, studies show two heads are almost always better than one.
	Programmers are universally more confident in their solutions when
	programming in pairs as opposed to working alone. Likewise, most
	of them enjoy their jobs more when pair programming. However, most
	programmers are long conditioned to working alone and often resist
	the transition to pair programming. Ultimately, most make this transition
	with great success. The goal of this article is to help programmers
	become effective pair programmers. The transition to and on-going
	success as a pair programmer often involves practicing everyday civility.
	In this article we explore the inherent lessons related to successful
	pair programming.},
  owner = {Katia},
  references = {Chrysler Goes to "Extremes"

	Extreme Programming Roadmap

	Embrace Change: Extreme Programming Explained

	Constantine on Peopleware

	Peopleware

	All I Really Need to Know I Learned in Kindergarten

	Coordination in Software Development

	The Case for Collaborative Programming

	The Psychology of Computer Programming Silver Anniversary Edition

	Egoless Programming

	Pair Programming Questionnaire},
  timestamp = {2010.06.21}
}

@ARTICLE{I[59],
    inserir = {true},
  author = {L. Williams and R. Kessler},
  title = {The effects of "pair-pressure" and "pair-learning" on software engineering
	education},
  year = {2000},
  abstract = {Anecdotal evidence from several sources, primarily in industry, indicates
	that two programmers working collaboratively on the same design,
	algorithm, code, or test perform substantially better than the two
	would working alone. In this technique, often called "pair programming"
	or "collaborative programming", one person is the "driver" and has
	control of the pencil/mouse/keyboard and is writing the design or
	code. The other person continuously and actively observes the work
	of the driver-watching for defects, thinking of alternatives, looking
	up resources, and considering strategic implications of the work
	at hand. A course in Web programming was taught at the University
	of Utah in Summer Semester 1999. In this course, the students worked
	in pairs, continuously collaborating on all programming assignments.
	Using the technique, the students applied a positive form of "pair-pressure"
	on each other, which proved beneficial to the quality of their work
	products. The students also benefited from "pair-learning", which
	allowed them to learn new languages faster and better than they had
	experienced with solitary learning. "Pair-learning" also reduced
	the workload of the teaching because the students no longer relied
	primarily on them for technical support and advise.},
  owner = {Katia},
  references = {Organizing Genius: The Secrets of Creative Collaboration

	Extremes

	Programming In Pairs

	Constantine on Peopleware

	The Case for Collaborative Programming

	Pair Programming Questionnaire

	All I Ever Needed to Know About Pair Programming I Learned in Kindergarten

	A Discipline for Software Engineering},
  timestamp = {2010.06.21}
}

@ARTICLE{I[60],
    inserir = {true},
  author = {L. Williams and R. Kessler and W. Cunningham and R. Jeffries and
	R. Jeffries},
  title = {Strengthening the case for pair programming},
  year = {2000},
  abstract = {Pair programming has been practiced in industry with great success
	for years. Yet, most who have nut tried and tested pair programming
	reject the idea immediately as a redundant, wasteful use of programming
	resources. This article demonstrates that incorporating pair programming
	into a software development process will help yield software products
	of better quality in less time with happier, more confident programmers.},
  owner = {Katia},
  references = {Constantine on Peopleware

	The Case for Collaborative Programming

	A Development Process Generative Pattern Language

	Analyzing Distributed Cognition in Software Teams: A Case Study of
	Team Programming during Perfective Software Maintenance

	The Psychology of Computer Programming Silver Anniversary Edition

	All I Ever Needed to Know about Pair Programming I Learned in Kindergarten

	Peopleware

	The Wisdom of Teams: Creating the High-Performance Organization

	Chrysler Goes to ‘Extremes

	Extreme Programming Explained: Embrace Change

	The Mythical Man-Month},
  timestamp = {2010.06.21}
}

@ARTICLE{I[63],
    inserir = {true},
  author = {L. Williams and L. Layman and J. Osborne and N. Katira},
  title = {Examining the Compatibility of Student Pair Programmers},
  year = {2006},
  abstract = {Pair programming has been shown to be beneficial for both students
	and teaching staff in university courses. A two-phased study of 1350
	students was conducted at North Carolina State University from 2002-2005
	to determine if teaching staff can proactively form compatible pairs
	based upon any of the following factors: personality type, learning
	style, skill level, programming self esteem, work ethic, or time
	management preference. We examined compatibility among freshmen,
	advanced undergraduate and graduate student pair programmers. We
	have found that overall 93% of students are compatible with their
	partners. Students notably preferred to pair with a partner that
	he or she perceived to be of similar or higher skill level to them,
	which can be predicted by grouping students with similar grade point
	average. Additionally, pairs comprised of a sensor and an intuitor
	learning style seem to be compatible, and pairs with differing work
	ethic are generally not compatible.},
  owner = {Katia},
  references = {Novice-Expert Differences in Software Design

	Voices of Women in a Software Engineering Course: Reflections on Collaboration

	Using Pair Programming and Agile Development Methods in a University
	Software Engineering Course to Develop a Model of Social Interactions

	Guidelines for the User of Pair Programming in a Freshman Programming
	Class

	Learning and Teaching Styles in Engineering Education

	Group Dynamics and Collaborative Group Performance

	Understanding the Compatibility of Pair Programmers MS Thesis

	Towards Increasing the Compatibility of Student Pair Programmers

	On Understanding Compatibility of Student Pair Programmers

	Peer Ratings in Cooperative Learning Teams

	Please Understand Me II

	Rational Unified Process Evaluation Framework Version 1.0

	How and Why Collaborative Software Development Impacts the Software
	Engineering Course

	The MBTI and Individual Pathways in Engineering Design

	The Effect of Pair Programming on Performance in an Introductory Programming
	Course

	The Impact of Pair Programming on Student Performance of Computer
	Science Related Majors

	Perceptions of Agile Practices: A Student Survey

	Improving the CS1 Experience with Pair Programming

	Pair Learning: With an Eye Toward Future Success

	Boomers, Gen-Xers, and Millennials: Understanding the New Students

	Measuring Computer Programing Quality and Comprehension

	The Evidence Remains Stable: The MBTI Predicts Attraction and Attrition
	in an Engineering Program

	Code Warriors and Code-a-Phobes: A study in attitude and pair programming

	Expert software design strategies

	Mind in society: The development of higher psychological processes

	Pair Programming Illuminated

	Building Pair Programming Knowledge Through a Family of Experiments

	In Support of Pair Programming in the Introductory Computer Science
	Course},
  timestamp = {2010.06.22}
}

@ARTICLE{I[70],
    inserir = {true},
  author = {L. Williams and L. Layman and K. M. Slaten and S. B. Berenson and
	C. Seaman},
  title = {On the Impact of a Collaborative Pedagogy on African American Millennial
	Students in Software Engineering},
  year = {2007},
  abstract = {Millennial students (those born after 1982), particularly African
	Americans and women, have demonstrated a propensity toward collaborative
	activities. We conducted a collective case study at North Carolina
	State University and North Carolina A&T to ascertain the role of
	collaboration and social interaction in attracting and retaining
	students in information technology. Responses from semi-structured
	interviews with 11 representative African American students in these
	classes were coded and analyzed. The responses from these minority
	students were used to evolve a social interaction model. The conjectures
	generated from the model suggest that pair programming and agile
	software methodologies effectively create a collaborative environment
	that is desirable to Millennial students, male and female, and, with
	the new evidence, minority and majority. Additionally, the African
	American Millennial students enjoy learning from their peers and
	believe that a collaborative environment better prepares them for
	the "real world."},
  owner = {Katia},
  references = {Iterative Enhancement: A Practical Technique for Software Development

	Extreme Programming Explained: Embrace Change

	The Agile Manifesto

	Voices of Women in a Software Engineering Course: Reflections on Collaboration

	Using Pair Programming and Agile Development Methods in a University
	Software Engineering Course to Develop a Model of Social Interactions

	Guidelines for the User of Pair Programming in a Freshman Programming
	Class

	A Spiral Model for Software Development and Enhancement

	Self-Explaining: The Dual Process of Generating Inference and Repairing
	Mental Models

	Java Modeling in Color with UML

	Agile Software Development. Reading

	Crystal "Clear": A human-powered software development methodology
	for small teams

	Toward improving female retention in the computer science major

	Qualitative inquiry and research design: Choosing among five traditions

	Three Problems Overcome with Behavioral Models of the Software Development
	Process (Panel)

	The Supply of Information Technology Workers in the United State

	Mathematics achievement among African American undergraduates of the
	University of California, Berkeley: An evaluation of the Mathematics
	Workshop Program

	Adaptive Software Development

	Group Dynamics and Collaborative Group Performance

	Please Understand Me II

	Agile and Iterative Development: A Manager's Guide

	A History of Iterative and Incremental Development

	Situated Learning: Legitimate peripheral participation

	How and Why Collaborative Software Development Impacts the Software
	Engineering Course

	Changing Students’ Perceptions: An Analysis of the Supplementary Benefits
	of Collaborative Software Development

	Personality Types, Learning Styles, and an Agile Approach to Software
	Engineering Education

	Geek Mythology and Attracting Undergraduate Women to Computer Science

	Women in Computing

	The impact of pair programming on student performance, perception,
	and persistence

	Improving the CS1 Experience with Pair Programming

	Pair Learning: With an Eye Toward Future Success

	Student Diversity Requires Different Approaches to College Teaching,
	Even in Math and Science

	Boomers, Gen-Xers, and Millennials: Understanding the New Students

	Educating the Net Generation

	A Practical Guide to Feature-Driven Development

	Agile Project Management with SCRUM

	Agile Software Development with SCRUM

	Qualitative Methods in Empirical Studies of Software Engineering

	Understanding Student Perceptions of Pair Programming and Agile Software
	Development Methodologies: Verifying a Model of Social Interaction

	The Art of Case Study Research. Thousand Oaks

	The Method in Practice

	Basics of Qualitative Research: Techniques and Procedures of Developing
	Grounded Theory

	Studying students studying calculus: A look at the lives of minority
	mathematics students in college

	IT courses and the IT industry: Does the future rely on gender or
	generation?

	Discourse and learning in the classroom: A sociocultural approach

	Pair Programming Illuminated

	In Support of Pair Programming in the Introductory Computer Science
	Course

	The Collaborative Software Process},
  timestamp = {2010.06.22}
}

@ARTICLE{I[62],
    inserir = {true},
  author = {L. Williams and C. McDowell and N. Nagappan and J. Fernald and L.
	Werner},
  title = {Building pair programming knowledge through a family of experiments},
  year = {2003},
  abstract = {Pair programming is a practice in which two programmers work collaboratively
	at one computer on the same design, algorithm, code, or test. Pair
	programming is becoming increasingly popular in industry and in university
	curricula. A family of experiments was run with over 1200 students
	at two US universities, North Carolina State University and the University
	of California Santa Cruz, to assess the efficacy of pair programming
	as an alternative learning technique in introductory programming
	courses. Students who used the pair programming technique were at
	least as likely to complete the introductory course with a grade
	of C or better when compared with students who used the solo programming
	technique. Paired students earned exam and project scores equal to
	or better than solo students. Paired students had a positive attitude
	toward collaboration and were significantly more likely to be registered
	as computer science-related majors one year later. Our findings also
	suggest that students in paired classes continue to be successful
	in subsequent programming classes continue to be successful in subsequent
	programming classes that require solo programming.},
  owner = {Katia},
  references = {Finlay, Statistical Methods for the Social Sciences: Dellen Publishing
	Company

	Building Knowledge through Families of Experiments

	Building Knowledge Through Families of Experiments

	Guidelines for the User of Pair Programming in a Freshman Programming
	Class

	The Costs and Benefits of Pair Programming

	The Effect of Pair Programming on Performance in an Introductory Programming
	Course

	The Impact of Pair Programming on Student Performance of Computer
	Science Related Majors

	Improving the CS1 Experience with Pair Programming

	Experimental Evaluation of Pair Programming

	The Case for Collaborative Programming

	Student perceptions of the suitability of Extreme and Pair Programming

	Code Warriors and Code-a-Phobes: A study in attitude and pair programming

	A Comparison of Pair Programming to Inspections for Software Defect
	Reduction

	Computer Science Attitude Survey

	Pair Programming Illuminated

	Strengthening the Case for Pair-Programming

	In Support of Pair Programming in the Introductory Computer Science
	Course

	Pair Programming in an Introductory Computer Science Course: Initial
	Results and Recommendations

	The Collaborative Software Process PhD Dissertation},
  timestamp = {2010.06.22}
}

@ARTICLE{E[187],
    inserir = {false},
  author = {L. Williams and A. Shukla and A. I. Anton},
  title = {An initial Exploration of the relationship between Pair Programming
	and Brooks' Law},
  year = {2004},
  abstract = {Through his law, "adding manpower to a late software project makes
	it later,'' Brooks asserts that the assimilation, training, and intercommunication
	costs of adding new team members outweigh the associated team productivity
	gain in the short term. Anecdotes suggest that adding manpower to
	a late project yields productivity gains to the team more quickly
	if the team employs the pair programming technique when compared
	to teams where new team members work alone. We utilize a system dynamics
	model which demonstrates support of these observations. Parameter
	values for the model were obtained via a small-scale, nonprobabilistic,
	convenience survey. Our initial findings suggest that managers should
	incorporate the pair programming practice when growing their team.},
  owner = {Katia},
  references = {(not available): http://www.computer.org/portal/web/csdl/doi/10.1109/ADEVC.2004.6

	(not available): An initial Exploration of the relationship between
	Pair Programming and Brooks' Law

	(not available): An initial Exploration of the relationship between
	Pair Programming and Brooks' Law

	(not available): An initial Exploration of the relationship between
	Pair Programming and Brooks' Law

	(not available): An initial Exploration of the relationship between
	Pair Programming and Brooks' Law

	(not available): An initial Exploration of the relationship between
	Pair Programming and Brooks' Law

	(not available): An initial Exploration of the relationship between
	Pair Programming and Brooks' Law

	(not available): An initial Exploration of the relationship between
	Pair Programming and Brooks' Law

	(not available): An initial Exploration of the relationship between
	Pair Programming and Brooks' Law

	(not available): An initial Exploration of the relationship between
	Pair Programming and Brooks' Law

	(not available): An initial Exploration of the relationship between
	Pair Programming and Brooks' Law},
  timestamp = {2010.06.22}
}

@ARTICLE{E[185],
    inserir = {false},
  author = {L. Williams and R. Upchurch},
  title = {Extreme programming for software engineering education?},
  year = {2001},
  abstract = {The eXtreme Programming (XP) software development methodology, has
	received considerable attention in recent years. The adherents of
	XP anecdotally extol its benefits, particularly as a method that
	is highly responsive to changing customer's desires. While XP has
	acquired numerous vocal advocates, the interactions and dependencies
	between XP practices have not been adequately studied. Good software
	engineering practice requires expertise in a complex set of activities
	that involve the intellectual skills of planning, designing, evaluating,
	and revising. The authors explore the practices of XP in the context
	of software engineering education. To do so, one must examine the
	practices of XP as they influence the acquisition of software engineering
	skills. The practices of XP, in combination or isolation, may provide
	critical features to aid or hinder the development of increasingly
	capable practitioners. This paper evaluates the practices of XP in
	the context of acquiring these necessary software engineering skills.},
  owner = {Katia},
  references = {Extreme Programming Explained: Embrace Change

	Planning Extreme Programming. Reading

	Extreme Programming Installed, Reading, Massachusetts

	Refactoring: Improving the Design of Existing Code

	Object-Oriented Software Engineering: A Use Case Driven Approach

	Evaluating Software Engineering Technologies

	What if programmers were treated like jocks?

	Essential Elements of Software Engineering Education

	Development of a causal model of processes determining job performance

	ASKING THE RIGHT QUESTION: What Does Research Tell Us About Technology
	and Higher Learning?

	Pattern-Oriented Software Architecture: A System of Patterns

	Educating the New Engineer

	The State of Education

	The Role of Deliberate Practice in the Acquisition of Expert Performance

	The Road to Excellence

	The Acquisition of Expert Performance: An Introduction to Some of
	the Issues

	Introduction to the Personal Software Process

	Designing Process-Based Software Curriculum

	A Discipline of Software Engineering. Reading

	Teaching object-oriented design to nonprogrammers: A progress report

	Teaching Object-Oriented Design Without Programming: A Progress Report

	Cognitive apprenticeship: Making thinking visible

	In Support of Student Process Improvement

	Skill acquisition and the Lisp Tutor

	Effects of examples and their explanation in a lesson on recursion:
	A production system analysis

	An empirical investigation into problem decomposition strategies used
	in program design

	Metacognition and problem solving: A process-oriented approach

	Learning Strategies and Transfer in the Domain of Programming

	Eliciting selfexplanations improves understanding

	The Role of Metacognition in Problem Solving

	Learning to Put Lessons Into Practice

	UML Distilled

	The CRC Card Book. Reading

	Introduction to the Team Software Process

	Experimenting with Industry's "Pair-Programming" Model in the Computer
	Science Classroom

	In Support of Student Pair-Programming

	Structural Assessment to Support Engineering Education},
  timestamp = {2010.06.21}
}

@ARTICLE{E[186],
    inserir = {false},
  author = {L. Williams and R. L. Upchurch},
  title = {In support of student pair-programming},
  year = {2001},
  abstract = {Industry, particularly those following the eXtreme Programming (XP)
	methodology [2], has popularized the use of pair-programming. The
	pair-programming model has also been found to be beneficial for student
	programmers. Initial quantitative and qualitative results, which
	will be discussed in this paper, demonstrate that the use of pair-programming
	in the computer science classroom enhances student learning and satisfaction
	and reduces the frustration common among students. Additionally,
	the use of pair-programming relieves the burden on the educators
	because students no longer view the teaching staff as their sole
	form of technical information. We explore the nature of pair-programming,
	then examine the ways such a practice may enhance teaching and learning
	in computer science education.},
  owner = {Katia},
  references = {Distributed Cognitions: Psychological and Educational Considerations

	Extreme Programming Explained:Embrace Change

	The Case for Collaborative Programming

	The Effects of "Pair-Pressure" and "Pair-Learning" on Software Engineering
	Education

	Strengthening the Case for Pair-Programming

	Experimenting with Industry's "Pair-Programming" Model in the Computer
	Science Classroom

	The Costs and Benefits of Pair Programming

	The Collaborative Software Process PhD Dissertation

	A Discipline for Software Engineering

	An Economic Analysis of Collaborative Programming

	Self-efficacy: The Exercise of Control

	Social Cognitive Theory of Organizational Mangement Special Issue:
	Theory development Forum

	On the Nature of Planning in Writing

	Advances in software inspections to reduce errors in program development

	Reengineering Inspection: The Future of Formal Technical Review

	Introduction to the Personal Software Process

	Learning Strategies and Transfer in the Domain of Programming

	Metacognition and Problem Solving: A Process-Oriented Approach

	Eliciting Self-Explanations Improves Understanding

	In Support of Student Process Improvement

	Integrating Software Process in Computer Science Curriculum

	Analyzing Distributed Cognition in Software Teams: A Case Study of
	Team Programming During Perfective Software Maintenance

	Problem Solving and Comprehension

	Skill Acqisition and the Lisp Tutor

	Effects of Examples and Their Explanation in a Lesson on Recursion:
	A Production System Analysis

	The Acquisition of Expertise in Software Engineering Education},
  timestamp = {2010.06.21}
}

@ARTICLE{I[61],
    inserir = {true},
  author = {L. Williams and E. Wiebe and K. Yang and M. Ferzli and C. Miller},
  title = {In Support of Pair Programming in the Introductory Computer Science
	Course},
  year = {2002},
  abstract = {A formal pair programming experiment was run at North Carolina to
	empirically assess the educational efficacy of the technique in a
	CS1 course. Results indicate that students who practice pair programming
	perform better on programming projects and are more likely to succeed
	by completing the class with a C or better. Student pairs are more
	self-sufficient which reduces their reliance on the teaching staff.
	Qualitatively, paired students demonstrate higher order thinking
	skills than students who work alone. These results are supportive
	of pair programming as a collaborative learning technique.},
  owner = {Katia},
  references = {Problem solving and program design: A pedagogical approach

	Constructing science in middle and secondary school classrooms

	Extreme programming explained: Embrace change

	Guidelines for the use of pair programming in a freshman programming
	class

	The costs and beneficts of pair programming

	Equity issues in computer-based collaboration: Looking beyond surface
	indicators

	Peopleware

	Fennema Sherman mathematics attitudes scales

	The psycho-social processes and cognitive effects of peer-based collaborative
	interactions with computers

	Majoring in computer science: Causal models for women and men

	Computer programming instruction: Effects of collaboration and structured
	design mileposts

	The effects of pair programming on performance in an introductory
	programming course

	The influence of instruction and activity on the development of semantic
	programming knowledge

	The effects of cooperative learning in a second-semester

	A statistical assessment of an experiment to compare traditional vs.
	laboratory approach in teaching introductory computer programming

	Construction sites: Science labs and classrooms

	Using student team learning. Baltimore: The Center for Social Organization
	of Schools

	Cooperative learning: Theory, research, and practice

	Studying different methods of technology integration for teaching
	problem solving with systems of equations and inequalities and linear
	programming

	Equity issues in collaborative group assessment: Group composition
	and performance

	The collaborative software process PhD dissertation

	The effects of ``pair-pressure'' and ``pair-learning'' on software
	engineering education

	Experimenting with industry's ``pair programming'' model in the computer
	science classroom

	Strengthening the case for pair programming

	Changing attitudes to university mathematics through problem solving},
  timestamp = {2010.06.21}
}

@ARTICLE{E[188],
    inserir = {false},
  author = {L. Williams and K. Yang and E. Wiebe and M. Ferzli and C. Miller},
  title = {Pair Programming in an Introductory Computer Science Course: Initial
	Results and Recommendations},
  year = {2002},
  abstract = {Prior research indicates that pair programming, whereby two programmers
	work collaboratively on the same design, algorithm, code, or test,
	produces higher quality code in essentially half the time taken by
	solo programmers. An experiment was run at North Carolina to assess
	the efficacy of pair programming in the introductory CS1 course.
	Results indicate that relative to students who program individually,
	pair programmers are more self-sufficient, perform better on projects,
	and are more likely to complete the class with a C or better.},
  owner = {Katia},
  references = {Extreme Programming Explained: Embrace Change

	Guidelines for the Use of Pair Programming in a Freshman Programming
	Class

	The Costs and Benefits of Pair Programming

	Equity issues in computer-based collaboration: Looking beyond surface
	indicators

	Peopleware

	The Effects of Pair Programming on Performance in an Introductory
	Programming Course

	Using Student Team Learning

	Cooperative Learning: Theory, Research, and Practice

	Equity issues in collaborative group assessment: Group composition
	and performance

	Pair Programming

	Strengthening the Case for Pair-Programming

	The Collaborative Software Process PhD Dissertation

	The Effects of "Pair-Pressure" and "Pair-Learning" on Software Engineering
	Education

	Experimenting with Industry’s “Pair Programming” Model in the Computer
	Science Classroom

	Pair Programming Illuminated

	All I Ever Needed to Know about Pair Programming I Learned in Kindergarten},
  timestamp = {2010.06.21}
}

@ARTICLE{I[64],
    inserir = {true},
  author = {D. Winkler and S. Biffl},
  title = {An empirical study on design quality improvement from best-practice
	inspection and pair programming},
  year = {2006},
  abstract = {The quality of the software design often has a major impact on the
	quality of the final product and the effort for development and evolution.
	A number of quality assurance (QA) approaches for inspection of early-life-cycle
	documents have been empirically evaluated. An implicit assumption
	of these studies was: an investment into early defect detection and
	removal saves higher rework cost. The concept of pair programming
	combines software construction with implicit QA in the development
	team. For planning QA activities, an important research question
	is how effective inspectors can be expected to be at detecting defects
	in software (design and code) documents compared to programmers who
	find defects as by-product of their usual construction activities.
	In this paper we present an initial empirical study that compares
	the defect detection effectiveness of a best-practice inspection
	technique with defect detection as by-product of constructive software
	evolution tasks during pair programming. Surprisingly, in the study
	context pair programmers were more effective to find defects in design
	documents than inspectors. However, when building a larger team for
	defect detection, a mix of inspection and pair programming can be
	expected to work better than any single technique.},
  owner = {Katia},
  references = {Studies on Reading Techniques

	Value-Based Software Engineering

	Software Inspection Techniques to support Project and Quality Management

	Investigating the Defect Detection Effectiveness and Cost Benefit
	of Nominal Inspection Teams

	Influence of Team Size and Defect Detection Methods on Inspection
	Effectiveness

	Investigating the Effect of V&V and Modern Construction Techniques
	on Improving Software Quality

	The Costs and Benefits of Pair Programming in Extreme Programming
	Examined

	Agile Software Development

	Design and Code Inspections To Reduce Errors In Program Development

	Software Inspection

	Are Reviews an Alternative to Pair Programming?

	Experimental Evaluation of Pair Programming

	Analyzing the Cost and Benefit of Pair Programming

	A field study of developer pairs: Productivity impacts and implications

	A Replicated Experiment of Usage-Based and Checklist-Based Reading

	Usage-Based Reading - An Experiment to Guide Reviewers with Use Cases

	An Experimental Comparison of Usage-Based and Checklist-Based Reading

	The cost of errors in software development: evidence from industry

	Strengthening the Case for Pair Programming

	All I really need to know about pair programming I learned in Kindergarten

	Building Pair Programming Knowledge through a Family of Experiments

	Investigating the Impact of Active Guidance on Design Inspection

	Improvement of Design Specifications with Inspection and Testing},
  timestamp = {2010.06.22}
}

@ARTICLE{E[189],
    inserir = {false},
  author = {A. Wojciechowski and J. Nawrocki and G. Jachimko and L. Gawron and
	M. Jagielski and B. Walter},
  title = {Experimental evaluation of two approaches to software artefacts review},
  year = {2002},
  abstract = {The classical approach to software artefacts review is based on two
	phases: first a developer produces an artefact (design, code etc.),
	and then a reviewer (or reviewers) check quality. That paradigm has
	been changed recently by a software development methodology called
	Extreme Programming (XP). One of key practices of XP is pair programming:
	while one programmer writes code the other is performing on-line
	review, i.e. programming and reviewing are performed in the same
	phase (simultaneously). In the paper an experiment is described that
	aimed at comparing those two approaches to software review.},
  owner = {Katia},
  references = {(not available): http://www.cs.put.poznan.pl/fcds/2002.htm

	(not available): Experimental evaluation of two approaches to software
	artefacts review

	(not available): Experimental evaluation of two approaches to software
	artefacts review

	(not available): Experimental evaluation of two approaches to software
	artefacts review

	(not available): Experimental evaluation of two approaches to software
	artefacts review

	(not available): Experimental evaluation of two approaches to software
	artefacts review

	(not available): Experimental evaluation of two approaches to software
	artefacts review

	(not available): Experimental evaluation of two approaches to software
	artefacts review

	(not available): Experimental evaluation of two approaches to software
	artefacts review

	(not available): Experimental evaluation of two approaches to software
	artefacts review

	(not available): Experimental evaluation of two approaches to software
	artefacts review},
  timestamp = {2010.06.21}
}

@ARTICLE{E[190],
    inserir = {false},
  author = {W. A. Wood and W. L. Kleb},
  title = {Exploring XP for scientific research},
  year = {2003},
  abstract = {Can we successfully apply XP (Extreme Programming) in a scientific
	research context? A pilot project at the NASA Langley Research Center
	tested XPs applicability in this context. Since the cultural environment
	at a government research center differs from the customer-centric
	business view, eight of XPs 12 practices seemed incompatible with
	the existing research culture. Despite initial awkwardness, the authors
	determined that XP can function in situations for which it appears
	to be ill suited.},
  owner = {Katia},
  references = {Programming Ruby: the pragmatic programmer's guide

	Ruby in a nutshell: a desktop quick reference

	Extreme programming explained: embrace change

	Refactoring: improving the design of existing code

	The Goal: A Process of Ongoing Improvement

	Efficient Multi-Stage Time Marching for Viscous Flows via Local Preconditioning

	Runge-Kutta Circular Advection Problem Solver},
  timestamp = {2010.06.22}
}

@ARTICLE{E[191],
    inserir = {false},
  author = {S. Xu},
  title = {Cognitive aspects of software engineering processes},
  year = {2006},
  abstract = {Software engineering activities are to process a large amount of knowledge
	and therefore, the cognitive process is mainly involved. Studying
	the cognitive process involved in software engineering can greatly
	help us to understand the whole process and to improve software engineering
	research. In order to study the cognitive process, we developed an
	empirical method that includes dialog-based protocol and self-directed
	learning theory. The dialog-based protocol is based on the analysis
	of the dialog that occurs between programmers in pair programming.
	It is an alternative to the common think-aloud protocol and it may
	minimize the Hawthorne and placebo effects. The self-directed learning
	theory is based on the constructivist learning theory and the Bloom
	taxonomy. It captures the specifics of the programmer's cognitive
	activities and provides an encoding scheme used in analyzing the
	empirical data. We conducted a case study of expert and intermediate
	programmers during incremental software development. Compared to
	intermediate programmers, experts discussed more domain concepts
	at a greater length before starting to write code. Experts mostly
	concentrated on one concept at one time, while intermediate programmers
	often discussed several concepts simultaneously. Experts were willing
	to reconsider and correct obsolete design decisions, while intermediate
	programmers retained all design decisions. Experts had more absorption
	activities at higher Bloom levels such as analysis and synthesis,
	while intermediate programmers had more absorption activities at
	lower Bloom levels such as comprehension and application. Experts
	spent more time analyzing the knowledge and generating test cases,
	while intermediate programmers spent more time learning the knowledge.
	We also conducted a case study on program debugging, and found that
	programmers apply the cognitive activities at all six Bloom levels
	and move from lower one to upper one in order to make update. Program
	debugging is a more complex activity than incremental software development.
	A case study on pair programming in software evolution class projects
	was also performed. The results of the case study showed that paired
	students completed their change request tasks faster and with higher
	quality than individuals. They also wrote less lines of code and
	used more meaningful variable names.},
  owner = {Katia},
  references = {Doctoral Thesis - Wayne State University (no available)

	Doctoral Thesis - Wayne State University (no available)

	Doctoral Thesis - Wayne State University (no available)

	Doctoral Thesis - Wayne State University (no available)

	Doctoral Thesis - Wayne State University (no available)

	Doctoral Thesis - Wayne State University (no available)

	Doctoral Thesis - Wayne State University (no available)

	Doctoral Thesis - Wayne State University (no available)},
  timestamp = {2010.06.22}
}

@ARTICLE{E[114],
    inserir = {false},
  author = {A. M. Zin and S. Idris},
  title = {Implementing Virtual Pair Programming in E-Learning Environment},
  year = {2006},
  abstract = {Programming subjects are one of the core and important subjects that
	should be taken by students majoring in Information System or computing.
	The problem of teaching and learning of programming has been widely
	reported in literatures. Many attempts have been made to solve this
	problems and this had led to many new approaches in teaching and
	learning of programming. One of the approach that has been proposed
	is the use of pair-programming, which is one of the practice of eXtreme
	Programming (XP). The advent of e-learning has given birth of Virtual
	Pair Programming (VPP). This paper describes how asynchronous mode
	of collaboration using VPP could be implemented for e-learning learners
	to learn programming.},
  owner = {Katia},
  references = {E-Commerce and the Undergraduate MIS Curricula: an Exploratory Study

	Implementing Virtual Pair Programming in E-Learning Environment

	A Knowledge Assimilation Schema for Acquiring Technical Knowledge

	Mitigating Negative Behaviors in Student Project Teams: An Information
	Technology Solution

	Memory Grid: A Glass Box View of Data Representation

	How the Teacher's Role Changes in On-line Case Study Discussions

	A Comparison of Faculty and Undergraduate Students' Perceptions of
	Online Courses and Degree Programs

	Market Power of ERP Education - An Investigative Analysis

	Constructing Integrated Writing Assignments for the IS Curriculum

	Teaching Object-Oriented Programming Concepts Using Visual Basic .NET

	The Competitiveness of the Information Systems Major: An Analytic
	Hierarchy Process},
  timestamp = {2010.06.22}
}
