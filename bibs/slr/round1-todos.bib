@comment{% This file was created with JabRef 2.3.1.
% Encoding: Cp1252}

@comment{jabref-meta: selector_publisher:}

@comment{jabref-meta: selector_author:}

@comment{jabref-meta: selector_journal:}

@comment{jabref-meta: selector_keywords:}

@article{E[10],
 abstract = {Component Based Software Development (CBSD) is focused on assembling
existing components to build a software system, with a potential
benefit of delivering quality systems by using quality components.
It departs from the conventional software development process in
that it is integration centric as opposed to development centric.
The quality of a component based system using high quality components
does not therefore necessarily guarantee a system of high quality,
but depends on the quality of its components, and a framework and
integration process used. Hence, techniques and methods for quality
assurance and assessment of a component based system would be different
from those of the traditional software engineering methodology. It
is essential to quantify factors that contribute to the overall quality,
for instances, the trade off between cost and quality of a component,
analytical techniques and formal methods, and quality attribute definitions
and measurements. This paper presents a literature survey of component
based system quality assurance and assessment; the areas surveyed
include formalism, cost estimation, and assessment and measurement
techniques for the following quality attributes: performance, reliability,
maintainability and testability. The aim of this survey is to help
provide a better understanding of CBSD in these aspects in order
to facilitate the realisation of its potential benefits of delivering
quality systems.},
 author = {S. Mahmood, R. Lai, Y. S. Kim, J. H. Kim, S. C. Park, H. S. Oh},
 inserir = {false},
 references = {A calculus for modelling software components

A classification of concurrency failures in Java components

A design level formal model for Javabeans

A formal approach to reusing more general components

A formal framework for analysing reusability complexity in component
based systems

A formal model for component-based software

Abstract behaviour types: a foundation model for components and their
composition

Analysis of a conflict between aggregation and interface negotiation
in Microsoft's Component Object Model

Assessing component based systems

Assessment of high integrity software components for completeness

Behavioural specification of distributed software component interfaces

Cadena: an integrated development, analysis, and verification environment
for component-based systems

Challenges and problems in testing software components

Component based measurement: few useful guidelines

Component-Based Software Engineering: Putting the Pieces Together

Composition for component based modelling

Design with asynchronously communicating components

Few important considerations for deriving interface complexity metric
for component-based systems

Formal specification of COTS-based software: a case study

Formal support for development of javabeans component systems

Formalization of component object model (COM)—the COMEL language

Formalizing and automating component reuse

iContract the Java Design by Contract Tool

Issues of CBD product quality and process quality

JML: a notation for detailed design

Lessons learned through six years of component-based development

Metrics and models for cost and quality of component-based software

Metrics in software quality assurance

Metrics-based framework for decision making in COTS-based software
systems

Metrics-guided quality management for component-based software systems

Quality characteristics for software components

Reasoning about software architectures with contractually specified
components

Refinement and verification of synchronized component based systems

Reuse of formal verification efforts of incomplete models

Reusing analogous components

Software engineering metrics for COTS-based systems

Software measurement guidebook

Software metrics model for quality control

Techniques for embedding executable specifications in software component
interfaces

Testing and quality assurance for component based software

The B Book

The role of formal methods in component-based software engineering

Third-party testing and the quality of software components

Towards a quality model for the selection of ERP systems

Z: An Introduction to Formal Methods},
 timestamp = {2010.02.09},
 title = {A survey of component based system quality assurance and assessment},
 year = {2005}
}

@article{E[11],
 abstract = {SCM (Software Configuration Management) is arguably one of the most
successful software engineering disciplines. It is difficult to imagine
this kind of success would have prevailed without research fueling
continuous innovations. This paper demonstrates that the impact of
this research, whether industrial or academic in nature, is undeniable
- most fundamental techniques underlying current SCM systems were
first published in one form or another. Like any other field, SCM
research has had its successes and failures. Certain ideas are universally
adopted, others have had limited impact, and yet others never saw
fruition. Timing has been critical: whereas some contributions could
immediately be related to practical, day-to-day problems, others
were too early for their time and not practically relevant for the
problems then at hand.},
 author = {J. Estublier, D. Leblang, A. Hoek, R. Conradi, G. Clemm, W. Tichy,
D. Wiborg-Weber},
 inserir = {false},
 references = {3DFS: A time-oriented file server

A conceptual basis for feature engineering

A configuration manager: The Adele data base of programs

A filesystem for software development

A generic, peer-to-peer repository for distributed configuration management

A layered approach to software design

A Layered Architecture for Uniform Version Management

A new dimension for the UNIX file system

A structural view of the Cedar programming environment

A user-level replicated file system

An editor for revision control

An efficient algorithm for differential file comparison

An Empirical Study of Delta Algorithms

An holistic model for change control

An OND difference algorithm and its variations

An overview of PCTE and PCTE+

An Overview of the CAPITL Software Development Environment

Automated software management based on structural models

Capability Maturity Model

Change management for software development

Change Oriented Versioning

Change Sets Versus Change Packages: Comparing Implementations of Change-Based
SCM

Change-oriented version descriptions in EPOS

ClearCase MultiSite: Supporting Geographically-Distributed Software
Development

Comments on OSS/FS software configuration management systems

Commercial realtime software needs different configuation management

Computer-Aided Software Engineering in a distributed workstation environment

Configuration Management (Trends in Software)

Configuration Management in Terms of Modules

Configuration Management Models in Commercial Environments

Configuration management with logical structures

Constructing a Large Product with Jam

Creation and maintenance of multiple versions

Defining and supporting concurrent engineering policies in SCM

Delta storage for arbitrary non-text files

Design, implementation, and evaluation of a Revision Control System

Endeavors: a process system integration infrastructure

Engineering of Real Time Systems

Experience with a data base of programs

From object composition to model transformation with the MDA

Fundamental software process concepts

Gandalf: software development environments

Goals for a Configuration Management Network Protocol

Good electronic records management (GERM) using IBM rational ClearCase
and IBM rational ClearQuest

High Level Process Modeling for SCM Systems

Implementing and Integrating Product Data Management and Software
Configuration Management

Integrating noninterfering versions of programs

ISPW6: support for the software process

Knowledge controlled version selection in software configuration management

Literate programming

Make---A program for maintaining computer programs

Managing multi-version programs with an editor

Managing the Software Development Process with ClearGuide

Methods and tools for software configuration management

Mining Version Histories to Guide Software Changes

Model-driven architecture and integration: Opportunities and challenges

Modelling software systems in configuration management

Modelling Systems with Variability using the PROTEUS Configuration
Language

Module interconnection languages

Ordering Broken Unit Tests for Focused Debugging

PCTE Interfaces: Supporting Tools in Software-Engineering Environments

Preliminary experience with a configuration control system for modular
programs

Process Technology

Programming-in-the-large vs. Programming-in-the-small

Rational clearcase UCM migration: A case study

Rational ClearCase UCM Migration: A case study

RCS—a system for version control, Software—Practice & Experience

Requirements for a modern CM system

Satterthwaite, Early experience with Mesa

SCM: Status and Future Challenges

Semantic data modeling of hypermedia associations

Separate compilation in CHIPSY

SHAPE---A software configuration management tool

Six Theses on Software Process Research

Smart recompilation

Smart recompilation: what is it?, its benefits for the user, and its
implementation in the DEC Ada compilation system

Smarter recompilation

Software architecture, configuration management, and configurable
distributed systems: A ménage a trois

Software architecture: perspectives on an emerging discipline

Software architectures and software configuration management

Software configuration management

Software configuration management in an object oriented database

Software configuration management: a roadmap

Software management constraints and action triggering in the Adele
program database

Software process modeling in adele: The ISPW-7 example

Software Process Modelling and Technology

Software processes are software too

Some thoughts on source update as a software maintenance tool

Spectrum of functionality in configuration management systems

Structure-oriented merging of revisions of software documents

Support for integrating program variants in an environment for programming
in the large

Syntactic Software Merging

System Modeling Resurrected

Task-based configuration management

The Adele configuration manager

The Asgard System: Activity-Based Configuration Management

The CM challenge: configuration management that works

The cost of selective recompilation and environment processing

The data model of the configuration management assistant (CMA)

The database system for the unibase software engineering environment

The design and implementation of the inversion file system

The ObjectStore database system

The Odin specification language

The Odin System

The source code control system

The Unified Modeling Language user guide

The VESTA approach to software configuration management

Toward a unified framework for version modeling in engineering databases

Toward SCM / PDM Integration?

Unified versioning through feature logic

Untangling Configuration Management

Vdelta: Efficient data differencing and compression

Version control in the Inscape environment

Version models for software configuration management

Version Sensitive Editing: Change History as a Programming Tool

Versioning extensions to WebDAV (Web Distributed Authoring and Versioning)

What Knowledge Is Important to a Software Professional?},
 timestamp = {2010.02.09},
 title = {Impact of software engineering research on the practice of software
configuration management},
 year = {2005}
}

@article{E[12],
 abstract = {Software engineering research and programming language design have
enjoyed a symbiotic relationship, with traceable impacts since the
1970s, when these areas were first distinguished from one another.
This report documents this relationship by focusing on several major
features of current programming languages: data and procedural abstraction,
types, concurrency, exceptions, and visual programming mechanisms.
The influences are determined by tracing references in publications
in both fields, obtaining oral histories from language designers
delineating influences on them, and tracking cotemporal research
trends and ideas as demonstrated by workshop topics, special issue
publications, and invited talks in the two fields. In some cases
there is conclusive data supporting influence. In other cases, there
are circumstantial arguments (i.e., cotemporal ideas) that indicate
influence. Using this approach, this study provides evidence of the
impact of software engineering research on modern programming language
design and documents the close relationship between these two fields.},
 author = {B. G. Ryder, M. L. Soffa, M. Burnett},
 inserir = {false},
 references = {A case for the GOTO

A design methodology for reliable software systems

A history of C++: 1979–1991

A history of CLU

A proposal for dealing with abnormal termination of programs

A study on exception detection and handling using aspect-oriented
programming

A systematic approach for implementing fault tolerant software designs
in Ada

A tour through cedar

A Tutorial on Algol 68

A type system for Smalltalk

A Visual Language Compiler

Abstraction and specification in program development

Abstraction and verification in Alphard: defining and specifying iteration
and generators

Abstraction mechanisms in CLU

Abstraction techniques in modern programming languages

Ada exception handling: an axiomatic approach

ALPHARD: Form and Content

An axiomatic basis for computer programming

An expansive view of reusable software

An experimental evaluation of data type conventions

An Iconic Programming System, HI-VISUAL

An introduction to the construction and verification of alphard programs

Aspect-oriented programming

Automating Visual Language Generation, IEEE Transactions on Software
Engineering

BLISS: a language for systems programming

Building visual language parsers

Building well-behaved type relationships in C++

Capital-intensive software technology

Communicating sequential processes

Comparison of programming languages for software engineering

Concurrent control with “readers” and “writers”

Cooperating sequential processes

Creating user interfaces using programming by example, visual programming,
and constraints

Critical comments on the programming language Pascal

Data abstraction from a programming language viewpoint

Designing robust Java programs with exceptions

Developing Educational Software Components

Enabling reuse with Ada generics

End-user software engineering with assertions in the spreadsheet paradigm

Exception handling for C++, The evolution of C++: language design
in the marketplace of ideas

Exception handling in CLU

Exception handling in PL/I

Exception handling: issues and a proposed notation

Experimentation in software engineering

From visual language specification to legal visual interaction

Gandalf: software development environments

Global variable considered harmful

goto considered harmful considered harmful

Graphical program development with PECAN program development systems

Hints on programming language design

History of programming languages

Influence of Visual Technology on the Evolution of Language Environments

Language design for programming reliability

Letters to the editor: go to statement considered harmful

LISP 1.5 Programmer's Manual

Mass-produced software components

Modula: A language for modular multiprogramming

Modula-3

Monitors and Concurrent Pascal: a personal history, History of programming
languages

Monitors: an operating system structuring concept

Notes on the design of Euclid

On the criteria to be used in decomposing systems into modules

On understanding types, data abstraction, and polymorphism

On-line graphical specification of computer procedures

Outlier finding: focusing user attention on possible errors

PICT: an interactive graphical programming environment

Possible directions for C++

Program development by stepwise refinement

Programming Language Concepts

Programming language pragmatics

Programming languages

Programming with abstract data types

Programming with the standard template library, sage advice for coping
with the stl

Prograph: A step towards liberating programming from textual conditioning

Pygmalion: A Computer Program to Model and Stimulate Creative Thought

Rationale for the design of the Ada programming language

Reference manual for the Ada programming language

Retrieval time for semantic memory

Revised Report on the Algorithmic Langauge ALGOL68

Scaling Up Visual Programming Languages

Semantic anomaly detection in online data sources

Should Computer Scientists Experiment More?

SIMULA 67 common base definition

Sketchpad: A man--machine graphical communication system

SMALLTALK-80: the interactive programming environment

Smalltalk-80: the language and its implementation

Software enginering

Software technology maturation

Solution of a problem in concurrent programming control

Specification techniques for data abstractions

Status Report: Software Reusability

Strong typing of object-oriented languages revisited

Structured exception handling

Structured multiprogramming

Structured Programming

Structured programming

System structure for software fault tolerance

The annotated C++ reference manual

The case against multiple inheritance in C++, The evolution of C++:
language design in the marketplace of ideas

The coming-of-age of software architecture research

The Cornell program synthesizer: a syntax-directed programming environment

The development of the SIMULA languages

The early history and characteristics of PL/I

The evolution of C++: language design in the marketplace of ideas

The inscape environment

The Java Language Specification

The Larch family of specification languages

The Programming Language Aspects of ThingLab, a Constraint-Oriented
Simulation Laboratory

The programming language concurrent Pascal

The programming language Pascal

The Smalltalk-76 programming system design and implementation

The Standard Template Library

Thinkpad: A graphical system for programming by demonstration

Usability analysis of visual programming environments: A ‘cognitive
dimensions’ framework

Using HCI Techniques to Design a More Usable Programming System

Visual Basic how-To

Visual Programming

Visual programming in the real world, Visual object-oriented programming:
concepts and environments

What you see is what you test: a methodology for testing form-based
visual programs

Why I am called ‘the father of Visual Basic’},
 timestamp = {2010.02.09},
 title = {The impact of software engineering research on modern progamming
languages},
 year = {2005}
}

@article{E[13],
 abstract = {Laboratory-based courses play a critical role in scientific education.
Automation is changing the nature of these laboratories, and there
is a long-running debate about the value of hands-on versus simulated
laboratories. In addition, the introduction of remote laboratories
adds a third category to the debate. Through a review of the literature
related to these labs in education, the authors draw several conclusions
about the state of current research. The debate over different technologies
is confounded by the use of different educational objectives as criteria
for judging the laboratories: Hands-on advocates emphasize design
skills, while remote lab advocates focus on conceptual understanding.
We observe that the boundaries among the three labs are blurred in
the sense that most laboratories are mediated by computers, and that
the psychology of presence may be as important as technology. We
also discuss areas for future research.},
 author = {J. Ma, J. V. Nickerson},
 inserir = {false},
 references = {A ‘virtual laboratory’ for research training and collaboration

A distributed collaborative science learning laboratory on the Internet

A large-scale web-based virtual oscilloscope laboratory experiment

A measurement laboratory on geographic network for remote test experiments

A measurement laboratory on geographic network for remote test experiments

A microcontroller laboratory for electrical engineering

A modern digital simulation laboratory for power systems

A novel simulation concept of reduced computational cost for TD-CDMA
mobile radio systems with adaptive antennas

A proposal for a remotely shared control systems laboratory

A remote access laboratory for electrical circuit experiments

A remote measurement laboratory for educational experiments

A remote-access LabVIEW-Based laboratory for environmental and ecological
science

A remotely accessed HVAC laboratory for distance education

A review of presence and performance in virtual environments

A sample survey of departments of electrical engineering to determine
recent significant changes in laboratory work patterns at first year
level

A study of the relationship between student final exam performance
and simulation game participation

A teaching-laboratory experiment

A vision-based experiment for mechanical engineering laboratory courses

A web-based multimedia virtual experiment

A web-based, interactive virtual laboratory system for unit operations
and process systems engineering education: Issues, design and implementation

Accessibility and usability in complex web based learning applications:
Lessons from the PEARL project

Addressing the challenges of inquiry-based learning through technology
and curriculum design

Advantages and disadvantages of using various computer tools in electrical
engineering courses

An assessment of in-person and remotely operated laboratories

An empirical evaluation of the pedagogical value of playing a simulation
game in a principles of marketing course

An empirical study comparing the learning environments of open and
closed computer laboratories

An evaluation of the student response to electronics teaching using
a CAL package

An exploratory investigation of computer simulations, student preferences,
and performance

An undergraduate low-level computer communications laboratory oriented
towards industry

Assessing the effectiveness of remote networking laboratories

Assessing the quality of web-enabled laboratories in undergraduate
education

Asynchronous Videoconferencing: A Hybrid Communication Prototype

At the heart of it all: The concept of presence

Autonomy, interaction, and presence

Benefiting from an open-ended experiment? A comparison of attitudes
to, and outcomes of, an expository versus an open-inquiry version
of the same experiment

Charting presence in virtual environments and its effects on performance

Collaborative peer learning in the laboratory

Collaborative task performance for learning using a virtual environment

Collaborative web-based experimentation in flexible engineering education

Computer simulation of laboratory experiments: an unrealized potential

Computerized pendulum experiment for the introductory physics laboratory

Conceptual change in science and in science education

Conceptual priming as a determinant of presence in virtual environments

Conducting laboratory experiments over the Internet

Confidence and critical awareness as factors in the development of
experimentation skills in laboratory courses

Contemporary approaches to learning science: Technologically-mediated
practical work

Cost effective and advanced teaching laboratory development at the
University of Adelaide

Descartes, Heidegger, Gibson, and God: Towards an eclectic ontology
of presence

Design and experimentation in undergraduate mechanical engineering

Development of a distant laboratory using labVIEW

Discourse about ideas: Monitoring and regulation in face-to-face and
computer-mediated environments

Distance education and its impact on computer engineering laboratories

Effective laboratory teaching

Effects of Constrained Information on Player Decisions in Experimental
Business Simulation: Some Empirical Evidence

Embedded Internet laboratory

Embedding remote experimentation in power engineering education

Ends and means in laboratory teaching

Engineering an interoperable computational collaoratory on the grid

Engineering students' understanding of the role of experimentation

Epistemological resources for thought experimentation in science learning

Evaluating a scientific collaboratory: Results of a controlled experiment

Evaluating ADAPT: a hybrid instructional model combining web-based
and classroom components

Evaluating mechanical engineering laboratory work

Evaluation of computer based laboratory simulation

Experience with low cost laboratory data

EyeTap devices for augmented, deliberately diminished, or otherwise
altered visual perception of rigid planar patches of real-world scenes

Facilitating interdisciplinary hands-on learning using LabView

Formative evaluation of bugscope: A sustainable world wide laboratory
for K-12

From laboratories to collaboratories: A new organizational form for
scientific collaboration

Group-Based learning using a remote laboratory

Hands-on engineering: Learning by doing in the integrated teaching
and learning program

Higher-Order thinking in the unit operations laboratory

History, Philosophy, and Science Teaching

How undergraduate students meet a new learning environment?

Improving creativity, solving problems and communications with peers
in engineering science laboratories

Improving the cost-effectiveness of laboratory teaching

Independent student learning aided by computers: an acceptable alternative
to lectures?

Inserting the presence of mind into a philosophy of presence: A response
to Sheridan and Mantovaniand Riva

Integrating computerized data acquisition and analysis into an undergraduate
electric machines laboratory

Integrating the Internet, multimedia components, and hands-on experimentation
into problem-based control education

Interactive multimedia web-based courseware with virtual laboratories

Intravenous catheter training system: Computer-Based education versus
traditional learning methods

Introducing 9--12 grade students to electrical engineering technology
through hands-on laboratory experiences

Is distance teaching more work or less work?

Is laboratory teaching effective?

Issues and questions regarding the effectiveness of labwork

Laboratory work as scientific method: Three decades of confusion and
distortion

Learning histories in simulation-based teaching: The effects on self-learning
and transfer

Learning science by doing science on the web

Learning science through collaborative visualization over the internet

Learning scientific concepts through material and social activities:
Conversational analysis meets conceptual change

Levels of scientific inquiry in university science laboratory classes:
Implications for curriculum deliberations

Mapping the physical world to psychological reality: creating synthetic
environments

Measuring presence in virtual environments: A presence questionnaire

Microcomputers in a college teaching laboratory

Microcomputers in the undergraduate instrumentation lab

Musings on telepresence and virtual presence

New era in engineering experiments: An integrated and interactive
teaching/learning approach, and real-time visualizations

Objectives for engineering laboratory instruction

Perceptive Presence

Practical class work at the Cavendish laboratory

Presence and distal attribution: Phenomenology, determinants and assesment

Presence in immersive virtual environments

Presence: Concept, determinants and measurement

Psychological Considerations in the Designs of Training Equipment

Re-engineering the practical laboratory session

Reflections on teaching experimentation to “applications” engineering
undergraduates

ReMLab: A Java-Based remote, didactic measurement laboratory

Remote access internetworking laboratory

Remote controlled experiments for teaching over the Internet: A comparison
of approaches developed in the PEARL project

Remote evaluation: the network as an extension of the usability laboratory

Remote experimentation on three coupled water reservoirs

Remote experiments, re-versioning and re-thinking science learning

Remote laboratories versus virtual and real laboratories

Remote laboratory

Remote laboratory experimentation

Remote laboratory experiments in electrical engineering education

Remote versus hands-on labs: A comparative study

Remotely accessible laboratory for electronic measurement teaching

Resource management portal for laboratories using real devices on
the Internet

Role of laboratory education in power engineering: Is the virtual
laboratory feasible?

Role of laboratory education in power engineering: Is the virtual
laboratory feasible?

Role of laboratory education in power engineering: Is the virtual
laboratory feasible?

Seeing what we build together: Distributed multimedia learning environments
for transformative communications

Sensemaking in organizations

Simulation and undergraduate engineering education: the technology
reinvestment project(TRP

Simulation software in a life sciences practical laboratory

Situated Learning Perspectives

Social presence with video and application sharing

Structure of the disciplines: Meanings and significances

Students' understanding of the objectives and procedures of experimentation
in the science classroom

Teaching research in an undergraduate laboratory

The Anatomy of the Grid: Enabling Scalable Virtual Organizations

The design of pedagogical agent for distance virtual experiment

The effective use of laboratories in undergraduate courses

The effects of levels of immersion on memory and presence in virtual
environments: A reality centered approach

The laboratory aims questionnaire---A new method for course improvement?

The laboratory in science education: Foundations for the Twenty-First
Century

The local production of order in traditional science laboratories:
A phenomenological analysis

The nature of scientific enquiry

The nature of the laboratory experience: A guide for describing, classifying
and enhancing hands-on activities

The reality of collaboratories

The Relationship Between Presence and Performance in Virtual Environments:
Results of a VERTS Study

The role of computer simulations in engineering education

The role of laboratories in engineering education

The role of laboratory experiments and the impact of high-tech equipment
on engineering education

The role of laboratory work in engineering education: Student and
staff perceptions

The role of the laboratory in science teaching: Neglected aspects
of research

The role of the laboratory in undergraduate engineering education

The roles of representations and tools in the chemistry laboratory
and their implications for chemistry learning

The sense of presence within virtual environments: A conceptual framework

The Social Psychology of Telecommunications

The virtual lab for controlling real experiments via Internet

Topics and manner of talk in undergraduate practical laboratories

Towards a national collaboratory

Towards a web-based control engineering

Towards virtual laboratories: A survey of LabVIEW-Based teaching/learning
tools and future trends

Training: Research and Practice

Undergraduate engineering ceramics laboratory development

Using a laboratory simulator in the teaching and study of chemical
processes in estuarine systems

Using embedded Internet devices in an Internet engineering laboratory
set-up

Using remote laboratories to extend access to science and engineering

Using the laboratory to enhance student learning

Using web-based instruction to improve large undergraduate biology
courses: an evaluation of a hybrid course format

ViBE: virtual biology experiments

Virtual laboratories enhance traditional undergraduate biology laboratories

Web services remote educational laboratory

Web-based courseware in teaching laboratory-based courses

WebLab! A universal and interactive teaching, learning, and laboratory
environment for the World Wide Web},
 timestamp = {2010.02.09},
 title = {Hands-on, simulated and remote laboratories: a comparative literature
review},
 year = {2006}
}

@article{E[14],
 abstract = {Over the last decades, a considerable amount of empirical knowledge
about the efficiency of defect-detection techniques has been accumulated.
Also a few surveys have summarised those studies with different focuses,
usually for a specific type of technique. This work reviews the results
of empirical studies and associates them with a model of software
quality economics. This allows a better comparison of the different
techniques and supports the application of the model in practice
as several parameters can be approximated with typical average values.
The main contributions are the provision of average values of several
interesting quantities w.r.t. defect detection and the identification
of areas that need further research because of the limited knowledge
available.},
 author = {S. Wagner},
 inserir = {false},
 references = {A Comparison of Software Defects in Database Management Systems and
Operating Systems

A history of software inspections

A Literature Survey of the Software Quality Economics of Defect-Detection
Techniques

A model and sensitivity analysis of the quality economics of defect-detection
techniques

A Software Reliability Model Based on a Geometric Sequence of Failure
Rates

A Survey of Software Inspection Technologies

Applied software measurement: assuring productivity and quality

Art of Software Testing

Comparing Bug Finding Tools with Reviews and Tests

Comparing the effectiveness of software testing strategies

Cost-Optimisation of Analytical Software Quality Assurance

Empirical Analysis of Safety-Critical Anomalies During Operations

Error injection aimed at fault removal in fault tolerance mechanisms-criteria
for error selection using field data on software faults

Extended static checking for Java

Finding User/Kernel Pointer Bugs With Type Inference

Functional Testing, Structural Testing and Code Reading: What Fault
Type Do They Each Detect

Key Lessons in Achieving Widespread Inspection Use

Modeling the Effects of Combining Diverse Software Fault Detection
Techniques

On Comparisons of Random, Partition, and Proportional Partition Testing

Optimizing Preventive Service of Software Products

Quantitative aspects of software validation

Reviewing 25 Years of Testing Technique Experiments

Software Engineering Economics

Software Inspection

Software quality assurance: an analytical survey and research prioritization

Software Reliability: Additional Investigations into Modeling with
Replicated Experiments

Theoretical and Empirical Studies of Program Testing

Using simulation to build inspection efficiency benchmarks for development
projects},
 timestamp = {2010.02.09},
 title = {A literature survey of the quality economics of defect-detection
techniques},
 year = {2006}
}

@article{E[1],
 abstract = {We provide an extensive overview of existing research in the field
of software refactoring. This research is compared and discussed
based on a number of different criteria: the refactoring activities
that are supported, the specific techniques and formalisms that are
used for supporting these activities, the types of software artifacts
that are being refactored, the important issues that need to be taken
into account when building refactoring tool support, and the effect
of refactoring on the software process. A running example is used
to explain and illustrate the main concepts.},
 author = {Tom Mens, Tom Tourwé},
 inserir = {false},
 references = {A Formal Pattern Language for Refactoring of Lisp Programs

A Language Independent Approach for Detecting Duplicated Code

A Methodology for Developing Transformations Using the Maintainability
Soft-Goal Graph

A Methodology for the Automated Introduction of Design Patterns

A Metric-Based Approach to Enhance Design Quality through Meta-pattern
Transformations

A Model for Change Propagation Based on Graph Rewriting

A notion of map between logic programs

A refactoring tool for Smalltalk

A Reorganization Framework of the Object-Oriented Class Hierarchy

Advanced Clone-Analysis to Support Object-Oriented System Refactoring

Automated assistance for program restructuring

Automatic inheritance hierarchy restructuring and method refactoring

Automating the Evolution of Object-Oriented Systems

Challenges of refactoring C programs

Concept Analysis for Module Restructuring

Confluence of Typed Attributed Graph Transformation Systems

Design patterns: elements of reusable object-oriented software

Evolving Object-Oriented Designs with Refactorings

Extracting Reusable Functions by Flow Graph-Based Program Slicing

Extreme programming explained: embrace change

Finding refactorings via change metrics

Formal Concept Analysis: Mathematical Foundations

Formalising Behaviour Preserving Program Transformations

Graph grammars with negative application conditions

Identifying objects using cluster and concept analysis

Identifying Refactoring Opportunities Using Logic Meta Programming

Implications of automated restructuring of COBOL

Inconsistency Management for Multiple-View Software Development Environments

Java Quality Assurance by Detecting Code Smells

Leveraging Inconsistency in Software Development

Maintenance and abstraction of program data using formal transformations

Maintenance of object-oriented systems during structural evolution

Maintenance: Less Is Not More

Managing application program maintenance expenditures

Metrics Based Refactoring

Object Oriented Reengineering Patterns

Object-oriented development: the fusion method

Object-preserving class transformations

On the Computer Aided Introduction of Design Pattern into Object-Oriented
Systems

Optimizing Object-Oriented Languages Through Architechtural Transformations

Practical analysis for refactoring

Problems with automatic restructurers

Program development by stepwise refinement

Reengineering class hierarchies using concept analysis

Reengineering Object-Oriented Code

Refactoring Browser with Preprocessor

Refactoring for generalization using type constraints

Refactoring UML Models

Refinement of Information Flow Architectures

Restructuring Legacy C Code into C++

Restructuring Requirements Specifications For Managing Inconsistency
And Change: A Case Study

Restructuring sequential Fortran code into a parallel/distributed
application

Reuse by Program Transformation

Reverse Engineering and Design Recovery: A Taxonomy

Rules and strategies for transforming functional and logic programs

Semantics and implementation of schema evolution in object-oriented
databases

Semantics preserving transformation rules for Prolog

Slicing object-oriented software

Software Maintenance Management

Systematic Change of Data Representation: Program Manipulations and
a Case Study

The Role of Constructors in the Context of Refactoring Object-Oriented
Systems

Tool support for planning the restructuring of data abstractions in
large systems

Tool support for refactoring functional programs

Total correctness by local improvement in the transformation of functional
programs

Towards generic refactoring

Tutorial on software restructuring

Using knowledge-based transformations to reverse-engineer COBOL programs

Using Metrics to Evaluate Software System Maintainability},
 timestamp = {2010.02.09},
 title = {A survey of software refactoring},
 year = {2004}
}

@article{E[2],
 abstract = {Over the last decade, a lot of research has been directed toward integrating
performance analysis into the software development process. Traditional
software development methods focus on software correctness, introducing
performance issues later in the development process. This approach
does not take into account the fact that performance problems may
require considerable changes in design, for example, at the software
architecture level, or even worse at the requirement analysis level.
Several approaches were proposed in order to address early software
performance analysis. Although some of them have been successfully
applied, we are still far from seeing performance analysis integrated
into ordinary software development. In this paper, we present a comprehensive
review of recent research in the field of model-based performance
prediction at software development time in order to assess the maturity
of the field and point out promising research directions.},
 author = {S. Balsamo, A. Di Marco, P. Inverardi, M. Simeoni},
 inserir = {false},
 references = {A Framework for Software Performance Engineering of Client/Server
Systems

A Framework for the Hierarchical Analysis of Discrete Event Dynamic
Systems

A Method for Design and Performance Modeling of Client/Server Systems

A Toolset for Performance Engineering and Software Design of Client-Server
Systems

A Tutorial on EMPA: A Theory of Concurrent Processes with Nondeterminism

A UML Tool for an Automatic Generation of Simulation Programs

ÆMPA: A Process Algebraic Description Language for the Performance
Analysis of Software Architectures

Algébre de Processus et Synchronization

Annotated Bibliography on Stochastic Petri Nets

Applying UML Performance Profile: Graph Grammar-Based Derivation of
LQN Models from UML Specifications

Automated Performance Modeling of Software Generated by a Design Environment

Automatic Derivation of Software Performance Models from CASE Documents

Combining Queueing Networks and Generalized Stochastic Petri Nets
for the Solution of Complex Models of System Behaviour

Combining Stochastic Process Algebras and Queueing Networks for Software
Architecture Analysis

Communicating Sequential Processes

Communication and Concurrency

Compositional Performance Modelling with the TIPPtool

Derivation of Petri Net Performance Models from UML Specifications
of Communication Software

Deriving a Queueing Network Based Performance Model from UML Diagrams

Deriving Performance Models of Software Architectures from Message
Sequence Charts

Design and Performance Modeling of Component Interconnection Patterns
for Distributed Software Architectures

Discrete-Event System Simulation

Early Generation of Performance Models for Object-Oriented Systems

Exploiting Quasi-Reversible Structures in Markovian Process Algebra
Models

Finite Markov Chains

From UML Descriptions of High-Level Software Architectures to LQN
Performance Models

From UML Sequence Diagrams and Statecharts to Analysable Petri Net
Models

Introduction to Automata Theory

Introduction to Computer System Performance Evaluation

Model-Based Performance Prediction in Software Development: A Survey

Object-Oriented Modeling and Design

On a Language Based Method for Software Performance Engineering of
Client/Server Systems

PASA: A Method for the Performance Assesment of Software Architectures

PEPAPerformance Enhanced Process Algebra

Performance Analysis at the Software Architecture Design Level

Performance Analysis of Time-Enhanced UML Diagrams Based on Stochastic
Processes

Performance Engineering Evaluation of Object-Oriented Systems with
SPEED

Performance Engineering of Component-Based Distributed Software Systems

Performance Engineering of Software Systems

Performance Evaluation of Software Architectures

Performance Models of Multiprocessor Performance

Performance of Multi-Level Client-Server Systems with Parallel Service
Operations

Performance Solutions: A Practical Guide to Creating Responsive

Petri Nets: An Introduction

PRIMAmob-UML: A Methodology for Performance Analysis of Mobile Software
Architectures

Probability and Statistics with Reliability

Process Algebra for Performance Evaluation

Product Form Solution for a Class of PEPA Models

Quantitative System Performance: Computer System Analysis Using Queueing
Network Models

Queueing Systems

Software Architecture Design: Evaluation and Transformation

Software Architecture in Practice

Software Performance Models from System Scenarios in Use Case Maps

Technical Note: A Hierarchical Computer Architecture Design and Simulation
Environment

The Hierarchical Evaluation Tool HIT

The Method of Layers

The PEPA Workbench: A Tool to Support a Process Algebra-Based Approach
to Performance Modelling

The Stochastic Rendezvous Network Model for Performance of Synchronous
Client-Server-Like Distributed Software

The Unified Modeling Language and Performance Engineering

TIPPA Language for Timed Processes and Performance Evaluation

Towards a Product Form Solution for Stochastic Process Algebras

TwoTowers 1.0 User Manual

UML Extensions for the Specification and Evaluation of Latency Constraints
in Architectural Models

UML-Based Performance Modeling Framework for Component-Based Distributed
Systems

Use CASE Maps for Object-Oriented Systems

Using UML Models for Performance Calculation

Using UML to Derive Stochastic Process Algebra Models

What is a ‘Distributed’ Data Processing System?

XSLT Transformation from UML Models to LQN Performance Models},
 timestamp = {2010.02.09},
 title = {Model-Based Performance Prediction in Software Development: A Survey},
 year = {2004}
}

@article{E[3],
 abstract = {Because of the extensive uses of components, the Component-Based Software
Engineering (CBSE) process is quite different from that of the traditional
waterfall approach. CBSE not only requires focus on system specification
and development, but also requires additional consideration for overall
system context, individual components properties and component acquisition
and integration process. The term component-based software development
(CBD) can be referred to as the process for building a system using
components. CBD life cycle consists of a set of phases, namely, identifying
and selecting components based on stakeholder requirements, integrating
and assembling the selected components and updating the system as
components evolve over time with newer versions. This work presents
an indicative literature survey of techniques proposed for different
phases of the CBD life cycle. The aim of this survey is to help provide
a better understanding of different CBD techniques for each of these
areas.},
 author = {S. Mahmood, R. Lai, Y. S. Kim},
 inserir = {false},
 references = {A component based methodology for web application development

A component model for invasive composition

A conceptual foundation for component based software

A COTS selection method and experience of its use

A method for built-in tests in component based software

A multitiered classification scheme for component retrieval

A Problem oriented and rule based component repository

A systematic regression testing method and tool for software components

Acquiring COTS software selection requirements

An architectural approach to building systems from COTS software

An assessment model for requirements identification in component based
software

An ontology for software component matching

Assessing component based systems. Component based software quality

Automated Black-box evaluation of COTS components with multiple-interfaces

Black-box understanding of COTS components

Building component-based reliable software systems

Business component identification – a formal approach

Challenges and problems in testing software components

Challenges of component based development

Characterization of a taxonomy for business applications and the relationship
among them

CIMO – component integration model

COMO: a UML-based component development methodology

Component adaptation for event-based application integration using
active rules

Component Based Software Engineering

Component based systems development: challenges and lessons learned

Component identification method with coupling and cohesion

Component primer

Component rank: relative significance rank for software component
search

Component software – beyond object – oriented programming

Component-based software engineering: putting the pieces together

Co-operating evolving components: a rigorous approach to evolving
large software systems

Corrigenda: a hierarchy-aware approach to faceted classification of
object oriented components

COTS products characterization: proposal and empirical assessment

CRE: a systematic method for COTS selection

Defining and applying measure of distance between specifications

Early detection of COTS component functional suitability

Engineering of component based systems

Evidence-based software engineering

Evidence-based software engineering for practitioners

Identifying commercial off-the-shelf (COTS) product risks: the COTS
usage risk evaluation

Integrated requirements engineering: a tutorial

Integrating independent components with on-demand remodularization

Integration of object-oriented software components for distributed
application software

Investigating conflicts in COTS decision-making

JAsCo: an aspectoriented approach tailored for component based software
development

Knowledge based COTS aware requirements engineering

Mechanisms for integration and enhancement of software components

Merging components and testing tools: the self-testing COTS components
(STECC) strategy

On building testable software components

On the efficiency of domain based COTS product selection

Process-oriented, consistent integration of software components

Requirement based automated Black-box test generation

Risks and challenges of component based software development

Selecting components in large COTS repositories

Selecting software components with multiple

Signature matching: a tool for using software libraries

Software evolution in component ware using requirements/assurances
contracts

Specification matching of software components

Specification, implementation, and deployment of components

Storing and retrieving software components: a refinement based

Supporting evolution in component based development using component
libraries

Techniques for testing componentbased software

Test reuse in CBSE using built-in tests

Testing and quality assurance for component based software

Testing component based software: a cautionary tale

Testing coverage analysis for software component validation

The current state of CBSE

Trends on COTS component identification

Using adapters to reduce interaction complexity in reusable component
based software development},
 timestamp = {2010.02.09},
 title = {Survey of component-based software development},
 year = {2007}
}

@article{E[4],
 abstract = {Distribution in software development projects is a complex phenomenon
with many dimensions. In addition to the obvious physical dimension
entailed by geographically dispersed project personnel and resources,
projects must contend with organizational distribution among various
company departments, for example, as well as temporal and stakeholder
distributions. A review of the literature on globally distributed
software development projects produced a preliminary taxonomy based
on a dimensional analysis of distribution. Developers can use this
taxonomy to identify and visualize their project's distribution dimensions
and scopes. A real-world case study of the taxonomy's use illuminates
its value, as well as common challenges and possible solutions to
distribution problems.This article is part of a special issue on
Global Software Development.},
 author = {Gumm, D.C.},
 inserir = {false},
 references = {An Exploratory Study of Facilitation in Distributed Requirements Engineering

Communication Needs, Practices and Supporting Structures in Global
Inter-Organizational Software Development Projects

Coordinating Open-Source Software Development

Distributed Development: Lessons Learned

Distributed Software Development: Toward an Understanding of the Relationship
between Project Team, Users and Customers

Fallbeispiele der CommSy-Nutzung-Eine Sammlung von Nutzungsberichten

From Small Scale to Large Scale User Participation: A Case Study of
Participatory Design in Egovernment Systems

Geographically Distributed Project Teams: A Dimensional Analysis

Managing Crosscultural Issues in Global Software Outsourcing

Modeling Coordination Costs Due to Time Separation in Global Software
Teams

Participatory Design for Widely-Distributed Scientific Communities

Taxonomy of PD Practices: A Brief Practitioner's Guide

Teaching Social Informatics as a Knowledge Project

The Phenomenon of Distribution in Software Development Projects: A
Taxonomy Proposal

Understanding Open Source Software Development

Understanding the Requirements for Developing Open Source Software
Systems

Using a Groupware Space for Distributed Requirements Engineering

Using Groupware for Mediated Feedback

Working Group Report of the 2nd Workshop on Coordinating Distributed
Software Development Projects

Working Group Report on Coordinating Distributed Software Development
Projects},
 timestamp = {2010.02.09},
 title = {Distribution Dimensions in Software Development Projects: A Taxonomy},
 year = {2006}
}

@article{E[5],
 abstract = {Since the late 1980s, software architecture has emerged as the principled
understanding of the large-scale structures of software systems.
From its roots in qualitative descriptions of empirically observed
useful system organizations, software architecture has matured to
encompass a broad set of notations, tools, and analysis techniques.
Whereas initially the research area interpreted software practice,
it now offers concrete guidance for complex software design and development.
It has made the transition from basic research to an essential element
of software system design and construction. This retrospective examines
software architecture's growth in the context of a technology maturation
model, matching its significant accomplishments to the model's stages
to gain perspective on where the field stands today. This trajectory
has taken architecture to its golden age.},
 author = {M. Shaw, P. Clements},
 inserir = {false},
 references = {A Field Guide to Boxology: Preliminary Classification of Architectural
Styles for Software Systems

A Formal Approach to Software Architectures

A Framework for Classifying and Comparing Architecture Description
Languages

Acme: An Architecture Description Interchange Language

An Introduction to Software Architecture

Analysis of a Conflict between Interface Negotiation and Aggregation
in Microsoft's Component Object Model

Applied Software Architecture

Blackboard Systems

Classifying Architectural Elements as a Foundation for Mechanism Matching

Component Software—Beyond Object-Oriented Programming

Documenting Software Architectures: Views and Beyond

Dynamic Structure in Software Architectures

Elements of a Design Language for Software Architecture

Evaluating Software Architectures: Methods and Case Studies

Experience with Performing Architecture Tradeoff Analysis

Formal Modeling and Analysis of the HLA Component Integration Standard

Formalizing Style to Understand Descriptions of Software Architecture

Formally Specifying Electronic Instruments

Foundations for the Study of Software Architecture

Heterogeneous Design Idioms for Software Architecture

Npsnet: A Network Software Architecture for Large Scale Virtual Environments

Paradigms for Process Interaction in Distributed Programs

Pattern-Oriented Software Architecture: A System of Patterns

Performance Engineering

Preliminary Design of ArchE: A Software Architecture Design Assistant

Principles for Evaluating the Quality Attributes of a Software Architecture

SAAM: A Method for Analyzing the Properties of Software Architectures

Software Architecture for Hard Real-Time Applications: Cyclic Executives
vs. Fixed Priority Executives

Software Architecture in Industrial Applications

Software Architecture in Practice

Software Architecture: Perspectives on an Emerging Discipline

Software Technology Maturation

Specification and Analysis of System Architecture Using Rapide

The 4+1 View Model of Software Architecture

The Coming-of-Age of Software Architecture Research

The Domain-Specific Software Architecture Program

The Golden Age of Software Architecture: A Comprehensive Survey

The Modular Structure of Complex Systems

Toward Higher-Level Abstractions for Software Systems

Towards a Taxonomy of Software Connectors},
 timestamp = {2010.02.09},
 title = {The golden age of software architecture},
 year = {2006}
}

@article{E[6],
 abstract = {The open source software community has published a substantial body
of research on OSS quality. Focusing on this peer-reviewed body of
work lets us draw conclusions from empirical data rather than rely
on the large volume of evangelical opinion that has historically
dominated this field. This body of published research has become
much more critical and objective in its efforts to understand OSS
development, and a consensus has emerged on the key components of
high-quality OSS delivery. This article reviews this body of research
and draws out lessons learned, investigating how the approaches used
to deliver high-quality OSS differ from, and can be incorporated
into, closed-source software development.},
 author = {M. Aberdour},
 inserir = {false},
 references = {A Case Study of Open Source Software Development: The Apache Server

A Survey on Quality Related Activities in Open Source

An Overview of the Software Engineering Process and Tools in the Mozilla
Project

Code Quality Analysis in Open Source Software Development

Collaboration with Lean Media: How Open-Source Software Succeeds

Controversy Corner: Open Source Software—An Evaluation

Effective Work Practices for Software Engineering: Free/Libre Open
Source Software Development

Essence of Distributed Work: The Case of the Linux Kernel

Evolution Patterns of Open-Source Software Systems and Communities

Fuzz Revisited: A Re-Examination of the Reliability of UNIX Utilities
and Services

Issues of Dependability in Open Source Software Development

Lessons from Open-Source Software Development

Open Source Methodology—Ready for Prime Time?

Open Source Methods: Peering through the Clutter

Progressive Open Source

The Cathedral and the Bazaar: Musings on Linux and Open Source by
an Accidental Revolutionary

The Linux Kernel Development as a Model of Open Source Knowledge Creation

The Power of Gifts: Organizing Social Relationships in Open Source
Communities

Toward an Understanding of the Motivation of Open Source Software
Developer

Two Case Studies of Open Source Software Development: Apache and Mozill},
 timestamp = {2010.02.09},
 title = {Achieving Quality in Open Source Software},
 year = {2007}
}

@article{E[7],
 abstract = {Due to its communication and collaboration-intensive nature, as well
as inherent interaction with most other development processes, the
practice of requirements engineering is becoming a key challenge
in global software engineering (GSE). In distributed projects, cross-functional
stakeholder groups must specify and manage requirements across cultural,
time-zone, and organizational boundaries. This creates a unique set
of problems, not only when an organization opens new development
subsidiaries across the world but also when software development
is a multiorganizational business affair. We need innovative processes
and technologies to manage stakeholders' expectations and interaction
in global projects. This article reports on the state of the practice,
drawn from industrial empirical studies, of stakeholders' interaction
in global RE. The article revisits stakeholders' needs in global
RE, discusses the challenges they face in distributed interaction,
and offers practical advice to alleviate these challenges, as distilled
from empirical studies of GSE practice.},
 author = {D. Damian},
 inserir = {false},
 references = {An Empirical Study of the Complex Relationships between Requirements
Engineering Processes and Other Processes That Lead to Payoffs in
Productivity, Quality and Risk Management

Collaboration Practices in Global Inter-Organizational Software Development
Projects

Global Software Engineering

Leveraging Resources in Global Software Development

Managing Knowledge in Global Software Development Efforts: Issues
and Practices

Overcoming Requirements Engineering Challenges: Lessons Learned from
Offshore Outsourcing

Requirements Engineering

Requirements Engineering Challenges in Multi-Site Software Development
Organizations

Requirements Engineering during Global Software Development: Some
Impediments to the Requirements Engineering Process—A Case Study

Requirements Management in Distributed Projects

Surviving Global Software Development

Synching or Sinking: Global Software Outsourcing Relationships

Tactical Approaches for Alleviating Distance in Global Software Development

The Hidden Costs of Offshore Outsourcing

Towards a Model of Awareness Support of Software Development in GSD},
 timestamp = {2010.02.09},
 title = {Stakeholders in Global Requirements Engineering: Lessons Learned from Practice},
 year = {2007}
}

@article{E[8],
 abstract = {Over the years the software engineering community has increasingly
realized the important role software architecture plays in fulfilling
the quality requirements of a system. The quality attributes of a
software system are, to a large extent determined by the system’s
software architecture. In recent years, the software engineering
community has developed various tools and techniques that allow for
design for quality attributes, such as performance or maintainability,
at the software architecture level. We believe this design approach
can be applied not only to “traditional” quality attributes such
as performance or maintainability but also to usability. This survey
explores the feasibility of such a design approach. Current practice
is surveyed from the perspective of a software architect. Are there
any design methods that allow for design for usability at the architectural
level? Are there any evaluation tools that allow assessment of architectures
for their support of usability? What is usability? A framework is
presented which visualizes these three research questions. Usability
should drive design at all stages, but current usability engineering
practice fails to fully achieve this goal. Our survey shows that
there are no design techniques or assessment tools that allow for
design for usability at the architectural level.},
 author = {E. Folmer, J. B. Bosch},
 inserir = {false},
 references = {A teaching method as an alternative to the concurrent think-aloud
method for usablity testing

Achieving usability through software architecture

An empirical study of perspective-based usability inspection

Analyzing software architectures for modifiability

Assessing optimal software architecture maintainability

Breaking down usability

Carriere, The architecture tradeoff analysis method

Confirmatory factor analysis of the end-user computing satisfaction
instrument

Design and Use of Software Architectures: Adopting and Evolving a
Product Line Approach

Design erosion: problems & causes

Design Patterns Elements of Reusable Object-orientated Software

Designing the User Interface: Strategies for Effective Human–Computer
Interaction

Designing the User Interface: Strategies for Effective Human–Computer
Interaction

Developing User Interfaces: Ensuring Usability through Product and
Process

Development of an instrument measuring user satisfaction of the human–computer
interface

Evaluation Usability of Human–Computer Interfaces: A Practical Method

Heuristic evaluation

Human–Computer Interaction

IBM Computer Usability Satisfaction Questionnaires: Psychometric Evaluation
and Instructions for Use

Inspections and design reviews: framework, history, and reflection

Interaction Design Patterns

Interaction patterns in user interfaces

International standards for HCI and usability

Introduction to HCI

Jenifer Tidwell’s Pattern Collection

Maintainability myth causes performance problems in parallel applications

Measuring usability as quality of use

Methods for Evaluating Usability

Nine management guidelines for better cost estimating

One-dimensional usability––influence of usability on consumers’ product
preference publication A21

Overview of usability evaluation methods

Perceived Usefulness, Perceived Ease of Use, and User Acceptance of
Information Technology

Perspective-based usability inspection

Practical Guide to Usability Testing

Psychometric evaluation of the post-study system usability questionnaire:
the PSSUQ

Remote evaluation: the network as an extension of the usability laboratory

Scenario-based analysis of software architecture

Scenarios in discount usability engineering

Software Architecture in Practice

Testing Two Participants at a Time

The cognitive jogthrough: a fast-paced user interface evaluation procedure

The Cognitive walkthrough: a practitioner’s guide

The Human Factor: Designing Computer Systems for People

The Mythical Man-Month: Essays on Software Engineering

The pluralistic usability walkthrough: coordinated empathies

The Psychology of Everyday Things

The Survey Research Handbook

The Timeless Way of Building

The usability engineering framework for product design and evaluation

Theory-based design for easily learned interfaces

Usability as a goal for the design of computer systems

Usability Engineering

Usability is quality of use

Usability Patterns for Applications on the World Wide Web

Usability: practical methods for testing and improvement

Usability–context, framework, design and evaluation

User-Centered Design: An Integrated Approach

USERfit, A Practical Handbook on User-centred Design for Assistive
Technology

Web-based User Interface Evaluation with Questionnaires

What is usability?

What users say about software usability},
 timestamp = {2010.02.09},
 title = {Architecting for usability: a survey},
 year = {2004}
}

@article{E[9],
 abstract = {As software systems evolve over time, they invariably undergo changes
that can lead to a degeneration of the architecture. Left unchecked,
degeneration may reach a level where a complete redesign is necessary,
a task that requires significant effort. In this paper, we present
a survey of technologies developed by researchers that can be used
to combat degeneration, that is, technologies that can be employed
in identifying, treating and researching degeneration. We also discuss
the various causes of degeneration and how it can be prevented.},
 author = {H. Lorin, L. Mikael},
 inserir = {false},
 references = {A classification and comparison framework for software architecture
description languages

A cliche-based environment to support architectural reverse engineering

A framework for experimental evaluation of clustering techniques

A goal-driven and agent-based requirements engineering framework

A methodology for the automated introduction of design patterns

A metrics suite for object-oriented design

A reverse engineering approach to subsystem structure identification

A survey of architecture description languages

A survey on software architecture analysis methods

A two-phase process for software architecture improvement

An integrated approach for studying architectural evolution

An intelligent tool for re-engineering software modularity

An Introduction to Software Architecture

Analyzing Java software by combining metrics and program visualization

Architecture-centric evolution by software metrics and design patterns

Automatic verification of java design patterns

Avoiding architectural degeneration: an evaluation process for software
architecture

Bunch: a clustering tool for the recovery and maintenance of software
system structures

Comparison of abstract data type and abstract state encapsulation
detection techniques for architectural understanding

Design erosion: problems and causes

Design pattern implementation in Java and aspectJ

Design patterns as language constructs

Design Patterns—Elements of Reusable Object-oriented Systems

Design recovery by automated search for structural design patterns
in object oriented software

Detecting defects in object-oriented designs: using reading techniques
to increase software quality

Does code decay? Assessing the evidence from change management data

Does the code match the design? A process for architecture evaluation

ET++—an object oriented application framework in C++

Evaluating architectural extractors

Evaluating Software Architectures

Evaluating Software Architectures

Evolution support by homogeneously documenting patterns, aspects,
and traces

Explicit programming

Extracting concepts from file names; a new file clustering criterion

Extreme Programming Explained: Embrace Change

Foundations for the study of software architecture

GASE: visualizing software evolution-in-the-large

Idenitifying design-code inconsistencies in object-oriented software:
a case study

Laws of software evolution revisited

Maintaining traceability during object-oriented software evolution:
a case study

Modeling early requirements in Tropos: a transformation based approach

Monitoring compliance of a software system with its high-level design
models

Object oriented design pattern inference

Object-Oriented Modeling and Design

Pattern-based reverse-engineering of design components

Pattern-Oriented Software Architecture

Pattern-Oriented Software Architecture

Precise specification and automatic application of design patterns

Program Evolution: Processes of Software Change

Program understanding and maintenance with the CANTO environment

Recovering software architecture from multiple source code analyses

Refactoring Object-Oriented Frameworks

Refactoring tool for Smalltalk, Theory Practice Object Syst

Refactoring: Improving the Design of Existing Code

Requirements for an effective architecture recovery framework

Reuse reengineering and validation via concept assignment

Secrets from the Monster: extracting Mozilla's software architecture

Software aging

Software Architecture in Practice

Software architecture recovery and restructuring through clustering
techniques

Software design by reusing architectures

Software reflexion models: bridging the gap between source and high-level
models

Software salvaging and the call dominance tree

Static and Dynamic Reverse Engineering Techniques for Java Software
Systems

Structural model: architecture for software designers

Test Driven Development: By Example

The Mythical Man-Month

The orphan adoption problem in architecture maintenance

The software bookshelf

The Unified Modeling Language User Guide

The weighted combined algorithm: a linkage algorithm for software
clustering

Tool support for object-oriented patterns

Towards modelling and reasoning support for early-phase requirements
engineering

Towards Pattern-based Design Recovery

Two controlled experiments assessing the usefulness of design pattern
documentation in program maintenance

Understanding software systems using reverse engineering technology

Using metrics to identify design patterns in object-oriented software

View extraction and view fusion in architectural understanding},
 timestamp = {2010.02.09},
 title = {Combating architectural degeneration: a survey},
 year = {2005}
}

@article{I[11],
 abstract = {It is well documented that the software industry suffers from frequent
cost overruns. A contributing factor is, we believe, the imprecise
estimation terminology in use. A lack of clarity and precision in
the use of estimation terms reduces the interpretability of estimation
accuracy results, makes the communication of estimates difficult,
and lowers the learning possibilities. This paper reports on a structured
review of typical software effort estimation terminology in software
engineering textbooks and software estimation research papers. The
review provides evidence that the term ‘effort estimate’ is frequently
used without sufficient clarification of its meaning, and that estimation
accuracy is often evaluated without ensuring that the estimated and
the actual effort are comparable. Guidelines are suggested on how
to reduce this lack of clarity and precision in terminology.},
 author = {S. Grimstad, M. Jørgensen, K. J. Moløkken-Østvold},
 inserir = {true},
 quality = {3.0},
 references = {A conflict between the use of estimating and planning tools in the
management of information systems

A review of software surveys on software effort estimation

A review of studies on expert estimation of software development effort

A survey on software estimation in the norwegian industry

Adapting, correcting, and perfecting software estimates: a maintenance
metaphor

Agile Software Development with Scrum

An empirical analysis of software effort estimate alterations

An empirical study of maintenance and development estimation accuracy

An experience report on the personal software process

An integrative contingency model of software project risk management

Applying UML and Patterns: An Introduction to Object-oriented Analysis
and Design and Iterative Development

Can software risk management improve system development: an exploratory
study

Causes of inaccurate software development cost estimates

Cognitive conflict and goal conflict effects on task performance

Combining quantitative software development cost estimation precision
data with qualitative data from project experience reports at Ericsson
design center in Norway

Controlling Software Projects

Cost estimation of OO projects: empirical observations, practical
applications

Empirical investigation of systems development practices and results

Estimating requirements for a large, software engineering project
(experience with Ada COCOMO on SIDPERS-3)

Estimation of information systems development efforts: a pilot study

Estimeetings: development estimates and a front-end process for a
large project

Experts' estimates of task durations in software development projects

Factors systematically associated with errors in subjective estimates
of software development effort: the stability of expert judgment

Function point analysis: Evaluation of a software cost estimation
model

How much does a vacation cost?

How to obtain accurate estimates in a real-time environment using
full function points

Impact of effort estimates on software project work

Information systems and organizational change

IT Project Estimation—A Practical Guide to the Costing of Software

Managing programmer resources in a maintenance environment with function
points

Offentlig IT-sprekk for 6 mrd

PMP: Project Management Professional Study Guide

Predicting with sparse data

Procedures for Performing Systematic Reviews

Project Estimation in the Norwegian Software Industry—A Summary

Rapid Development

Realism in assessment of effort estimation uncertainty: It matters
how you ask

Reasons for software effort estimation error: impact of respondent
role, information collection approach, and data analysis method

Software Engineering

Software Engineering—A Practitioner's Approach

Software estimation perspectives

Software Metrics: Measurement for Software Process Improvement

Software project duration and effort: an empirical study

Standards and Practices for Forecasting, in Principles of Forecasting:
A Handbook for Researchers and Practitioners

Statistical analysis of deviation of actual cost from estimated cost
using actual project data

The Criteria for Success-Industry Trend or Event

The Mythical Man-Month: Essays on Software Engineering

The role of motivated reasoning in optimistic time predictions

Undersizing software systems: third versus fourth generation software
development

Waltzing With Bears: Managing Risk on Software Projects},
 timestamp = {2010.02.09},
 title = {Software effort estimation terminology: the tower of Babel},
 year = {2005}
}

@article{I[12],
 abstract = {Empirically based theories are generally perceived as foundational
to science. However, in many disciplines, the nature, role and even
the necessity of theories remain matters for debate, particularly
in young or practical disciplines such as software engineering. This
article reports a systematic review of the explicit use of theory
in a comprehensive set of 103 articles reporting experiments, from
of a total of 5,453 articles published in major software engineering
journals and conferences in the decade 1993-2002. Of the 103 articles,
24 use a total of 40 theories in various ways to explain the cause-effect
relationship(s) under investigation. The majority of these use theory
in the experimental design to justify research questions and hypotheses,
some use theory to provide post hoc explanations of their results,
and a few test or modify theory. A third of the theories are proposed
by authors of the reviewed articles. The interdisciplinary nature
of the theories used is greater than that of research in software
engineering in general. We found that theory use and awareness of
theoretical issues are present, but that theory-driven research is,
as yet, not a major issue in empirical software engineering. Several
articles comment explicitly on the lack of relevant theory. We call
for an increased awareness of the potential benefits of involving
theory, when feasible. To support software engineering researchers
who wish to use theory, we show which of the reviewed articles on
which topics use which theories for what purposes, as well as details
of the theories' characteristics.},
 author = {J. E. Hannay, D. I. K. Sjoberg, T. Dyba},
 inserir = {true},
 quality = {2.5},
 references = {(Quasi-)experimental studies in industrial settings

“Editorial,” Empirical Software Eng

A Case for Scientific Realism

A Coding Scheme to Support Systematic Analysis of Software Comprehension

A Cognitive Footprint in Archival Data: Generalizing the Dilution
Effect from Laboratory to Field Settings

A cognitive information processing and information theory approach
to diagram clarity: a synthesis and experimental investigation

A Controlled Experiment in Maintenance Comparing Design Patterns to
Simpler Solutions

A Controlled Experiment To Assess The Effectiveness Of Inspection
Meetings

A Guide to Usage for Writers and Students in the Social Sciences

A Handbook of Software and Systems Engineering

A Human Factors Experimental Comparison of SQL and QBE

A Mathematical Theory of Communication

A Spreading Activation Theory of Semantic Processing

A Survey of Controlled Experiments in Software Engineering

A Survey of Studies Contrasting the Quality of Group Performance and
Individual Performance, 1920-1957

A translation approach to portable ontology specifications

Albert Einstein and Empirical Software Engineering

Alternatives to Validity: Some Thoughts Suggested by Campbell's Guidelines

An analysis of research in computing disciplines

An empirical analysis of debugging performance — differences between
iterative and recursive constructs

An Empirical Study of Representation Methods for Reusable Software
Components

An Empirical Study of Software Project Bidding

An Experiment to Assess the Cost-Benefits of Code Inspections in Large
Scale Software Development

An experimental comparison of reading techniques for defect detection
in UML design documents

An experimental investigation of the impact of individual, program,
and organizational characteristics on software maintenance effort

An Internally Replicated Quasi-Experimental Comparison of Checklist
and Perspective-Based Reading of Code Documents

An investigation of risk perception and risk propensity on the decision
to continue a software development project

Applying Software Metrics to Formal Specifications: A Cognitive Approach

Aspects of Theory of Syntax

Assessing the Changeability of two Object-Oriented Design Alternatives—a
Controlled Experiment

Bargaining Behavior: An International Study

Basics of Software Engineering Experimentation

Beyond Discrete Biases: Functional and Dysfunctional Aspects of Judgmental
Heuristics

Bringing Men Back In

Case Study Research: Design and Methods

Categories and Concepts

Cognitive fit in requirements modeling: a study of object and process
methodologies

Cognitive Fit: A Theory-Based Analysis of the Graphs versus Tables
Literature

Cognitive Fit: An Empirical Study of Information Acquisition

Cognitive Processes

Cognitive processes in program comprehension

Cognitive Structures in the Comprehension and Memory of Computer Programs:
An Investigation of Computer Program Debugging

Comments on What Theory Is Not

Comprehending Object and Process Models: An Empirical Study

Comprehension strategies in programming

Concepts and Thought

Conceptual entropy and its effect on class hierarchies

Confirmation, Disconfirmation, and Information In Hypothesis Testing

Consequences of Pragmatism

Conservatism in Human Information Processing

Constraints in Design Engineering: A Report of Research in Progress

Construct Validity in Organizational Behavior

Correspondence Versus Autonomy in the Language of Understanding Human
Action

Cost Models for Future Life Cycle Processes: COCOMO 2

Data processing project management

Delocalized Plans and Program Comprehension

Designing documentation to compensate for delocalized plans

Designing Evaluations of Social and Educational Programs

Developing Sociological Knowledge: Theory and Method

Early Lifecycle Work: Influence of Individual Characteristics,Methodological
Constraints, and Interface Constraints

Editor's Comments

Eliminating Exception Handling Errors with Dependability Cases: A
Comparative

Episodic and Semantic Memory

Essays in the Theory of Risk-Bearing

Evaluating Inheritance Depth on the Maintainability of Object-Oriented
Software

Evaluating the Usefulness and the Ease of Use of a Web-based Inspection
Data Collection Tool

Experimental and Quasi-Experimental Designs for Generalized Causal
Inference

Experimental Economics

Experimental evaluation of hypertext access structures

Experimental Methods

Experimentation in software engineering: an introduction

Explaining Organizational Behavior

External experiments: a workable paradigm for collaboration between
industry and academia

Formulation and preliminary test of an empirical theory of coordination
in software engineering

From Individuals to Group Members: A Dialectic for the Social Sciences

Further Experiences with Scenarios and Checklists

Group Process and Productivity

Groups Interacting with Technology: Ideas, Evidence, Issues and an
Agenda

Guest Editor's Special Section Introduction

Handbook of Cognitive Psychophysiology: Central and Autonomic Nervous
System Approaches

Hindsight Bias: A By-Product of Knowledge Updating?

How to Solve Problems

Human Factors Studies of Database Query Languages: A Survey and Assessment

Human Memory: A Proposed System and Its Control Process

Human Problem Solving

Imagery and Verbal Processes

Industrial Experience with an Integrated Code Comprehension Model

Information Processing and Memory

Investigating The Impact Of Reading Techniques On The Accuracy Of
Different Defect Content Estimation Techniques

Judgement under Uncertainty: Heuristics and Biases

Learning and Memory, Personality, Roles and Social Behavior

Major Developments in Social Psychology during the Five Past Decades

Management Control Systems

Management Teams

Mathematical Explanation and the Theory of Why-Questions

Mathematical Modeling in Social Sciences

Measuring Computer Program Quality and Comprehension

Mindless Statistics

Nothing Is Quite So Practical as a Good Theory

Novice/expert differences in programming skills

Object-Oriented Program Comprehension: Effect of Expertise, Task and
Phase

On Problem Solving

On the Rate of Gain of Information

Organizational information requirements, media richness and structural
design

Organizational Theories: Some Criteria for Evaluation

Perspective-based Usability Inspection: An Empirical Validationof
Efficacy

Philosophy of Science

Philosophy of Science

Preliminary guidelines for empirical research in software engineering

Principles of Categorization

Principles of Forecasting: A Handbook for Researchers and Practitioners

Procedures for Performing Systematic Reviews

Productive Thinking

Program understanding behaviour during enhancement of large-scale
software

Programmers' Performance on Structured versus Nonstructured Function
Definitions

Psychoanalytic Theories

QED—The Strange Theory of Light and Matter

Realism and Antirealism in Social Science

Realism, Instrumentalism, and Scientific Symbiosis

Reconceptualizing the Determinants of Risk Behavior

Representations of Risk Judgments

Research in Software Engineering: An Analysis of the Literature

Rethinking Perceptual Organization: The Role of Uniform Connectedness

Risk Taking: A Study in Cognition and Personality

Role Theory

Role Theory: Expectation, Identities, and Behaviors

Scientific Research I: The Search for a System

Search Processes in Recognition Memory

Should Computer Scientists Experiment More?

Sociology and Prediction

Software Project Control: An Experimental Investigation of Judgment
with Fallible Information

Stimulus Information as a Determinant of Reaction Time

Stimulus Structures and Mental Representations in Expert Comprehension
of Computer Programs

Strategies of Discourse Comprehension

Team Roles at Work

That's Interesting! Towards a Phenomenology of Sociology and a Sociology
of Phenomenology

The Conduct of Inquiry

The Design of Everyday Things

The Effectiveness of Software Development Technical Reviews: A Behaviorally
Motivated Program of Research

The efficacy of matching information systems development methodologies
with application characteristics—an empirical study

The Explanatory Power of Models

The General Method of Theory-Building Research in Applied Disciplines

The Growth of Theories

The Magical Number Seven, Plus or Minus Two: Some Limits on Our Capacity
for Processing Information

The Meaning of It All: Thoughts of a Citizen-Scientist

The Mind's Eye in Chess

The Nature of Space and Time

The Nature of Theory in Information Systems

The Research Center for Group Dynamics at Massachusetts Institute
of Technology

The Research Methods Knowledge Base

The sciences of the artificial

The Scientific Image

The Scope of General Theory

The Social Psychology of Telecommunications

The Structure of Memory and the Process of Solving Problems

The Structure of Science

The Structure of Science: Problems in the Logic of Scientific Explanation

The Structure of Theories

The Theoretical Status of Latent Variables

The Use of Procedural Roles in Code Inspections: An ExperimentalStudy

Theory

Theory Building

Theory Construction as Disciplined Imagination

Theory Development

Theory-Testing, Generalization, and the Problem of External Validity

Toward a theory of computer program bugs: an empirical test

Toward an assessment of software development risk

Toward Reform of Program Evaluation

Towards a Theory of the Comprehension of Computer Programs

Two Controlled Experiments Assessing the Usefulness of Design Pattern
Documentation in Program Maintenance

Understanding the sources of variation in software inspections

Untersuchungen Zurlehre von der Gestalt: II

User acceptance of computer technology: a comparison of two theoretical
models

User cognitive representations: the case for an object oriented model

Using a behavioral theory of program comprehension in software engineering

Using Belbin's leadership role to improve team effectiveness: an empirical
investigation

Using Different Communication Media in Requirements Negotiation

What Constitutes a Theoretical Contribution

What Theory Is Not

What Theory Is Not, Theorizing Is},
 timestamp = {2010.02.09},
 title = {A systematic review of theory use in software engineering experiments},
 year = {2007}
}

@article{I[14],
 abstract = {The review presented in this paper examines the evidence on the use
of expert judgement, formal models, and a combination of these two
approaches when estimating (forecasting) software development work
effort. Sixteen relevant studies were identified and reviewed. The
review found that the average accuracy of expert judgement-based
effort estimates was higher than the average accuracy of the models
in ten of the sixteen studies. Two indicators of higher accuracy
of judgement-based effort estimates were estimation models not calibrated
to the organization using the model, and important contextual information
possessed by the experts not included in the formal estimation models.
Four of the reviewed studies evaluated effort estimates based on
a combination of expert judgement and models. The mean estimation
accuracy of the combination-based methods was similar to the best
of that of the other estimation methods.},
 author = {M. Jorgensen},
 inserir = {true},
 quality = {2.5},
 references = {A Review of Studies on Expert Estimation of Software Development Effort

A Survey of Software Cost Es-timation in the Chinese Software Industry

A Systematic Review of Software Development Cost Estimation Studies

Clinical versus Actuarial Judgment

Estimating Software Costs

Estimation of Software Development Work Effort: Evidence on Expert
Judgment and Formal Models

Judgemental and Statistical Time Series Forecasting: A Review of the
Literature

My Life Is Failure

On Knowing When to Switch from Quantitative to Judgemental Forecasts

On the Problem of the Software Cost Function

Practical Guidelines for Expert-Judgment-Based Software Effort Estimation

Principles of Forecasting: A Handbook for Researchers and Practitioners

Software Engineering Economics

Software Project Survival Guide

Software Sizing, Estimation, and Risk Management},
 timestamp = {2010.02.09},
 title = {Estimation of software development work effort: evidence on expert
judgement and formal models},
 year = {2007}
}

@article{I[15],
 abstract = {This paper provides an extensive review of studies related to expert
estimation of software development effort. The main goal and contribution
of the review is to support the research on expert estimation, e.g.,
to ease other researcher's search for relevant expert estimation
studies. In addition, we provide software practitioners with useful
estimation guidelines, based on the research-based knowledge of expert
estimation processes. The review results suggest that expert estimation
is the most frequently applied estimation strategy for software projects,
that there is no substantial evidence in favour of use of estimation
models, and that there are situations where we can expect expert
estimates to be more accurate than formal estimation models. The
following 12 expert estimation "best practice" guidelines are evaluated
through the review: (1) evaluate estimation accuracy, but avoid high
evaluation pressure; (2) avoid conflicting estimation goals; (3)
ask the estimators to justify and criticize their estimates; (4)
avoid irrelevant and unreliable estimation information; (5) use documented
data from previous development tasks; (6) find estimation experts
with relevant domain background and good estimation records; (7)
Estimate top-down and bottom-up, independently of each other; (8)
use estimation checklists; (9) combine estimates from different experts
and estimation strategies; (10) assess the uncertainty of the estimate;
(11) provide feedback on estimation accuracy and development task
relations; and, (12) provide estimation training opportunities. We
found supporting evidence for all 12 estimation principles, and provide
suggestions on how to implement them in software organizations.},
 author = {M. Jorgensen},
 inserir = {true},
 quality = {4.0},
 references = {A case study of expert judgment: economists’ probabilities versus
base-rate model forecasts

A case study of maintenance estimation accuracy

A causal model for software cost estimating error

A comparative study of two software development cost modeling techniques
using multi-organizational and company-specific data

A conflict between the use of estimating and planning tools in the
management of information systems

A controlled experiment to assess the benefits of estimating with
analogy and regression models

A manager’s checklist for validating software cost and schedule estimates

A note on aggregating opinions

A progress report on the training of probability assessor

A project effort estimation study

A psychological approach to decision support systems

A replicated assessment and comparison of common software cost modeling
techniques

A subjective effort estimation experiment

A. Diamantopoulos and S.F. Witt, Forecasting practice: a review of
the empirical literature and an agenda for future research

Abandoning unrealistic optimism: performance estimates and the temporal
proximity of self-relevant feedback

An assessment and comparison of common software cost estimation modeling
techniques

An empirical evaluation of the MkII FPA estimation model

An empirical study of analogy-based software effort estimation

An experimental examination of subjective forecast combination

An experimental study of individual subjective effort estimations
and combinations of the estimates

Analysis of variance, design and regression

Application of cost-estimation techniques: industrial perspective

Are software cost-estimation models accurate?

Assessing the quality of expert judgment: Issues and analysis

Bayesian analysis of empirical software engineering cost models

Better sure than safe? Overconfidence in judgment based software development
effort prediction intervals

Beyond Six Billion: Forecasting the World’s Population

Bias and accuracy in estimates of task duration

Building tailor-made software cost model: Intermediate TUCOMO

Calibrating a software cost estimation model: why and how

Calibrating estimation tools for software development

Calibration of probabilities: the state of the art to 1980

Cognitive conflict and goal conflict effects on task performance

Combination of software development effort prediction intervals: Why,
when and how?

Combining forecasts

Combining forecasts: a review and annotated bibliography

Combining forecasts: what information do judges need to outperform
the simple average

Combining quantitative software development cost estimation precision
data with qualitative data from Project Experience Reports at Ericsson
Design Center in Norway

Combining the judgments of experts: How many and which ones?

Comparing the top-down and bottom-up approaches of function point
analysis: a case study

Competence in experts: the role of task characteristics

Confidence in judgment: persistence of the illusion of validity

Confidence judgments by actors and observers

Cost estimation of software intensive projects: a survey of current
practices

Cost estimation of software intensive projects: a survey of current
practices

Database models and managerial intuition: 50% model+50% manager

Decisions under time pressure: how time constraint affects risky decision
making

Decomposed versus holistic estimates of effort required for software
writing tasks

Decomposition for judgmental forecasting and estimation

Deploying realistic estimation (field situation analysis)

Determinants of overconfidence and miscalibration: the roles of random
error and ecological structure

Direct comparison of the efficacy of intuitive and analytical cognition
in expert judgment

Do those who know more also know more about how much they know

Does having to justify one’s judgments change nature of the judgment
process?

Does reliable information improve the accuracy of judgmental forecasts?

Double Dummy Spit and other estimating games

Economics of software project management in Tunisia: basic TUCOMO

Effects of decision importance on ability to generate warranted subjective
uncertainty

Eliciting and Analyzing Expert Judgment: A Practical Guide

Eliciting subjective probability distributions on continuous variables

Enhancing judgmental sales forecasting: the role of laboratory research

Estimation support by lexical analysis of requirements documents.
Journal of Systems and Software 51 2 (2000), pp. 87–98. Article |
PDF (220 K) | View Record in Scopus | Cited By in Scopus (3)

Estimeetings: development estimates and a front-end process for a
large project

Exaggerated self-assessments and the preference for controllable risks

Examining the feasibility of a case-based reasoning model for software
effort estimation

Expert and exceptional performance: Evidence of maximal adaptation
to task constraints

Expert estimation of Web-development effort: individual biases and
group processes

Expert judgement as an estimating method

Expert judgment: Is more information better

Expert opinions in forecasting: The role of the Delphi process

Expertise and decision under uncertainty: performance and process

Experts’ estimates of task durations in software development projects

Explanation, imagination, and confidence in judgment

Exploring the “Planning fallacy”: Why people underestimate their task
completion times

Fault trees: sensitivity of estimated failure probabilities to problem
representation

Feedback and task predictability as determinants of performance in
multiple cue probability learning tasks

Forecasting: Methods and Applications

Frequency, probability, and prediction: easy solutions to cognitive
illusions?

Function point analysis: evaluation of a software cost estimation
model

Goals and performance in computer programming

Hindsight <> foresight: the effect of outcome knowledge on judgement
under uncertainty

How bad is human judgment?

Human effects in early stage construction contract price forecasting

Human inference: Strategies and shortcomings of social judgment

Human judgement and social policy: irreducible uncertainty, inevitable
error, unavoidable injustice

Impact of effort estimates on software project work

Impact of experience on maintenance skills

Improving group judgment accuracy: information sharing and determining
the best member

Improving judgment in forecasting

Improving judgmental time series forecasting: a review of the guidance
provided by research

Improving predictive accuracy with a combination of human intuition
and mechanical decision aids

Improving the accuracy of group judgment: a process intervention combining
group facilitation, social judgment analysis, and information technology

In one word: not from experience

In the 25 years since The Mythical Man-Month what have we learned
about project management

Inducing compensatory information processing through decision aids
that facilitate effort reduction: an experimental assessment

Information system cost estimating: a management perspective

Information systems and organizational change

Information systems software cost estimating: a current assessment

Intuitive predictions: biases and corrective procedures

Issues in estimating real-time data communications software projects

Judgement or models: the importance of task differences

Judgemental and statistical time series forecasting: a review of the
literature

Judgment under Uncertainty: Heuristics and biases

Judgment under uncertainty: Heuristics and biases

Judgmental adjustment of statistical forecasts

Judgmental forecasting in times of change

Judgmental forecasting with time series and causal information

Learning from experience in performing analytical procedures

Making management decisions: the role of intuition and emotion

Measurement and effort prediction for Web applications

Nine management guidelines for better cost estimating

O’Connor, Effects of cognitive feedback on performance

On combining expert opinion

On knowing when to switch from quantitative to judgemental forecasts

On the evaluation of one-sided evidence

On the problem of the software cost function

On the psychology of prediction

On the use of software cost models

Outcome effects: the impact of decision process and outcome controllability

Outcome feedback effects on under- and overconfident judgments (general
knowledge tasks)

Overconfidence in judgmental forecasting

Overconfidence: it depends on how, what and whom you ask

Overestimating causality: Attributional effects of confirmatory processing

People focus on optimistic scenarios and disregard pessimistic scenarios
when predicting task completion times

Performance of a composite as a function of the number of judges

Performance of effort estimating techniques in current development
environments

Postmortem: Never leave a project without it

Precision and accuracy of judgmental estimation

Predicting maintenance effort with function points

Problem structuring aids for quantitative estimation

Project estimation using screenflow engineering

Project experience database: a report based on first practical experience

Proper and improper linear models

Reasons for confidence

Recent advantages in software estimation techniques

Research trends in judgment and their implications for the Schmidt–Hunter
global estimation procedure

Resource estimation in software engineering

Reuse of software development experience at Telenor Telecom Software

Selecting forecasting methods

Self-presentation and drive in social facilitation

Simple Heuristics that Make us Smart

Simple rules for combining forecasts: Some empirical results

Social enhancement and impairment of performance in the cockroach

Social facilitation

Software cost estimation

Software cost estimation: a review of models, process, and practice

Software cost estimation: Present and future

Software development cost estimation approaches––a survey

Software economics: status and prospects

Software Effort Estimation by Analogy and Regression Toward the Mean

Software effort estimation: an exploratory study of expert performance

Software Engineering Economics

Software engineering economics

Software management and cost estimating error

Software process improvement and human judgement heuristics

Software project control: an experimental investigation of judgment
with fallible information

Software Project Survival Guide

Standards and practices for forecasting

Statistical analysis of deviation of actual cost from estimated cost
using actual project data

Subjective probability

Successful experience of using function points to estimate project
costs early in the life-cycle

Swets, Enhanced interpretation of diagnostic images

Teamwork in planning innovative projects: improving group performance
by rational and interpersonal interventions in group process

The calibration of subjective probabilities: theories and models 1980–94

The contribution of the group process to successful project planning
in R & D settings

The cost of developing large-scale software

The dynamics of software project scheduling

The effect of motivation of judgment depends on the difficulty of
the judgment

The effects of feedback and training on the performance of probability
forecasters

The Experience Factory

The forecasting dictionary

The impact of customer expectation on software development effort
estimates

The impact of goals on software project management: an experimental
investigation

The importance of not learning from experience

The process-performance paradox in expert judgment: How can experts
know so much and predict so badly?

The quality of questionnaire based software maintenance studies

The role of motivated reasoning in optimistic time predictions

The use of the decomposition principle in making judgments

The work breakdown structure in software project management

Timid choices and bold forecasts: a cognitive perspective on risk
taking

Training to improve calibration and discrimination: the effects of
performance and environmental feedback

Uncertainty intervals versus interval uncertainty: an alternative
method for eliciting effort prediction intervals in software development
projects

Unskilled and unaware of it: how difficulties in recognizing one’s
own incompetence lead to inflated self-assessments

Using function points to find cost analogies

We knew it all along: hindsight bias in groups

When oracles fail––a comparison of four procedures for aggregating
subjective probability forecasts

When shall we use our heads instead of the formula?

Why is p=0.90 better than p=0.70? preference for definitive predictions
by lay consumers of probability judgments},
 timestamp = {2010.02.09},
 title = {A review of studies on expert estimation of software development
effort},
 year = {2004}
}

@article{I[16],
 abstract = {This paper aims to provide a basis for the improvement of software
estimation research through a systematic review of previous work.
The review identifies 304 software cost estimation papers in 76 journals
and classifies the papers according to research topic, estimation
approach, research approach, study context and data set. A Web-based
library of these cost estimation papers is provided to ease the identification
of relevant estimation research results. The review results combined
with other knowledge provide support for recommendations for future
software cost estimation research, including 1) increase the breadth
of the search for relevant studies, 2) search manually for relevant
papers within a carefully selected set of journals when completeness
is essential, 3) conduct more studies on estimation methods commonly
used by the software industry, and 4) increase the awareness of how
properties of the data sets impact the results when evaluating estimation
methods.},
 author = {M. Jorgensen, M. Shepperd},
 inserir = {true},
 quality = {3.0},
 references = {A Conflict between the Use of Estimating and Planning Tools in the
Management of Information Systems

A Review of Software Surveys on Software Effort Estimation

A Simulation Study of the Model Evaluation Criterion MMRE

An Investigation of Machine Learning Based Prediction Systems

Assessing Software Cost Estimation Models: Criteria for Accuracy,
Consistency and Regression

Combining Techniques to Optimize Effort Predictions in Software Project
Management

Experience with the Accuracy of Software Maintenance Task Effort Prediction
Models

F. J. Heemstra

Industrial Use of Formal Software Cost Estimation Models: Expert Estimation
in Disguise?

Recent Advances in Software Estimation Techniques

Resource Estimation in Software Engineering

S. Grimstad, M. Jorgensen, K. J. Molokken-Astvold

Software Development Cost Estimation Approaches—A Survey

Software Engineering Economics},
 timestamp = {2010.02.09},
 title = {A systematic review of software development cost estimation studies},
 year = {2007}
}

@article{I[18],
 abstract = {Mature knowledge allows engineering disciplines the achievement of
predictable results. Unfortunately, the type of knowledge used in
software engineering can be considered to be of a relatively low
maturity, and developers are guided by intuition, fashion or market-speak
rather than by facts or undisputed statements proper to an engineering
discipline. Testing techniques determine different criteria for selecting
the test cases that will be used as input to the system under examination,
which means that an effective and efficient selection of test cases
conditions the success of the tests. The knowledge for selecting
testing techniques should come from studies that empirically justify
the benefits and application conditions of the different techniques.
This paper analyzes the maturity level of the knowledge about testing
techniques by examining existing empirical studies about these techniques.
We have analyzed their results, and obtained a testing technique
knowledge classification based on their factuality and objectivity,
according to four parameters.},
 author = {N. Juristo, A. M. Moreno, S. Vegas},
 inserir = {true},
 quality = {2.5},
 references = {A Comparative Study of Coarse-and Fine-Grained Safe Regression Test
Selection

A controlled experiment in program testing and code walkthroughs/inspections

A Study of Effective Regression Testing in Practice

All-uses versus mutation: An experimental comparison of effectiveness

An empirical evaluation (and specification) of the all-du-paths testing
criterion

An Empirical Evaluation of Three Defect-Detection Techniques

An Empirical Evaluation of Weak Mutation

An empirical study of regression test application frequency

An empirical study of regression test selection techniques

An empirical study of the complexity of data flow testing

An Experimental Comparison of the Effectiveness of Branch Testing
and Data Flow Testing

An experimental comparison of the effectiveness of the all-uses and
all-edges adequacy criteria

An experimental determination of sufficient mutant operators

An experimental evaluation of selective mutation

Art of Software Testing

Comparing and combining software defect detection techniques: a replicated
empirical study

Comparing the Effectiveness of Software Testing Strategies

Comparing the effectiveness of software testing strategies. Department
of Computer Science

Comparison of all-uses and all-edges: design, data, and analysis

Empirical Evaluation of the Textual Differencing Regression Testing
Technique

Empirical Studies of a Safe Regression Test Selection Technique

Evaluating software engineering testing strategies

Experiments of the effectiveness of dataflow and controlflow-based
test adequacy criteria

Fault detection effectiveness of mutation and data-flow testing

Further empirical studies of test effectiveness

How strong is weak mutation?

Prioritizing test cases for regression testing

Software requirements: objects, functions, and states

Software Testing Techniques

Test Case Prioritization: An Empirical Study

The Cost of Data Flow Testing: An Empirical Study

Theoretical comparison of testing methods},
 timestamp = {2010.02.09},
 title = {Reviewing 25 years of testing technique experiments},
 year = {2004}
}

@article{I[19],
 abstract = {Gathering evidence in any discipline is a lengthy procedure, requiring
experimentation and empirical confirmation to transform information
from mere opinion to undisputed fact. Software engineering is a relatively
young field and experimental SE is even younger, so undisputed facts
are few and far between. Nevertheless, ESE's relevance is growing
because experimental results can help practitioners make better decisions.
We have aggregated results from unit-testing experiments with the
aim of identifying information with some experimental basis that
might help practitioners make decisions. Most of the experiments
focus on two important characteristics of testing techniques: effectiveness
and efficiency. Some other experiments study the quality of test-case
sets according to different criteria.},
 author = {N. Juristo, A. M. Moreno, S. Vegas, M. Solari},
 inserir = {true},
 quality = {1.5},
 references = {A Comparative Study of Coarse—and Fine-Grained Safe Regression Test
Selection

A Study of Effective Regression Testing in Practice

All-Uses versus Mutation Testing: An Experimental Comparison of Effectiveness

An Empirical Evaluation (and Specification) of the All-du-paths Testing
Criterion

An Empirical Evaluation of Defect Detection Techniques

An Empirical Evaluation of Test Case Filtering Techniques Based on
Exercising Complex Information Flows

An Empirical Evaluation of Three Defect-Detection Techniques

An Empirical Evaluation of Weak Mutation

An Empirical Study of Regression Test Application Frequency

An Empirical Study of Regression Test Selection Techniques

An Experimental Comparison of the Effectiveness of Branch Testing
and Data Flow Testing

An Experimental Determination of Sufficient Mutant Operators

Basics of Software Engineering Experimentation

Combining Empirical Results in Software Engineering

Comparing the Effectiveness of Software Testing Strategies

Comparison of Delivered Reliability of Branch, Data Flow and Operational
Testing: A Case Study

Empirical Evaluation of Orthogonality of Class Mutation Operators

Empirical Evaluation of the Textual Differencing Regression Testing
Technique

Empirical Studies of a Safe Regression Test Selection Technique

Evidence-Based Software Engineering for Practitioners

Experimental Validation of New Software Technology

Experiments on the Effectiveness of Dataflow- and Controlflow-Based
Test Adequacy Criteria

Fault Detection Effectiveness of Mutation and Data-flow Testing

Further Empirical Studies of Test Effectiveness

On Test Suite Composition and Cost-Effective Regression Testing

Prioritizing Test Cases for Regression Testing

Reviewing 25 Years of Testing Technique Experiments

Software Testing Techniques

Soup or Art? The Role of Evidential Force in Empirical Software Engineering

Test Case Prioritization: An Empirical Study

The Complexity of Data Flow Criteria for Test Data Selection

The Cost of Data Flow Testing: An Empirical Study},
 timestamp = {2010.02.09},
 title = {In search of what we experimentally know about unit testing},
 year = {2006}
}

@article{I[1],
 abstract = {Due to the importance of software architectural documents, its review
became a fundamental activity for the success of software projects
and for the software quality improvement. Software architecture evaluation
is a subject that has been intensively studied by diverse research
groups. However there is a lack of formal reviews aiming at identifying
the existence of software evaluation approaches. The bibliographical
reviews that have been accomplished can not be audited or repeated,
making them entirely dependent upon the researchers for the obtained
results, which could introduce bias on the research results. To prevent
these limitations, this paper describes a systematic review aiming
at the dentification of existing architectural evaluation approaches.
Based on the result of this review, we summarize the main characteristics,
advantages and limitations of the identified evaluation approaches
and propose the requirements for a checklist based software architectural
documents evaluation approach.},
 author = {C. Zannier, G. Melnik, F. Maurer},
 inserir = {true},
 quality = {2.5},
 references = {A Survey of Controlled Experiments in Software Engineering

Basics of Software Engineering Experimentation

Building Knowledge through Families of Experiments

Case Studies for Software Engineers

Case Study Research: Design and Methods

Empirical Studies of Object-Oriented Artifacts, Methods, and Processes:
State of the Art and Future Directions

Empirical studies of software engineering: a roadmap

Experimental evaluation in computer science: a quantitative study

Experimental validation of new software technology

Experimentation in software engineering

Has Twenty-five Years of Empirical Software Engineering Made a Difference?

Meta-analysis in Social Research

Panel: empirical validation: what, why, when, and how

Preliminary guidelines for empirical research in software engineering

Qualitative Research & Evaluation Methods

Research in software engineering: an Analysis of the Literature

Science and Substance: A Challenge to Software Engineers

Should Computer Scientists Experiment More?

Software metrics: a rigorous and practical approach

Soup or Art? The Role of Evidential Force in Empirical Software Engineering

Ten Rules of Reading Clinical Research Reports

The Experimental Paradigm in Software Engineering

The role of experimentation in software engineering: past, current,
and future

The type of evidence produced by empirical software engineers

Using Experiments to Build a Body of Knowledge

Writing good software engineering research papers: minitutorial},
 timestamp = {2010.02.09},
 title = {On the success of empirical studies in the international conference
on software engineering},
 year = {2006}
}

@article{I[20],
 abstract = {The objective of this paper is to determine under what circumstances
individual organisations would be able to rely on cross-company based
estimation models. We performed a systematic review of studies that
compared predictions from crosscompany models with predictions from
within-company models based on analysis of project data. Ten papers
compared cross-company and within-company estimation models, however,
only seven of the papers presented independent results. Of those
seven, three found that crosscompany models were as good as within-company
models, four found cross-company models were significantly worse
than within-company models. Experimental procedures used by the studies
d iffered making it impossible to undertake formal meta-analysis
of the results. The main trend distinguishing study results was that
studies with small single company data sets (i.e. <20 projects) that
used leaveone-out cross-validation all found that the within-company
model was significantly more accurate than

the cross-company model. The results of this review are inconclusive.
It is clear that some organisations would be ill-served by cross-company
models whereas others would benefit. Further studies are needed,
but they must be independent (i.e. based on different data bases
or at least different single comp any data sets). In addition, experimenters
need to standardise their experimental procedures to enable formal
meta-analysis.},
 author = {B. Kitchenham, E. Mendes, G. H. Travassos},
 inserir = {true},
 quality = {4.0},
 references = {A Comparative Study of Two Software Development Cost Modeling Techniques
using Multi-organizational and Company-specific Data

A Comparison of Cross-company and Single-company Effort Estimation
Models for Web Applications

A general empirical solution to the macro software sizing and estimating
problem

A replicated assessment of common software cost estimation techniques

A Replicated Comparison of Cross-company and Withincompany Effort
Estimation models using the ISBSG Database

A Simulation Study of the Model Evaluation Criteria MMRE

An assessment and comparison of common cost estimation models

An empirical validation of software cost estimation models

Controlling Software Projects: Management measurement and estimation

Evidence-based software engineering

Further Comparison of Cross-Company and Within Company Effort Estimation
Models for Web Applications

How valuable is company-specific data compared to multi-company data
for software cost estimation?

Investigating Early Web Size Measures for Web Cost Estimation

Performance Evaluation of General and Company Specific Models in Software
Development Effort Estimation

Procedures for Performing Systematic Reviews

Software cost models

Software Engineering Economics

Systematic reviews and meta-analyses: An illustrated step-by-step
guide

The MERMAID approach to software cost estimation

Using Genetic Programming to Improve Software Effort Estimation Based
on General Data Sets

Using public domain metrics to estimate software development effort},
 timestamp = {2010.02.09},
 title = {A Systematic Review of Cross- vs. Within-Company Cost Estimation
Studies},
 year = {2006}
}

@article{I[21],
 abstract = {The objective of this paper is to determine under what circumstances
individual organizations would be able to rely on cross-company-based
estimation models. We performed a systematic review of studies that
compared predictions from cross-company models with predictions from
within-company models based on analysis of project data. Ten papers
compared cross-company and within-company estimation models; however,
only seven presented independent results. Of those seven, three found
that cross-company models were not significantly different from within-company
models, and four found that cross-company models were significantly
worse than within-company models. Experimental procedures used by
the studies differed making it impossible to undertake formal meta-analysis
of the results. The main trend distinguishing study results was that
studies with small within-company data sets (i.e., $20 projects)
that used leave-one-out cross validation all found that the within-company
model was significantly different (better) from the cross-company
model. The results of this review are inconclusive. It is clear that
some organizations would be ill-served by cross-company models whereas
others would benefit. Further studies are needed, but they must be
independent (i.e., based on different data bases or at least different
single company data sets) and should address specific hypotheses
concerning the conditions that would favor cross-company or within-company
models. In addition, experimenters need to standardize their experimental
procedures to enable formal meta-analysis, and recommendations are
made in Section 3.},
 author = {B. Kitchenham, E. Mendes, G. H. Travassos},
 inserir = {true},
 quality = {4.0},
 references = {A Comparative Study of Two Software Development Cost Modeling Techniques
Using Multi-Organizational and Company-Specific Data

A Comparison of Cross-Company and Single-Company Effort Estimation
Models for Web Applications

A General Empirical Solution to the Macro Software Sizing and Estimating
Problem

A Replicated Assessment of Common Software Cost Estimation Techniques

A Replicated Comparison of Cross-Company and Within-Company Effort
Estimation Models Using the ISBSG Database

A Simulation Study of the Model Evaluation Criterion MMRE

A Systematic Review of Cross- versus Within-Company Cost Estimation
Studies

An Assessment and Comparison of Common Cost Estimation Models

An Empirical Validation of Software Cost Estimation Models

Controlling Software Projects: Management Measurement and Estimation

Data Analysis and Regression

Early Lifecycle Specification Based on Sizing with Function Points

Further Comparison of Cross-Company and Within Company Effort Estimation
Models for Web Applications

How Valuable Is Company-Specific Data Compared to Multi-Company Data
for Software Cost Estimation?

Making Inferences with Small Numbers of Training Sets

Performance Evaluation of General and Company Specific Models in Software
Development Effort Estimation

Practical Meta-Analysis

Procedures for Performing Systematic Reviews

Software Cost Models

Software Engineering Economics

Systematic Reviews and Meta-Analyses: An Illustrated Step-by-Step
Guide

Systematic Reviews in the Social Sciences: A Practical Guide

The Consistency of Empirical Comparisons of Regression and Analogy-Based
Software Project Cost Prediction

The MERMAID Approach to Software Cost Estimation

Using Genetic Programming to Improve Software Effort Estimation Based
on General Data Sets

Using Public Domain Metrics to Estimate Software Development Effort},
 timestamp = {2010.02.09},
 title = {Cross versus Within-Company Cost Estimation Studies: A Systematic
Review},
 year = {2007}
}

@article{I[27],
 abstract = {The objective is to determine the consistency within and between results
in empirical studies of software engineering cost estimation. We
focus on regression and analogy techniques as these are commonly
used. We conducted an exhaustive literature search using predefined
inclusion and exclusion criteria and identified 67 journal papers
and 104 conference papers. From this sample we identified 11 journal
papers and 9 conference papers that used both methods. Our analysis
found that about 25% of studies were internally inconclusive. We
also found that there is approximately equal evidence in favour of,
and against analogy-based methods. We confirm the lack of consistency
in the findings and argue that this inconsistent pattern from 20
different studies comparing regression and analogy is somewhat disturbing.
It suggests that we need to ask more detailed questions than just:
What is the best prediction system?},
 author = {C. Mair, M. Shepperd},
 inserir = {true},
 quality = {2.5},
 references = {A Comparative Study of Cost Estimation Models for Web Hypermedia Applications

A comparative study of two software development cost modeling techniques
using multi-organizational and company-specific data

A Comparison of Case-Based Reasoning Approaches to Web Hypermedia
Project Cost Estimation

A comparison of techniques for developing predictive models of software
metrics

A controlled experiment to assess the benefits of estimating with
analogy and regression models

A replicated assessment and comparison of common software cost modeling
techniques

A simulation tool for efficient analogy based cost estimation

An Analysis of Data Sets Used to Train and Validate Cost Prediction
Systems

An assessment and comparison of common software cost estimation modeling
techniques

An empirical study of analogy-based software effort estimation

An investigation of analysis techniques for software data sets

An investigation of machine learning based prediction systems

Analyse statistique de la productivitie des projets informatique a
partie de la technique des point des fonction

Applying meta-analytical procedures to software engineering experiments

Building knowledge through families of experiments

Can genetic programming improve software effort estimation? A comparative
evaluation

Can results from software engineering experiments be safely combined?

Combining techniques to optimize effort predictions in software project
management

Comparing software prediction techniques using simulation

Early Web Size Measures and Effort Prediction for Web Costimation

Early Web size measures and effort prediction for Web costimation

Estimating software development effort with case-based reasoning

Estimating software project effort using analogies

Evaluating software development effort model-building techniques for
application in a real-time telecommunications environment

Examining the feasibility of a casebased reasoning model for software
effort estimation

Further Comparison of Cross-Company and Within-Company Effort Estimation
Models for Web Applications

Further Investigation into the Use of CBR and Stepwise Regression
to Predict Development Effort for Web Hypermedia Applications

How valuable is company-specific data compared to multicompany data
for software cost estimation?

Machine learning, neural and statistical classification

N. E. Fenton, S. L. Pfleeger

Predicting Maintenance Effort with Function Points

Primary, Secondary and Metaanalysis of Research

Principles of forecasting: A handbook for researchers and practitioners

Research synthesis in software engineering: a case for meta-analysis

Software Effort Models for Early Estimation of Process Control Applications

Software Metrics – A Rigorous and Practical Approach

Software-effort estimation with a case-based reasoner

The "file-drawer" problem and tolerance for null results

Using an engineering approach to understanding and predicting Web
authoring and design

Using public domain metrics to estimate software development effort

Using simulation to evaluate prediction techniques},
 timestamp = {2010.02.09},
 title = {The consistency of empirical comparisons of regression and analogy-based
software project cost prediction},
 year = {2005}
}

@article{I[28],
 abstract = {This paper uses a systematic literature review as means of investigating
the rigor of claims arising from Web engineering research. Rigor
is measured using criteria combined from software engineering research.
We reviewed 173 papers and results have shown that only 5% would
be considered rigorous methodologically. In addition to presenting
our results, we also provide suggestions for improvement of Web engineering
research based on lessons learnt by the software engineering community.},
 author = {E. Mendes},
 inserir = {true},
 quality = {2.0},
 references = {A controlled experiment in maintenance: comparing design patterns
to simpler solutions

A proposed curriculum for a Masters in Web engineering

A Web Metrics Survey Using WQM

Achieving industrial relevance with academic excellence: lessons from
the Oregon master of software engineering

Albert Einstein and Empirical Software Engineering

An empirical study of software reuse vs. defect-density and stability

An investigation of software engineering curricula

An operational process for goal-driven definition of measures

Building knowledge through families of experiments

Can results from software engineering experiments be safely combined?

Case studies for method and tool evaluation

Combining empirical results in software engineering

Comparing Detection Methods for Software Requirements Inspections:
A Replicated Experiment

Conducting realistic experiments in software engineering

Empirical Methodologies for Web Engineering

Empirical studies of software engineering: a roadmap

Evidence-based software engineering

Fraunhofer: the German model for applied research and technology transfer

How much information is needed for usage-based reading?

How we know: an exploration of the scientific process

Issues in using students in empirical studies in software engineering
education

Making resource decisions for software projects

Methodological contributions to professional education and training

Modeling software measurement data

Preliminary guidelines for empirical research in software engineering

Procedures for Performing Systematic Reviews

Prospects for an Engineering Discipline of Software

Replicating software engineering experiments: addressing the tacit
knowledge problem

Research in computer science: an empirical study

Research in software engineering: an analysis of the literature

Research Synthesis in Software Engineering: A Case for Meta-Analysis

Science and Substance: A Challenge to Software Engineers

Software Metrics: A Rigorous and Practical Approach

Status report on software measurement

Systematic reviews and meta-analyses: An illustrated step-by-step
guide

The road to maturity: navigating between craft and science

The role of experimentation in software engineering: past, current,
and future

Towards the Design of a Metrics Cataloguing System by Exploiting Conceptual
and Semantic Web Approaches

Web Engineering, Managing Diversity and Complexity of Web Application
Development

WebComposition: an object-oriented support system for the Web engineering
lifecycle},
 timestamp = {2010.02.09},
 title = {Systematic review of Web engineering research},
 year = {2007}
}

@article{I[31],
 abstract = {We provide an overview of the estimation methods that software companies
apply to estimate their projects, why those methods are chosen, and
how accurate they are. In order to improve estimation accuracy, such
knowledge is essential. We conducted an in-depth survey, where information
was collected through structured interviews with senior managers
from 18 different companies and project managers of 52 different
projects. We analyzed information about estimation approach, effort
estimation accuracy and bias, schedule estimation accuracy and bias,
delivered functionality and other estimation related information.
Our results suggest, for example, that average effort overruns are
41%, that the estimation performance has not changed much the last
10-20 years, that expert estimation is the dominating estimation
method, that estimation accuracy is not much impacted by use of formal
estimation models, and that software managers tend to believe that
the estimation accuracy of their company is better than it actually
is.},
 author = {K. Moloekken-OEstvold, M. Joergensen, S. S. Tanilkan, H. Gallis,
A. C. Lien, S. W. Hove},
 inserir = {true},
 quality = {3.0},
 references = {A Conflict Between the Use of Estimating and Planning Tools in the
Management of Information Systems

A Review of Studies on Expert Estimation of Software Development Effort

A Review of Surveys on Software Effort Estimation

An effort prediction interval approach based on the empirical distribution
of previous estimation accuracy

An empirical study of maintenance and development estimation accuracy

An empirical validation of the relationship between the magnitude
of relative error and project size

An Experimental Study of Individual Subjective Effort Estimations
and Combinations of the Estimates

Causes of Inaccurate Software Development Cost Estimates

Comparing Effort Estimates Based on Use Case Points with Expert Estimates

Controlling Software Development Costs: A Field Study

Controlling Software Project Risks - an Empirical Study of Methods
used by Experienced Project Managers

Could Large UK Corporations and Computing Companies Use Software Cost
Estimating Tools? - A Survey

Estimating Software Development Effort Based on Use Cases - Experiences
from Industry

Estimation of Information Systems Development Efforts: A Pilot Study

How Large Are Software Cost Overruns?

How much does a vacation cost? or What is a software cost estimate?

Improving Estimation Practices by Applying Use Case Models

Information System Cost Estimating: A Management Perspective

Information Systems Development and the Changing Role of MIS in the
Organisation

Information Systems Project Management: an Integrated Resource Planning
Perspective Model

Information systems software cost estimating: a current assessment

Method to estimate parameter values in software prediction models

Methods in behavioral research

Nine management guidelines for better cost estimating

Project estimation using screenflow engineering

Resource modeling in software engineering

Software cost estimation

Software Engineering Economics

Software Engineering Metrics and Models

Software Metrics in New Zealand: Recent Trends

Software Project Estimation: a Survey of Practices in New Zealand

Statistical power analysis for the behavioral sciences

The impact of customer expectation on software development effort
estimates

The State of IT Project Management in the UK 2002-2003

Uncertainty, experience and the 'winners curse' in OCS lease bidding

Wetherbe, Empirical Investigation of Systems Development Practices
and Results},
 timestamp = {2010.02.09},
 title = {A survey on software estimation in the Norwegian industry},
 year = {2004}
}

@article{I[32],
 abstract = {Software inspection is a method to detect faults in the early phases
of the software life cycle. In order to estimate the number of faults
not found, capture–recapture was introduced for software inspections
in 1992 to estimate remaining faults after an inspection. Since then,
several papers have been written in the area, concerning the basic
theory, evaluation of models and application of the method. This
paper summarizes the work made in capture–recapture for software
inspections during these years. Furthermore, and more importantly,
the contribution of the papers are classified as theory, evaluation
or application, in order to analyse the performed research as well
as to highlight the areas of research that need further work. It
is concluded that (1) most of the basic theory is investigated within
biostatistics, (2) most software engineering research is performed
on evaluation, a majority ending up in recommendation of the Mh–JK
model, and (3) there is a need for application experiences. In order
to support the application, an inspection process is presented with
decision points based on capture–recapture estimates.},
 author = {H. Petersson, T. Thelin, P. Runeson, C. Wohlin},
 inserir = {true},
 quality = {2.5},
 references = {A comparison and integration of capture–recapture models and the detection
profile method

A comprehensive evaluation of capture–recapture models for estimating
software defect content

A two-person inspection method to improve programming productivity

Active design reviews: principles and practices

Advances in software inspections

An empirical study of experience-based software defect content estimation
methods

An experimental evaluation of an experience-based capture–recapture
method in software code inspections

An experimental evaluation of capture–recapture in software inspections

An improved inspection technique

Assessing software design using capture–recapture methods

ASSISTing management decisions in the software inspection process

Capture–Recapture and Removal Methods for Sampling Closed Populations

Capture–recapture estimations for perspective-based reading––a simulated
experiment

Capture–recapture models

Capture–Recapture Models to Estimate Software Fault Content

Capture–recapture-models, methods, and the reality

Comparing detection methods for software requirements inspection:
a replicated experiment

Confidence intervals for capture–recapture estimations in software
inspections

Defect content estimation for two reviewers

Defect content estimation from review data

Design and code inspections to reduce errors in program development

Detecting defects in object-oriented designs: using reading techniques
to increase software quality

Empirical Evaluations of Usage-Based Reading and Fault Content Estimation
for Software Inspections

Empirical interval estimates for the defect content after an inspection

Estimating population size for capture–recapture data when capture
probabilities vary by time and individual animal

Estimating population size for sparse data in capture–recapture experiments

Estimating software fault content before coding

Estimating the number of components with defects post-release that
showed no defects in testing

Estimating the number of remaining defects after inspection

Estimating the population size for capture–recapture data with unequal
catchability

Estimation of the size of a closed population when capture–recapture
probabilities vary among animals

Evaluating capture–recapture models with two inspectors

Evaluating defect content estimation rules in software inspections

Evaluating the accuracy of defect estimation models based on inspection
data from two inspection cycles

Evaluation of using capture–recapture methods in software review data

Fault content estimations using extended curve fitting models and
model selection

How many errors remain in a software design document after inspection?

Investigating the impact of reading techniques on the accuracy of
different defect content estimation techniques

Lab package for the empirical investigation of perspective-based reading

Lessons from three years of inspection data

Modeling capture, recapture, and removal statistics for estimation
of demographic parameters for fish and wildlife populations: past,
present, and future

N-fold inspections: a requirements analysis technique

On the independence of software inspectors

On the statistical analysis of the number of errors remaining in a
software design document after inspection

On the Statistical Validation of Computer Programs

Quantitative evaluation of capture–recapture models to control software
inspections

Reliability-estimations & stopping-rules for software testing, based
on repeated appearance of bugs

Robust estimations of fault content with capture–recapture and detection
profile estimators

Sample-driven inspections

Software Inspection Process

Software Inspections

Software Reliability Engineering: More Reliable Software, Faster Development
and Testing

Software technology maturation

Statistical decision support method for in-process inspections

Statistical inference from capture data on closed animal populations

Statistical Methods for Software Quality––Using Metrics for Process
Improvement

Supporting Software Inspections Through Fault Content Estimation and
Effectiveness Analysis

Sur les Naissances, les Mariages et les Morts Histoire de L'Academic
Royale des Sciences

The application of subjective estimates of effectiveness to controlling
software inspections

The empirical investigation of perspective-based reading

Usage-based reading––an experiment to guide reviewers with use cases

Using inspection data for defect estimation},
 timestamp = {2010.02.09},
 title = {Capture–recapture in software inspections after 10 years research
– theory, evaluation and application},
 year = {2004}
}

@article{I[34],
 abstract = {In this paper, we examine the state of computer science (CS) research
from the point of view of the following research questions: What
topics do CS researchers address? What research approaches do CS
researchers use? What research methods do CS researchers use? On
what reference disciplines does CS research depend? At what levels
of analysis do CS researchers conduct research? To answer these questions,
we examined 628 papers published between 1995 and 1999 in 13 leading
research journals in the CS field. Our results suggest that while
CS research examines a variety of technical topics it is relatively
focused in terms of the level at which research is conducted as well
as the research techniques used. Further, CS research seldom relies
on work outside the discipline for its theoretical foundations. We
present our findings as an evaluation of the state of current research
and as groundwork for future CS research efforts.},
 author = {V. Ramesh, R. L. Glass, I. Vessey},
 inserir = {true},
 quality = {1.5},
 references = {A comparative analysis of the topic areas of Computer Science

A Historiographical Examination of Information Systems

A Meta-Analysis of Multidisciplinary Research

A review of MIS research and disciplinary development: implications
for deans/administrators

A structure-based critique of contemporary computing research

An information systems keyword classification scheme

Computational science and the future of computing research

Computer Science research in India

Computer Science research in Mexico

Computing research programs in the US

Cross-fertilizations of knowledge: the case of MIS and its reference
disciplines

CSE: content and product

Experimental evaluation in computer science: a quantitative study

Experimental validation in software engineering

Exploring the research in information technology implementation

Exploring the Software Engineering component in MIS research

Federated database systems for managing distributed, heterogeneous,
and autonomous databases

Information systems research thematics: submissions to a new journal
1987–1992

Research in Computing Disciplines: A Comprehensive Classification
Scheme

Research in software engineering: an analysis of the literature

Semantic database modeling: survey, applications and research issues

Strategic directions in computing research

Studying information technology in organizations: research approaches
and assumptions

The evolution of empirical research in IS: a study in IS maturity

The role of experiments in Computer Science},
 timestamp = {2010.02.09},
 title = {Research in computer science: an empirical study},
 year = {2003}
}

@article{I[35],
 abstract = {A survey of defect detection studies comparing inspection and testing
techniques yields practical recommendations: use inspections for
requirements and design defects, and use testing for code. Evidence-based
software engineering can help software practitioners decide which
methods to use and for what purpose. EBSE involves defining relevant
questions, surveying and appraising avail able empirical evidence,
and integrating and evaluating new practices in the target environment.
This article helps define questions regarding defect detection techniques
and presents a survey of empirical studies on testing and inspection
techniques. We then interpret the findings in terms of practical
use. The term defect always relates to one or more underlying faults
in an artifact such as code. In the context of this article, defects
map to single faults.},
 author = {P. Runeson, C. Andersson, T. Thelin, A. Andrews, T. Berling},
 inserir = {true},
 quality = {2.0},
 references = {A Controlled Experiment in Program Testing and Code Walkthroughs/Inspections

An Empirical Evaluation of Defect Detection Techniques

An Empirical Evaluation of Six Methods to Detect Faults in Software

An Empirical Evaluation of Three Defect-Detection Techniques

An Empirical Study of Inspection and Testing Data at Ericsson

An Experimental Analysis of Program Verification Methods

An Experimental Evaluation of Inspection and Testing for Detection
of Design Faults

An Industrial Case Study of the Verification and Validation Activities

Applying Meta-Analytical Procedures to Software Engineering Experiments

C. Wohlin, P. Runeson, M. Höst, M. C. Ohlsson, B. Regnell, A. Wesslén

Comparing the Effectiveness of Software Testing Strategies

Detection or Isolation of Defects? An Experimental Comparison of Unit
Testing and Code Inspection

Evidence-Based Software Engineering for Practitioners

Experimental Context Classification: Incentives and Experience of
Subjects

Functional Testing, Structural Testing, and Code Reading: What Fault
Type Do They Each Detect?

Persuading Developers to "Buy into" Software Process Improvement:
Local Opinion and Empirical Evidence

Prioritized Use Cases as a Vehicle for Software Inspections

Reviewing 25 Years of Testing Technique Experiments

State-of-the-Art: Software Inspections after 25 Years

Studying the Effects of Code Inspection and Structural Testing on
Software Quality

Test Driven Development: By Example

Using Students as Subjects—A Comparative Study of Students and Professionals
in Lead-Time Impact Assessment},
 timestamp = {2010.02.09},
 title = {What do we know about defect detection methods?},
 year = {2006}
}

@article{I[36],
 abstract = {The classical method for identifying cause-effect relationships is
to conduct controlled experiments. This paper reports upon the present
state of how controlled experiments in software engineering are conducted
and the extent to which relevant information is reported. Among the
5,453 scientific articles published in 12 leading software engineering
journals and conferences in the decade from 1993 to 2002, 103 articles
(1.9 percent) reported controlled experiments in which individuals
or teams performed one or more software engineering tasks. This survey
quantitatively characterizes the topics of the experiments and their
subjects (number of subjects, students versus professionals, recruitment,
and rewards for participation), tasks (type of task, duration, and
type and size of application) and environments (location, development
tools). Furthermore, the survey reports on how internal and external
validity is addressed and the extent to which experiments are replicated.
The gathered data reflects the relevance of software engineering
experiments to industrial practice and the scientific maturity of
software engineering research.},
 author = {D. I. K. Sjoeberg, J. E. Hannay, O. Hansen, V. B. Kampenes, A. Karahasanovic,
N. -K. Liborg, A. C. Rekdal},
 inserir = {true},
 quality = {2.0},
 references = {A Handbook of Software and Systems Engineering: Empirical Observations

A Preliminary Software Engineering Theory as Investigated by Published
Experiments

A Review of Experimental Investigations into Object-Oriented Technology

A Review of Studies on Expert Estimation of Software Development Effort

An Analysis of Research in Computing Disciplines

An Assessment of Systems and Software Engineering Scholars and Institutions
(1998-2002)

Better Sure than Safe? Over-Confidence in Judgement Based Software
Development Effort Prediction Intervals

Building Knowledge through Families of Experiments

By the Way, Did Anyone Study Real Programmers?

Case Study Research: Design and Methods

Challenges and Recommendations when Increasing the Realism of Controlled
Software Engineering Experiments

Conducting Realistic Experiments in Software Engineering

Confounding and Collapsibility in Causal Inference

Editor"s Comments

Editorial: Research by Convenienc

Evaluating the Effect of a Delegated versus Centralized Control Style
on the Maintainability of Object-Oriented Software

Experimental and Quasi-Experimental Designs for Generalized Causal
Inference

Experimental and Quasi-Experimental Designs for Research on Teaching

Experimental Context Classification: Incentives and Experience of
Subjects

Experimental Evaluation in Computer Science: A Quantitative Study

Experimental Methodology

Experimental Models for Validating Technology

Experimental Validation in Software Engineering

Experimentation in Software Eng.: An Introduction

Experimentation in Software Engineering

Generalization and Theory Building in Software Engineering Research

Hints for Reviewing Empirical Work in Software Engineering

How Effective Are Software Engineering Methods?

Human Errors in Programming

Measurement and Experimentation in Software Engineering

Method in Experimental Psychology

Preliminary Guidelines for Empirical Research in Software Engineering

Procedures for Performing Systematic Reviews

Quasi-Experimentation: Design & Analysis Issues for Field Settings

Repeatable Software Engineering Experiments for Comparing Defect-Detection
Techniques

Research in Software Engineering: An Analysis of the Literature

Research Synthesis in Software Engineering: A Case for Meta- Analysis

Response to `Comments on Formal Methods Application: An Empirical
Tale of Software Development

Reviewing 25 Years of Testing Technique Experiments

Should Computer Scientists Experiment More? 16 Excuses to Avoid Experimentation

SWEBOK—Guide to the Software Engineering Body of Knowledge

The Design of Replicated Studies

The Experimental Paradigm in Software Engineering

The Research Methods Knowledge Base

The Research Sample, Part I: Sampling

The Role of Experimentation in Software Engineering: Past, Current,
and Future

Theory-Testing, Generalization, and the Problem of External Validity

Using Students as Experimental Subjects—An Analysis of Graduate and
Freshmen PSP Student Data

Writing Good Software Engineering Research Papers: Minitutorial},
 timestamp = {2010.02.09},
 title = {A survey of controlled experiments in software engineering},
 year = {2005}
}

@article{I[38],
 abstract = {Although developing with commercial-off-the-shelf components is gaining
more attention from both research and industrial communities, most
literature on the topic doesn't clearly identify context variables
such as the type of products, projects, and systems. In particular,
the literature often lacks a definition of "COTS product," or, when
a definition is present, it invariably disagrees with other studies.
A shared definition would improve discourse and enable researchers
to meta-analyze published empirical data. After a speculative effort
to define and classify COTS products, we decided to obtain this much-needed
understanding from the bottom up. We asked people involved in industrial
projects to name the key features in COTS-based development and to
tell us what they think constitutes a COTS product. We present the
interview results in the form of six theses, which contradict widely
accepted (or simply undisputed) ideas. We also present a definition
of "COTS product" that captures the key features.},
 author = {M. Torchiano, M. Morisio},
 inserir = {true},
 quality = {1.0},
 references = {A Formal Process for Evaluating COTS Software Products

Component-Based Perspective on Software Mismatch Detection

COTS Integration: Plug and Pray?

COTS-Based Systems Top 10 List

Definition and Classification of COTS: A Proposal

Developing New Processes for COTS-Based Systems

Investigating and Improving a COTS-Based Software Development Process

Open Source Security: Opportunity or Oxymoron?

Requirements That Handle IKIWISI, COTS, and Rapid Change

Software Architecture Classification for Estimating the Cost of COTS
Integration},
 timestamp = {2010.02.09},
 title = {Overlooked aspects of COTS-based development},
 year = {2004}
}

@article{I[40],
 abstract = {Critiques of the quantity and quality of empirical evaluations in
software engineering have existed for quite some time. However such
critiques are typically not empirically evaluated. This paper fills
this gap by empirically analyzing papers published by ICSE, the prime
research conference on Software Engineering. We present quantitative
and qualitative results of a quasi-random experiment of empirical
evaluations over the lifetime of the conference. Our quantitative
results show the quantity of empirical evaluation has increased over
29 ICSE proceedings but we still have room to improve the soundness
of empirical evaluations in ICSE proceedings. Our qualitative results
point to specific areas of improvement in empirical evaluations.},
 author = {C. Zannier, G. Melnik, F. Maurer},
 inserir = {true},
 quality = {3.5},
 references = {A Survey of Controlled Experiments in Software Engineering

Basics of Software Engineering Experimentation

Building Knowledge through Families of Experiments

Case Studies for Software Engineers

Case Study Research: Design and Methods

Empirical Studies of Object-Oriented Artifacts, Methods,and Processes:
State of the Art and Future Directions

Empirical studies of software engineering: a roadmap

Experimental evaluation in computer science: a quantitative study

Experimental validation of new software technology

Experimentation in software engineering

Has Twenty-five Years of Empirical Software Engineering Made a Difference?

Meta-analysis in Social Research

Panel: empirical validation: what, why, when, and how

Preliminary guidelines for empirical research in software engineering

Qualitative Research & Evaluation Methods

Research in software engineering: an Analysis of the Literature

Science and Substance: A Challenge to Software Engineers

Should Computer Scientists Experiment More?

Software metrics: a rigorous and practical approach

Soup or Art? The Role of Evidential Force in Empirical Software Engineering

Ten Rules of Reading Clinical Research Reports

The Experimental Paradigm in Software Engineering

The role of experimentation in software engineering: past, current,
and future

The type of evidence produced by empirical software engineers

Using Experiments to Build a Body of Knowledge

Writing good software engineering research papers: minitutorial},
 timestamp = {2010.02.09},
 title = {On the success of empirical studies in the international conference
on software engineering},
 year = {2006}
}

@article{I[4],
 abstract = {Statistical power is an inherent part of empirical studies that employ
significance testing and is essential for the planning of studies,
for the interpretation of study results, and for the validity of
study conclusions. This paper reports a quantitative assessment of
the statistical power of empirical software engineering research
based on the 103 papers on controlled experiments (of a total of
5,453 papers) published in nine major software engineering journals
and three conference proceedings in the decade 1993–2002. The results
show that the statistical power of software engineering experiments
falls substantially below accepted norms as well as the levels found
in the related discipline of information systems research. Given
this study's findings, additional attention must be directed to the
adequacy of sample sizes and research designs to ensure acceptable
levels of statistical power. Furthermore, the current reporting of
significance tests should be enhanced by also reporting effect sizes
and confidence intervals.},
 author = {T. Dyba, V. B. Kampenes, D. I. K. Sjoberg},
 inserir = {true},
 quality = {2.5},
 references = {A Power Primer

A Power-Analytic Examination Of Contemporary Communication Research

A Statistical Power Analysis Of Applied Psychology Research

A Survey Of Controlled Experiments In Software Engineering

An Analysis Of Statistical Power In Behavioral Accounting Research

An Instrument For Measuring The Key Factors Of Success

Applying Meta-Analytic Procedures To Software Engineering Experiments

Case Study Research: Design And Methods

Combining Empirical Results In Software Engineering

Design Sensitivity: Statistical Power For Experimental Research

Do Studies Of Statistical Power Have An Effect On The Power Of Studies?

Experimental And Quasi-Experimental Designs For Generalized Causal
Inference

Experimental Validation In Software Engineering

Explaining Psychological Statistics

How Many Subjects? Statistical Power Analysis In Research

Increasing Statistical Power Without Increasing Sample Size

On The Power Of Statistical Tests

On The Problem Of The Most Efficient Tests Of Statistical Hypotheses

On The Use And Interpretation Of Certain Test Criteria For Purposes
Of Statistical Inference

Organizational Configurations And Performance: The Role Of Statistical
Power In Extant Research

Preliminary Guidelines For Empirical Research In Software Engineering

Procedures For Performing Systematic Reviews

Psychometric Theory

Quasi-Experimentation: Design & Analysis Issues For Field Settings

Research In Software Engineering: An Analysis Of The Literature, Information
And Software Technology

Statistical Power Analysis For The Behavioral Sciences

Statistical Power Analysis For The Behavioral Sciences

Statistical Power And Effect Size In Marketing Research

Statistical Power And Its Subcomponents – Missing And Misunderstood
Concepts In Empirical Software Engineering Research

Statistical Power And The Testing Of Null Hypotheses: A Review Of
Contemporary Management Research And Recommendations For Future Studies

Statistical Power In Contemporary Management Research

Statistical Power In Information Systems Research: Application And
Impact On The Discipline

Statistical Significance Testing – A Panacea For Software Technology
Experiments?

Statistics

Summated Rating Scale Construction: An Introduction

The ‘Power’ Of International Business Research

The Account Taken Of Statistical Power

The Design Of Replicated Studies

The Perceptions And Usage Of Statistical Power In Applied Psychology
And Management Research

The Persistence Of Underpowered Studies In Psychological Research:
Causes, Consequences, And Remedies

The Power Of Replications And The Replications Of Power

The Problem Of Statistical Power In Mis Research

The Statistical Power Of Abnormal-Social Psychological Research: A
Review

The Task Force On Statistical Inference},
 timestamp = {2010.02.09},
 title = {A systematic review of statistical power in software engineering
experiments},
 year = {2006}
}

@article{I[7],
 abstract = {Many software development professionals and managers of software development
organizations re not fully convinced in the profitability of investments
for the advancement of SQA systems. The results included in each
of the articles we found, cannot lead to general conclusions on the
impact of investments in upgrading an SQA system. Our meta analysis
was based on CMM level transition (CMMLT) analysis of available publications
and was for the seven most common performance metric. The CMMLT analysis
is applicable for combined analysis of empirical data from many sources.
Each record in our meta analysis database is calculated as “after-before
ratio”, which is nearly free of the studied organization’s characteristics.Because
the CMM guidelines and SQA requirement are similar, we claim that
the results for CMM programs are also applicable to investments in
SQA systems The extensive database of over 1,800 projects from a
variety of 19 information sources leading to the meta analysis results
– proved that investments in CMM programs and similarly in SQA systems
contribute to software development performance.},
 author = {D. Galin, M. Avrahami},
 inserir = {true},
 quality = {2.5},
 references = {Attaining Level 5 in CMM Process Maturity

Benefits of CMM-Based Software Process Improvement: Initial Results

Benefits realized from climbing the CMM ladder

Demonstrating the Impact and Benefits of CMMI: An Update and Preliminary
Results

Do Quality Certification Improve Software Industry’s Operational Performanc

Does Quality Certification Improve Software Industry’s Operational
Performance – Supplemental material

Ericsson: Benefits from continuous software process improvements -
The Ericsson Strategic Software Initiative

Honeywell Building Solutions Center, Europe - Achieving Level 3 in
30 Months, The Honeywell BSCE Case

How CMM Impacts Quality, Productivity, Rework, and the Bottom Line

How Software Process Improvement Helped Motorola

Implementing the Capability Maturity Model for Software Development

Practices of an SEI CMM level 5 SEPG

Raytheon Electronic Systems Experience in Software Process Improvement

SEI CMM level 5: For the right reasons

Software Improvements in an International Company

Software Process Improvement in the NASA Software Engineering Laboratory

Software Process Improvement Journey (From Level 1 To Level 5)

Software Process Improvement Lessons Learned at Litton Data Systems

Software Process Improvement Works!

Software Process Improvement: What is the Cost?, what is the Return
on Investment?

Telcordia Technologies: The journey to high maturity

The Evolution of Quality Processes at Tata Consultancy Services},
 timestamp = {2010.02.09},
 title = {Do SQA programs work – CMM works: A meta analysis},
 year = {2005}
}

@article{I[8],
 abstract = {Are CMM program investments beneficial? Analyzing past studiesCMM
experts strongly believe that investments in programs promoting an
organization's CMM maturity yield substantial organizational and
economic benefits. In particular, they argue that CMM programs that
implement software process improvements can provide more benefits.},
 author = {D. Galin, M. Avrahami},
 inserir = {true},
 quality = {2.5},
 references = {Attaining Level 5 in CMM Process Maturity

Benefits of CMM-Based Software Process Improvement: Initial Results

Benefits Realized from Climbing the CMM Ladder

CMM for the Right Reasons

How CMM Impacts Quality, Productivity, Rework, and the Bottom Line

How Software Process Improvement Helped Motorola

Implementing the Capability Maturity Model for Software Development

Practices of an SEI CMM Level 5 SEPG

R. Dion Raytheon Electronic Systems Experience in Software Process
Improvement

Return on Software Process Improvement

SEI CMM Level 5: For the Right Reasons

Software Improvements in an International Company

Software Process Improvement in the NASA Software Engineering Laboratory

Software Process Improvement Journey (From Level 1 to Level 5)

Software Process Improvement Works!

Software Process Improvement: What Is the Cost? What Is the Return
on Investment?

Telcordia Technologies: The Journey to High Maturity

The Cascading Benefits of Software Process Improvement

The Evolution of Quality Processes at Tata Consultancy Services},
 timestamp = {2010.02.09},
 title = {Are CMM program investments beneficial? Analyzing past studies},
 year = {2006}
}

@article{I[9],
 abstract = {Comparing the topics and methods of the three major subdivisions of
the computing realm.},
 author = {R. L. Glass, V. Ramesh, I. Vessey},
 inserir = {true},
 quality = {2.0},
 references = {A comparative analysis of the topic areas of computer science, software
engineering, and information systems

An assessment of systems and software engineering scholars and institutions

Computing research programs in the U.S.

Experimental evaluation in computer science: a quantitative study

On site: global perceptions of IS journals

Professional accreditation of information systems programs

The classification

The profession of IT: The IT schools movement

The supply and demand of information systems doctorates: past, present,
and future

The Supply of Information Technology Workers in the United States},
 timestamp = {2010.02.09},
 title = {An analysis of research in computing disciplines},
 year = {2004}
}

